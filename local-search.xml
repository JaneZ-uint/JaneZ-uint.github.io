<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mathematical-Logic4</title>
    <link href="/2025/03/14/Mathematical-Logic4/"/>
    <url>/2025/03/14/Mathematical-Logic4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）但是，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"><a href="#Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）但是，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜" class="headerlink" title="Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）但是，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"></a>Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）但是，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜</h5><h1 id="Mathematical-Logic-4-同构引理的证明-替换"><a href="#Mathematical-Logic-4-同构引理的证明-替换" class="headerlink" title="Mathematical Logic 4 同构引理的证明 &amp; 替换"></a>Mathematical Logic 4 同构引理的证明 &amp; 替换</h1><h2 id="Call-back-previous-一阶逻辑语义"><a href="#Call-back-previous-一阶逻辑语义" class="headerlink" title="Call back previous 一阶逻辑语义"></a>Call back previous 一阶逻辑语义</h2><p><strong>同构</strong><br>存在一个A -&gt; B 的映射满足：</p><ol><li>是双摄</li><li>保持关系（n元关系运算符）</li><li>保持运算（n元函数运算符）</li><li>保持常量（常数c）</li></ol><p>则结构A、结构B同构</p><p>在上周的作业中，我们证明了同构是一种等价关系。回忆，等价关系需要满足三个条件：</p><ol><li>自反性</li><li>对称性</li><li>传递性</li></ol><h2 id="同构引理的证明"><a href="#同构引理的证明" class="headerlink" title="同构引理的证明"></a>同构引理的证明</h2><p>Recall:<br>A、B是2个同构的S-结构，那么对于所有S-sentence 𝜑，有：</p><p>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑 </p><p>Prof:<br>由重合引理可知：<br>A |&#x3D; 𝜑 ⟺ (A,β) |&#x3D; 𝜑<br>B |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>so A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑  ⟺  (A,β) |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>定义β^𝜋(x) :&#x3D; 𝜋(β(x))<br>那么我们要证：<br>(A,β) |&#x3D; 𝜑 ⟺ (B,β^𝜋) |&#x3D; 𝜑 (𝜑 是任意S-公式)<br>&#x2F;&#x2F; 这不就从句子推广到公式上了嘛 </p><p>也就是要证明：<br>I:&#x3D; (A,β) I^𝜋:&#x3D; (B,β^𝜋)<br>𝜋(I(t)) &#x3D; I^𝜋(t)</p><p>这里改写成解释，也就可以进行结构归纳法（对公式的归纳了）<br>略</p><h2 id="项的替换-Substitution"><a href="#项的替换-Substitution" class="headerlink" title="项的替换 Substitution"></a>项的替换 Substitution</h2><p>设t 是一个S-term，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义项的替换：<br><img src="/img/%E6%9B%BF%E6%8D%A2.png" alt="替换"></p><p>(a)如果t &#x3D; x是一个变量，那么：<br><img src="/img/%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="变量替换"></p><p>(b)如果t &#x3D; c是一个常数，那么：<br><img src="/img/%E5%B8%B8%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="常量替换"></p><p>(c)对于一个函数项<br><img src="/img/%E5%87%BD%E6%95%B0%E9%A1%B9%E6%9B%BF%E6%8D%A2.png" alt="函数项替换"></p><h2 id="公式上的替换"><a href="#公式上的替换" class="headerlink" title="公式上的替换"></a>公式上的替换</h2><p>设𝜑 是一个S-formula，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义：<br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A21.png" alt="公式替换"><br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A22.png" alt="公式替换"></p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Of DS1</title>
    <link href="/2025/03/13/AlgorithmOfDS1/"/>
    <url>/2025/03/13/AlgorithmOfDS1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：最近在de-STLite的最后一个数据结构map。周二用一个下午-一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️"><a href="#Before：最近在de-STLite的最后一个数据结构map。周二用一个下午-一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️" class="headerlink" title="Before：最近在de STLite的最后一个数据结构map。周二用一个下午+一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️"></a>Before：最近在de STLite的最后一个数据结构map。周二用一个下午+一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️</h5><h1 id="Algorithm-of-Data-Structure-1-单调栈-单调队列-栈模拟递归"><a href="#Algorithm-of-Data-Structure-1-单调栈-单调队列-栈模拟递归" class="headerlink" title="Algorithm of Data Structure 1 单调栈&amp;单调队列&amp;栈模拟递归"></a>Algorithm of Data Structure 1 单调栈&amp;单调队列&amp;栈模拟递归</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>定义：栈内元素满足某种单调性质，可以单增也可以单减</p><p>在处理每个元素时，将其与栈顶元素进行比较，如果当前元素大于（或小于）栈顶元素，则将栈顶元素出栈，直到满足单调性质为止。然后，将当前元素入栈，继续处理下一个元素（<strong>当前元素必须入栈</strong>）</p><p>单调栈可以快速找到每个元素的下一个更大（或更小）元素，时间复杂度为O(n)（n为序列的长度）</p><p>具体来说，<strong>单调递增栈可用于寻找下一个更小元素，而单调递减栈可用于寻找下一个更大元素</strong>，并且只需要遍历整个序列一次</p><p>Example：找到数列中每个元素下一个比它大的元素下标（1 — base）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈顶位置</span><br>stack[top] = <span class="hljs-number">0</span>; <span class="hljs-comment">//a[0]入栈  stack数组记录栈内元素下标</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span> &amp;&amp; a[stack[top]] &lt; a[i])&#123;<br>        ans[stack[top]] = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//记录答案</span><br>        top --; <span class="hljs-comment">//当前栈顶元素出栈</span><br>    &#125;<br>    stack[++ top] = i;<br>&#125;<br><span class="hljs-keyword">while</span>(top &gt;=<span class="hljs-number">0</span>)&#123;<br>    ans[stack[top --]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈内剩余元素不存在下一个比它大的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：需要一个stack数组记录栈内情况，一个top记录栈顶位置，一个a存储原本序列数据，和一个ans存储答案</p><h2 id="单调栈例题"><a href="#单调栈例题" class="headerlink" title="单调栈例题"></a>单调栈例题</h2><p><a href="https://www.luogu.com.cn/problem/P1901">luogu P1901</a></p><ul><li>某地有N个能量发射站排成一行，每个发射站i都有不相同的高度Hi，并能向两边（两端的发射站只能向一边）同时发射能量值为Vi的能量，发出的能量只被两边最近的且比它高的发射站接收。</li><li>显然，每个发射站发出的能量有可能被0~2个其他发射站所接受。</li><li>请计算出接收最多能量的发射站接收的能量是多少。</li></ul><p>小黄题，15分钟速通😋 Strong女也只能切黄题了呜呜呜</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>main() &#123;<br>   <span class="hljs-built_in"> int </span>n;<br>    cin &gt;&gt; n;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        cin &gt;&gt; h1[i];<br>        cin &gt;&gt; v1[i];<br>    &#125;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        h2[i] = h1[n - 1 -i];<br>        v2[i] = v1[n - 1- i];<br>    &#125;<br>   <span class="hljs-built_in"> int </span>top1 = 0;<br>   <span class="hljs-built_in"> int </span>top2 = 0;<br>    stack1[top1] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top1 &gt;= 0 &amp;&amp; h1[stack1[top1]] &lt; h1[i]) &#123;<br>            ans1[stack1[top1]] = i;<br>            total1[i] += v1[stack1[top1]];<br>            top1 --;<br>        &#125;<br>        stack1[++ top1] = i;<br>    &#125;<br>    while(top1 &gt;= 0) &#123;<br>        ans1[stack1[top1 --]] = -1;<br>    &#125;<br><br>    stack2[top2] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top2 &gt;= 0 &amp;&amp; h2[stack2[top2]] &lt; h2[i]) &#123;<br>            ans2[stack2[top2]] = i;<br>            total2[i] += v2[stack2[top2]];<br>            top2 --;<br>        &#125;<br>        stack2[++ top2] = i;<br>    &#125;<br>    while(top2 &gt;= 0) &#123;<br>        ans2[stack2[top2 --]] = -1;<br>    &#125;<br><br>   <span class="hljs-built_in"> int </span>maxE = 0;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>       <span class="hljs-built_in"> int </span>current = total1[i] + total2[n - 1 - i];<br>        if(current &gt; maxE) &#123;<br>            maxE = current;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>高效地维护队列中元素的单调性（递增或递减），同时支持在队列两端的插入和删除操作</p><ul><li>可在队首出队</li><li>仅在队尾入队</li><li>如果影响单调性，可能从队尾出队</li></ul><p>省流：其实是一个双端队列（deque）（这不是隔壁这次大作业嘛🤣有福了）</p><p><strong>它通常用于解决需要在一个滑动窗口（或固定长度的子数组）内找到最大值或最小值的问题</strong></p><ul><li>插入元素：当新元素进入窗口时，从队列尾部移除所有小于新元素的元素，然后将新元素插入队列尾部。</li><li>移除元素：当元素离开窗口时，如果它是队列头部的元素，则从队列头部移除。</li><li>获取最值：队列头部的元素始终是当前窗口的最大值（或最小值，取决于单调性）</li></ul><p>可实现在O(1)的时间复杂度下获得最值<br>比如我们现在要一个递增的单调队列</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> minFront = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> minBack = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-built_in">num</span>[i] = read();<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; minWin[minFront] &lt;= i - k)&#123; <span class="hljs-comment">//队头指针小于等于队尾指针 &amp;&amp; 队头元素索引已经不在窗口范围内</span><br>        ++ minFront;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; <span class="hljs-built_in">num</span>[i] &lt; minWin[minBack])&#123;<br>        -- minBack; <span class="hljs-comment">// 将破坏单调性的元素出列</span><br>    &#125;<br>    <span class="hljs-comment">//加入队列</span><br>    minWin[++ minBack] = <span class="hljs-built_in">num</span>[i];<br>    <span class="hljs-keyword">if</span>(i &gt;= k)&#123;<br>        cout &lt;&lt; minWin[minFront];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列例子"><a href="#单调队列例子" class="headerlink" title="单调队列例子"></a>单调队列例子</h2><p>小Z的家门口种了N棵树，第i棵树在目标点xi，高度hi。<br>如果一棵树左边D距离内和右边D距离内有高度至少是它的两倍的树，那么小Z认为这棵树不够茁壮。<br>春天到了，他想给不够茁壮的树多施点肥，请你帮忙数数有几棵不够茁壮的树。</p><p>思路：长度为D（若不足D 也可）的数组（窗口），移动即可。两个方向都扫一遍</p><h2 id="栈模拟递归"><a href="#栈模拟递归" class="headerlink" title="栈模拟递归"></a>栈模拟递归</h2><p>递归过程：</p><ol><li>执行代码块0</li><li><strong>保存现场准备进入下一层</strong></li><li>接受下层返回的数据</li><li><strong>恢复现场</strong></li><li>继续执行代码块1</li></ol><p>直接用递归程序实现递归时，第二步和第四步都是编译器在帮助你完成<br>而非递归实现，我们期望：自己用实现保存现场和恢复现场</p><p>用栈模拟递归的优势在于：</p><ol><li>避免递归深度限制</li><li>更直观的控制流程</li><li>避免递归调用的开销</li></ol><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>你可以当我哑巴一样<br>你不会看见我的抵抗<br>请别怕我受伤 我自己会圆场</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Monotonic Stack</tag>
      
      <tag>Monotonic Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构4</title>
    <link href="/2025/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/"/>
    <url>/2025/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-4-字符串-树状结构"><a href="#数据结构-4-字符串-树状结构" class="headerlink" title="数据结构 4 字符串 树状结构"></a>数据结构 4 字符串 树状结构</h1><h2 id="字符串实现方式"><a href="#字符串实现方式" class="headerlink" title="字符串实现方式"></a>字符串实现方式</h2><p>当然也有<strong>顺序实现和链接实现</strong>。<br>顺序存储使用字符数组存储字符串。C语言中使用<strong>普通数组</strong>进行处理，将每个操作由一个函数实现，这些函数实现在<strong>ctring</strong>库中，但无法用运算符操纵字符串，还存在内存溢出的问题。而C++采用<strong>动态数组</strong>进行存储，实现了一个<strong>string类</strong>，根据字符串长度重新分配空间，解决了C语言存在的缺陷，但在时间性能上有所下降。</p><p>链接存储我们自然而然想到使用单链表，虽然在时间上有了很大优化，但空间利用率较低，于是我们可以考虑<strong>块状链表</strong>。<br>我们允许一个结点存在空余空间。进行分裂结点和合并结点的操作。</p><h2 id="树状结构——处理层次关系的数据结构"><a href="#树状结构——处理层次关系的数据结构" class="headerlink" title="树状结构——处理层次关系的数据结构"></a>树状结构——处理层次关系的数据结构</h2><p>树是由n个结点组成的有限集合T，并且满足：<br>1.有一个根结点<br>2.其余结点分为m个集合，这些集合本身也是一棵树<br>有些问题可以看成是树的结构，如八皇后问题（本质是DFS）</p><p>树有一些特殊的术语：</p><ul><li>根结点、叶结点、内部结点</li><li>结点的度（一个结点的直接后继数）和树的度（结点的最大度）</li><li>儿子结点</li><li>父亲结点</li><li>兄弟结点</li><li>祖先结点</li><li>子孙结点</li><li>结点所处层次</li><li>树的高度（一棵树上最大的层次号）</li><li>有序树</li><li>无序树</li><li>森林</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>满二叉树：任意一层的结点个数都达到了最大值<br>完全二叉树：在满二叉树的最底层自右向左依次去掉若干结点</p><p>二叉树的性质：</p><ul><li>第 i 层最多 2^(i - 1)个结点</li><li>高度为k，最多有2^k - 1个结点</li><li>n0 &#x3D; n2 + 1</li><li>具有n个结点的完全二叉树高度是[log_2 n] + 1</li><li>对于完全二叉树，左儿子为2i，右儿子为2i + 1</li></ul><h2 id="二叉树的运算"><a href="#二叉树的运算" class="headerlink" title="二叉树的运算"></a>二叉树的运算</h2><p>一个重要的操作：遍历<br>前序遍历、中序遍历、后序遍历</p><p>如斐波那契数列的求解过程，我们采用<strong>后序遍历</strong><br>再如快速排序过程，我们采用<strong>前序遍历</strong>（先进行划分）</p><p>前序+中序可以确定一棵二叉树<br>后序+中序也可确定一棵二叉树<br>但前序+后序不可确定一棵二叉树</p><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><p>把树的层次关系映射成线性关系，对于完全二叉树来说这是容易做到的，但对于非完全二叉树来说，就需要添加一些哑结点，把一棵普通的树修补成一棵完全二叉树（空间浪费）。<br>更多情况下我们选择<strong>链接存储</strong>二叉树。<br>标准形式：二叉链表（只存储儿子结点）<br>广义的存储方式：三叉链表（2个儿子结点+父结点）</p><p>二叉树是递归定义的，所以操作可用递归实现，我们一般把这些递归函数设为二叉树类的私有成员函数。</p><p>二叉树的遍历操作可以采用递归实现<br>前序：实现find(x) 查找操作<br>中序  后序<br>层次（可用队列实现，回顾广搜BFS）<br>递归实现：形式优美，易懂</p><h2 id="成员函数实现"><a href="#成员函数实现" class="headerlink" title="成员函数实现"></a>成员函数实现</h2><p>获得子结点</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq">T lchild(T x,T flag)&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == nullptr |<span class="hljs-type">| tmp</span> -&gt; <span class="hljs-built_in">left</span> == nullptr)&#123; //短路判别<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp -&gt; <span class="hljs-built_in">left</span> -&gt; data;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一棵树<br>可通过非递归实现（队列），也可通过递归实现</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>String</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic3</title>
    <link href="/2025/03/08/Mathematical-Logic3/"/>
    <url>/2025/03/08/Mathematical-Logic3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"><a href="#Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣" class="headerlink" title="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"></a>Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣</h5><p>🐖🐖🐖</p><h1 id="Mathematical-Logic-3-重合引理-同构引理"><a href="#Mathematical-Logic-3-重合引理-同构引理" class="headerlink" title="Mathematical Logic 3 重合引理 同构引理"></a>Mathematical Logic 3 重合引理 同构引理</h1><h2 id="概念回顾"><a href="#概念回顾" class="headerlink" title="概念回顾"></a>概念回顾</h2><p><strong>项</strong>是由<strong>变量、常量符号和函数符号</strong>通过递归方式构造的表达式。<br><strong>公式</strong>（formula）是由<strong>项</strong>通过<strong>谓词符号、逻辑连接词和量词构造</strong>的表达式。<br><strong>结构</strong>由<strong>域</strong>和<strong>解释函数</strong>组成。<br><strong>解释</strong>由<strong>结构</strong>和<strong>赋值函数</strong>（将自由变量映射到域中的元素）组成。</p><ul><li>原子公式：包括等式公式、谓词公式R</li><li>逻辑连接词：¬、∧、∨、→、↔</li><li>量词：∀xφ (x是变量，φ 是公式)、∃xφ (x是变量，φ 是公式)</li></ul><p>我们可以解释term、解释formula、解释sentence</p><h2 id="结构归纳法（对公式进行归纳）"><a href="#结构归纳法（对公式进行归纳）" class="headerlink" title="结构归纳法（对公式进行归纳）"></a>结构归纳法（对公式进行归纳）</h2><p>公式的归纳基于公式的结构，即公式的构造方式。由于公式是通过递归方式定义的（<strong>从原子公式逐步构造出复杂公式</strong>），因此我们可以使用结构归纳法来证明公式的性质。<br>公式的归纳证明通常分为以下几个步骤：</p><ul><li>证明性质𝑃对所有原子公式成立</li><li>归纳步骤：假设性质𝑃对某些公式𝜑和𝜓成立（归纳假设），然后证明𝑃对通过这些公式构造的复杂公式也成立。</li></ul><h2 id="重合引理（The-Coincidence-Lemma）"><a href="#重合引理（The-Coincidence-Lemma）" class="headerlink" title="重合引理（The Coincidence Lemma）"></a>重合引理（The Coincidence Lemma）</h2><p>设I1(A1,β1),I2(A2,β2)是2个S-解释，且满足以下条件：</p><ul><li>A1 &#x3D; A2（解释的域相同）</li><li>对于S：&#x3D; S1 ∩ S2中的每个符号，它们在A1、A2中的解释相同</li></ul><p>那么：</p><ul><li>对于任何S项t，如果β1(x) &#x3D; β2(x)对于t中的所有变量x成立，则I1(x) &#x3D; I2(x)<br>即需要满足<strong>结构的解释相同</strong>和<strong>变量的赋值相同</strong></li><li>对于任何S公式𝜑，如果β1(x) &#x3D; β2(x)对于𝜑中的所有自由变量x成立，则I1 |&#x3D; 𝜑 当且仅当 I2 |&#x3D; 𝜑<br>即需要满足<strong>结构的解释相同</strong>和<strong>自由变量的赋值相同</strong></li></ul><p>证明依赖于<strong>结构归纳法</strong></p><h2 id="同构引理（The-Isomorphism-Lemma）"><a href="#同构引理（The-Isomorphism-Lemma）" class="headerlink" title="同构引理（The Isomorphism Lemma）"></a>同构引理（The Isomorphism Lemma）</h2><p>首先给出<strong>同构</strong>的定义：<br>在模型论中，同构是指两个结构之间存在一个<strong>双射</strong>（bijection），这个双射<strong>保持了结构中的所有关系、函数和常量</strong>。<br>具体来说：<br>设A(A,I)和B(B,J)是2个S—结构，其中A和B是它们的域，I和J是解释函数。<br>一个同构𝜋：A → B是一个双射，满足以下条件：</p><ul><li>保持关系<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%85%B3%E7%B3%BB.png" alt="保持关系"></li><li>保持运算<br><img src="/img/%E4%BF%9D%E6%8C%81%E8%BF%90%E7%AE%97.png" alt="保持运算"></li><li>保持常量<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%B8%B8%E9%87%8F.png" alt="保持常量"></li></ul><p>如果存在这样的双射𝜋，则称结构A和B是同构的，记作A≅B<br>例子：群论 &amp; 图论中的同构</p><p>同构的性质：</p><ul><li>自反性（Reflexivity）：A ≅ A</li><li>对称性（Symmetry）：若A ≅ B，则B ≅ A</li><li>传递性（Transitivity）：若A ≅ B 且 B ≅ C ，则A ≅ C</li></ul><p>因此，同构是一个<strong>等价关系</strong></p><p>那么同构引理可以表示为：<br>如果A、B是两个同构的S-结构，则对于任何<strong>S-句子</strong>𝜑，有<br>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑<br>这意味着，同构的结构在一阶逻辑中无法被区分，它们满足相同的句子。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure15</title>
    <link href="/2025/03/07/Data-Structure15/"/>
    <url>/2025/03/07/Data-Structure15/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-Am-I-noisy-I-really-regret-Why-am-I-being-so-annoying-Why-am-I-becoming-jealous-of-something-unnecessary-Maybe-it’s-because-of-something-romantic-something-secret-something-I-keep-chasing-and-that-is-you-Sometimes-I-find-out-that-she-is-not-that-perfect-but-I-still-ignore-all-those-stuffs-😢😢😢"><a href="#Before-Am-I-noisy-I-really-regret-Why-am-I-being-so-annoying-Why-am-I-becoming-jealous-of-something-unnecessary-Maybe-it’s-because-of-something-romantic-something-secret-something-I-keep-chasing-and-that-is-you-Sometimes-I-find-out-that-she-is-not-that-perfect-but-I-still-ignore-all-those-stuffs-😢😢😢" class="headerlink" title="Before: Am I noisy?I really regret.Why am I being so annoying?Why am I becoming jealous of something unnecessary?Maybe it’s because of something romantic,something secret,something I keep chasing,and that is you.Sometimes I find out that she is not that perfect,but I still ignore all those stuffs.😢😢😢"></a>Before: Am I noisy?I really regret.Why am I being so annoying?Why am I becoming jealous of something unnecessary?Maybe it’s because of something romantic,something secret,something I keep chasing,and that is you.Sometimes I find out that she is not that perfect,but I still ignore all those stuffs.😢😢😢</h5><p>有人又emo了，为什么呢？因为最近发生的那些吗…就忘了吧<br>是过去，是现在，是未来</p><h1 id="Data-Structure-15-动态查找表-BST-AVL"><a href="#Data-Structure-15-动态查找表-BST-AVL" class="headerlink" title="Data Structure 15 动态查找表 BST &amp; AVL"></a>Data Structure 15 动态查找表 BST &amp; AVL</h1><p>既支持查找操作，又支持增、删操作的集合称为<strong>动态查找表</strong>。<br>动态查找表抽象类可以这样定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dynamicSearchTable</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> SET&lt;KEY,OTHER&gt;* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY&amp; x)</span> </span>== <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(CONST SET&lt;KEY,OTHER&gt;&amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY&amp; x)</span> </span>== <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">dynamicSearchTable</span>()&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用于处理动态查找表的树称为<strong>查找树</strong>(Search Tree)。另一种动态查找表的实现是<strong>散列表</strong>，它是专用于集合查找的数据结构。</p><h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 Binary Search Tree"></a>二叉查找树 Binary Search Tree</h2><p>注：鉴于关于BST的实现已经在<a href="https://janez-uint.github.io/2025/03/01/Introduction-to-Algorithms2/">Introduction to Algorithm 2</a>中实现了，这里只会简单说明一下一些要点</p><p>首先是存储：与普通二叉树的存储一样，只需存储二叉查找树的根结点<br>下面是一些运算实现：</p><ul><li>查找：从根结点开始，决定是向左子树找还是向右子树找</li><li>插入：原则上必须保证插入一个结点后，这棵树仍是一棵二叉查找树；且在插入前需要进行查找操作以确保插入的元素不会重复</li><li>（最复杂的操作）删除：如果删除的是叶结点，那么直接删除；如果删除的结点只有一侧存在结点，则那一侧的结点作为新的根结点；最复杂的是删除结点仍有2个子结点的情况，我们在右子树中找到最小的元素，为了避免大量数据元素的移动，我们选择将r的信息与这个最小的结点进行值交换，最小的那个结点成为了新的根结点，我们只需要在右子树中删除原有结点即可（划归到了1.2两种情况）</li></ul><p>（老生常谈了）BST并不保证平衡，可能退化成链表，复杂度炸了</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>注：鉴于关于AVL的思想已经在<a href="https://janez-uint.github.io/2025/03/06/Introduction-to-Algorithms3/">Introduction to Algorithm 3</a>中介绍了(<strong>特别是证明树有对数级高度</strong>)</p><p><strong>AVL树中每个结点的左右子树的高度最多差 1</strong></p><p>首先还是存储上，AVL结点多了一个量用于记录结点高度<br>具体成员函数上，有抽象类规定的插入、删除和查找函数，除此之外，在私有成员函数中还包括了一组工具函数。包括调整树的平衡的adjust函数，四种旋转函数LL、RR、LR、RL，一个求树高度的height函数，清空AVL树的clear函数。</p><h3 id="旋转rotate操作"><a href="#旋转rotate操作" class="headerlink" title="旋转rotate操作"></a>旋转rotate操作</h3><p>具体来讲一讲AVL中一个特殊的操作：<strong>维护AVL的平衡</strong>。造成AVL失衡主要有四种情况：<br><img src="/img/AVL%E6%97%8B%E8%BD%AC.png" alt="AVL四种失衡情况"></p><p>首先，我们给出四种情形的示例图：<br><img src="/img/LL%E6%83%85%E5%86%B5.png" alt="LL型情况"><br><img src="/img/LR%E6%83%85%E5%86%B5.png" alt="LR型情况"><br><img src="/img/RR%E6%83%85%E5%86%B5.png" alt="RR型情况"><br><img src="/img/RL%E6%83%85%E5%86%B5.png" alt="RL型情况"></p><p>观察树可以发现，导致出现LL、RR型进行的插入操作发生在<strong>树的外部</strong>，可以通过<strong>单旋转</strong>调整好，而LR、RL型就复杂一些，插入操作发生在<strong>树的内部</strong>，需更复杂的<strong>双旋转</strong>操作。</p><p>不妨先看LL型：<br>插入前，结点A是平衡的，结点B原来的平衡度应该为0，否则A不会失去平衡或成为第一个失去平衡的结点。经过一次右旋的操作，树依然是有序的。如选图所示：<br><img src="/img/%E5%8F%B3%E6%97%8B%E6%93%8D%E4%BD%9C.png" alt="右旋操作"></p><p>下面是代码实现（应该或许大概还是挺易懂的😢，虽然笨人已经被搞红温了）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">LL</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    AVLnode *newRoot = t.left;<br>    t.left = newRoot.right;<br>    newRoot.right = t;<br>    t -&gt; height = max(t -&gt; left,t -&gt; right) + <span class="hljs-number">1</span>;<br>    newRoot -&gt; height = max(height(t),height(newRoot -&gt; left)) + <span class="hljs-number">1</span>;<br>    t = newRoot;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理可以得到RR型，需要进行左旋操作，如下图所示：<br><img src="/img/%E5%B7%A6%E6%97%8B%E6%83%85%E5%86%B5.png" alt="左旋操作"></p><p>下面是代码实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">RR</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    AVLnode *newRoot = t.right;<br>    t.right = newRoot.left;<br>    newRoot.left = t;<br>    t -&gt; height = max(t -&gt; left,t -&gt; right) + <span class="hljs-number">1</span>;<br>    newRoot -&gt; height = max(height(t),height(newRoot -&gt; right)) + <span class="hljs-number">1</span>;<br>    t = newRoot;<br>&#125;<br></code></pre></td></tr></table></figure><p>LR、RL实际上是把LL、RR的操作进行复合<br>还是先来看一下过程吧，如图所示：<br><img src="/img/LR%E6%93%8D%E4%BD%9C.png" alt="LR操作"><br><img src="/img/RL%E6%93%8D%E4%BD%9C.png" alt="RL操作"></p><p>代码基于了LL、RR操作</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">LR</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    RR(t -&gt; left);<br>    LL(t);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">RL</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    LL(t -&gt; right);<br>    RR(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>To be honest：我觉得写成LL、RR、LR、RL的样子不是很直观，不如写成leftRotate、rightRotate、leftAndrightRotate、rightAndleftRotate，这样写至少能告诉我下面要进行怎样的操作。但单看怎么Rotate又不知道对应的哪种情况😇😇😇区别在于实现函数和调用函数的方便程度吧</p><h3 id="插入insert操作（kind-of-a-conclusion）"><a href="#插入insert操作（kind-of-a-conclusion）" class="headerlink" title="插入insert操作（kind of a conclusion）"></a>插入insert操作（kind of a conclusion）</h3><p><strong>递归算法</strong>可能是实现AVL树插入的最简单的方法，要在AVL树T中插入一个键值为x的结点，可以递归地将它插入T的某棵合适的子树（记作T’），如果插入后T’的高度没有改变，就完成了操作。否则，根据x和T及T’中的键值选择单旋转或双旋转（以T为根），操作也结束了。</p><p>与二叉查找树一样，插入操作也是通过递归实现的。如果树是空树，将结点插入为根结点，递归结束。如果插入结点比根结点小，则在左子树上插入。如果插入结点比根结点大，则在右子树上插入。只是AVL树还要多做一件事，<strong>就是在插入后要检查从插入结点到根结点的路径上有没有结点失衡</strong>。如果有，则作相应的调整。从插入结点到根结点的回溯过程由递归函数自动完成，在递归调用返回后检查根结点的平衡度。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;&amp;<span class="hljs-symbol">x</span>)&#123;<br>    insert(x,root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;&amp;<span class="hljs-symbol">x,<span class="hljs-symbol">AvlNode</span></span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        t = new AVLNode(x,<span class="hljs-literal">null</span>ptr,<span class="hljs-literal">null</span>ptr);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &lt; t -&gt; data.key)&#123;<br>        insert(x,t -&gt; left);<br>        <span class="hljs-keyword">if</span>(height(t -&gt; left) - height(t -&gt; right) == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(x.key &lt; t -&gt; left -&gt; data.key)&#123;<br>                LL(t);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                LR(t);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t -&gt; data.key)&#123;<br>        insert(x,t -&gt; right);<br>        <span class="hljs-keyword">if</span>(height(t -&gt; right) - height(t -&gt; left) == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(x.key &gt; t -&gt; right -&gt; data.key)&#123;<br>                RR(t);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                LR(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>    t -&gt; height = max(height(t -&gt; left),height(t -&gt; right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这还是比较容易的😋😋😋至多只需要调整一个结点</p><h3 id="删除remove操作"><a href="#删除remove操作" class="headerlink" title="删除remove操作"></a>删除remove操作</h3><p>两步操作：</p><ul><li>删除结点 x（与BST一样）</li><li>调整平衡</li></ul><p>删除操作没有插入操作那么幸运，调整可能导致整棵子树高度下降，从而影响该子树的父结点的平衡度。只有当某个结点的高度在删除前后保持不变，才无须继续调整。<br>下面是代码实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    remove(x,root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x,<span class="hljs-symbol">Avlnode</span></span>* &amp;<span class="hljs-symbol">t</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x == t -&gt; data.key)&#123;<br>        <span class="hljs-keyword">if</span>(t -&gt; left == <span class="hljs-literal">null</span>ptr || t -&gt; right == <span class="hljs-literal">null</span>ptr)&#123;<br>            AVLnode *oldNode = t;<br>            <span class="hljs-keyword">if</span>(t -&gt; left == <span class="hljs-literal">null</span>ptr)&#123;<br>                t = t -&gt; right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                t = t -&gt; left;<br>            &#125;<br>            delete oldNode;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        AVLNode *tmp = t -&gt; right;<br>        <span class="hljs-keyword">while</span>(tmp -&gt; left != <span class="hljs-literal">null</span>ptr)&#123;<br>            tmp = tmp -&gt; left;<br>        &#125;<br>        t -&gt; data = tmp -&gt; data;<br>        <span class="hljs-keyword">if</span>(remove(tmp -&gt; data,t -&gt; right))&#123;  <span class="hljs-comment">//若树不会变矮</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> adjust(t,<span class="hljs-number">1</span>); <span class="hljs-comment">//1表示调整右子树</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t -&gt; data.key)&#123;<br>        <span class="hljs-keyword">if</span>(remove(x,t -&gt; left))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> adjust(t,<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t -&gt; data.key)&#123;<br>        <span class="hljs-keyword">if</span>(remove(x,t -&gt; right))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> adjust(t,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/5%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="左子树删除一个结点后的5种情况"></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//返回值为true即说明高度没变，无需进一步检查平衡，反之，则需要进一步检查</span><br>template&lt;class KEY,class OTHER&gt;<br>bool AVLTree&lt;KEY,OTHER&gt;::adjust(AVLnode *&amp; t,int subtree)&#123;<br>    <span class="hljs-keyword">if</span>(subtree)&#123;  <span class="hljs-comment">//在右子树上删除，使右子树变矮</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) - height(t -&gt;</span> right) == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            -- <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> height;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) &lt; height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> right))&#123;<br>            LR(t);<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        LL(t);<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//在左子树上删除，使左子树变矮</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>) - height(t -&gt;</span> left) == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            -- <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> height;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) &gt; height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> right))&#123;<br>            RL(t);<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        RR(t);<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.csdn.net/qq_25806863/article/details/74755131">AVL树的旋转图解和简单实现</a></li><li><a href="https://blog.csdn.net/m0_45067620/article/details/117913500">二叉平衡(AVL)树中的 LL旋转、RR旋转、LR旋转、RL旋转 的详细解释</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>BST</tag>
      
      <tag>AVL</tag>
      
      <tag>Balanced Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms3</title>
    <link href="/2025/03/06/Introduction-to-Algorithms3/"/>
    <url>/2025/03/06/Introduction-to-Algorithms3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"><a href="#Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢" class="headerlink" title="Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"></a>Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢</h5><h1 id="Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL"><a href="#Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL" class="headerlink" title="Introduction to Algorithms 3 Balanced Binary Search Tree——AVL"></a>Introduction to Algorithms 3 Balanced Binary Search Tree——AVL</h1><p>First, recall an important definition of <strong>Height of a Node</strong>: <strong>length of the longest downward path to a leaf</strong></p><h2 id="The-Importance-of-Being-Balanced"><a href="#The-Importance-of-Being-Balanced" class="headerlink" title="The Importance of Being Balanced"></a>The Importance of Being Balanced</h2><p>As we talk about last time,BST suppports insert&#x2F;delete&#x2F;min&#x2F;max&#x2F;next_larger&#x2F;next_smaller or in a time complexity of <strong>O(h)</strong>.But that’s not what we want.Somehow if h equals to n,it’s gonna be really bad.</p><p>We love this tree😋😋😋：<br><img src="/img/PerfectTree.png" alt="Perfectly Balanced Binary Tree"></p><p>We hope to do some adjustments to the tree so that h can equal to <strong>logN</strong>.</p><h2 id="AVL-Trees——Adel’son-Vel’skii-Landis-1962"><a href="#AVL-Trees——Adel’son-Vel’skii-Landis-1962" class="headerlink" title="AVL Trees——Adel’son-Vel’skii &amp; Landis 1962"></a>AVL Trees——Adel’son-Vel’skii &amp; Landis 1962</h2><h3 id="Main-Defintion"><a href="#Main-Defintion" class="headerlink" title="Main Defintion:"></a>Main Defintion:</h3><p>For every node,require <strong>heights</strong> of left &amp; right children to differ by at most <strong>± 1</strong>.</p><ul><li>We mark nil trees as height <strong>-1</strong>（quite smart cuz -1 + 1 &#x3D; 0）</li><li>Each nodes stores its height</li></ul><p><img src="/img/AVL%E4%BE%8B%E5%AD%90.png" alt="An example of an AVL tree"></p><h3 id="Balance"><a href="#Balance" class="headerlink" title="Balance"></a>Balance</h3><p>Consider the largest height of an AVL tree with N nodes.(worst time complexity)<br>Equalently,we can consider <strong>the minimun node numbers of an AVL tree with height h</strong>!<br>Great thoughts!</p><p>We can do a rough Maths proof:<br>N_h &#x3D; N_(h - 1) + N_(h - 2) &gt; 2N_(h - 2)<br>&#x3D;&gt; N_h &gt; 2^(h&#x2F;2)<br>&#x3D;&gt; h &lt; 2 log(N_h)<br>So proved that h is alogN(a is a parameter)</p><p>Theoretical computer scientists can do this more accurately,like what the picture below shows using Fibonacci:<br><img src="/img/AVLproof.png" alt="The secret behind the logN height of the AVL tree"></p><h3 id="AVL-insert"><a href="#AVL-insert" class="headerlink" title="AVL insert"></a>AVL insert</h3><p>1.insert as in simple BST(just the normal one)<br>2.<strong>work your way up tree, restoring AVL property</strong>(the most important step of building the AVL tree)</p><p>Each Step of the famous <strong>AVL Rotation</strong>:</p><ul><li><p>suppose x is lowest node violating(违背) AVL</p></li><li><p>assume x is right-heavy (left case symmetric)</p></li><li><p>if x’s right child is right-heavy or balanced:<br><img src="/img/AVL%E6%97%8B%E8%BD%AC1.png" alt="AVL Inserting Balance"></p></li><li><p>else: follow steps<br><img src="/img/AVL%E6%97%8B%E8%BD%AC2.png" alt="AVL Inserting Balance"></p></li><li><p>then continue up to x’s grandparent, greatgrandparent</p></li></ul><h2 id="Other-Balanced-Trees"><a href="#Other-Balanced-Trees" class="headerlink" title="Other Balanced Trees"></a>Other Balanced Trees</h2><ul><li>B-Trees&#x2F;2-3-4 Trees Bayer and McCreight 1972 (see CLRS 18)</li><li>BB[α] Trees Nievergelt and Reingold 1973</li><li>Red-black Trees CLRS Chapter 13</li><li>Splay-Trees Sleator and Tarjan 1985</li><li>Skip Lists Pugh 1989</li><li>Scapegoat Trees Galperin and Rivest 1993</li><li>Treaps Seidel and Aragon 1996</li></ul><h2 id="Comparison-with-Heap"><a href="#Comparison-with-Heap" class="headerlink" title="Comparison with Heap"></a>Comparison with Heap</h2><p><img src="/img/HeapAVL1.png"><br><img src="/img/HeapAVL2.png"></p><h2 id="End-Start-BHW-3-Map"><a href="#End-Start-BHW-3-Map" class="headerlink" title="End(Start BHW 3 Map~~~)"></a>End(Start BHW 3 Map~~~)</h2>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>AVL</tag>
      
      <tag>Balanced Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure14</title>
    <link href="/2025/03/06/Data-Structure14/"/>
    <url>/2025/03/06/Data-Structure14/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Long-Time-No-See-这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting-always-comes-to-an-end-你是我声色张扬下欲盖弥彰的温柔理想。"><a href="#Before：Long-Time-No-See-这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting-always-comes-to-an-end-你是我声色张扬下欲盖弥彰的温柔理想。" class="headerlink" title="Before：Long Time No See!这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting always comes to an end.你是我声色张扬下欲盖弥彰的温柔理想。"></a>Before：Long Time No See!这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting always comes to an end.你是我声色张扬下欲盖弥彰的温柔理想。</h5><h1 id="Data-Structure-14-集合与静态查找表"><a href="#Data-Structure-14-集合与静态查找表" class="headerlink" title="Data Structure 14 集合与静态查找表"></a>Data Structure 14 集合与静态查找表</h1><h2 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h2><p>首先，集合中数据元素的关系十分松散，除了属于同一集合外，没有任何逻辑关系。但集合中的元素有一个区别其他元素的唯一标识，通常称为<strong>键值</strong>或<strong>关键字值</strong>。故每个集合中的元素可以看成由两部分组成：<strong>关键字值</strong>和<strong>其他信息</strong>。<br>故我们可以这样定义集合中元素的类型：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">struct</span> <span class="hljs-symbol">SET</span>&#123;<br>    KEY key;<br>    OTHER other;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于集合中元素不存在直接前驱、直接后继等，故集合中的主要操作只有<strong>添加元素、删除元素以及查找某个元素是否出现在集合中</strong>。但当集合元素非常多时，查找某个元素将花费很长时间，我们需要一种手段来<strong>加速查找过程</strong>。因此将集合中的元素按它的唯一标识排序也是集合的基本运算。</p><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><p>通常将用于查找的数据结构称为<strong>查找表</strong>。查找就是要<strong>确定指定关键字值的数据元素在查找表中是否存在</strong>。（注意，有一些特殊的情况可能会出现一些数据结构含有相同关键字值，这样的集合称为<strong>多重集</strong>，我们暂不讨论这种情况）。<br>如果查找表中的数据元素个数和每个数据元素的值是不变的，这样的查找表我们通常称为<strong>静态查找表</strong>。如果对查找表不但要进行查找操作，还要进行插入、删除操作，那么查找表将是动态变化的，其数据元素的个数并不是一个稳定的常数，这样的查找表通常称为<strong>动态查找表</strong>。<br>显而易见，动态查找表的要求更高呢😢不仅要查找迅速，插入删除也要迅速（已经开始😇）</p><p>被查找的所有数据元素全部存放在<strong>内存储器</strong>中时的查找操作称为<strong>内部查找</strong>，如果数据元素太多，不能全部放在内存之中，只能将它们存放到<strong>外存储器</strong>中去，这时的查找操作便称之为<strong>外部查找</strong>。在外存储器中，每个数据元素通常称为<strong>记录</strong>。<br>在内部查找中，一般以比较次数作为衡量时间性能的一个标准。在外部查找中，被查找的数据是存储在外存储器上，查找时必须把<strong>外存储器</strong>上的数据<strong>读入内存</strong>。与外存访间相比，比较时间是微不足道的，所以在外部查找中一般以<strong>外存储器的访问次数</strong>作为衡量标准。<strong>减少访问外存的次数</strong>，将会大大减少查找的时间代价。</p><p>如果没记错（就是没记错），BPT也是要在外存上实现的吧。。。😇😇😇😇😇</p><h2 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h2><p>数据元素个数及数据元素的值不允许变化的查找表称为<strong>静态查找表</strong>。（嗯几秒前刚讲过🤣）通常将被查找的数据存放在一个<strong>数组或顺序表</strong>中。</p><p>与其他各类数据结构一样，各个静态查找表中的数据元素类型是不一样的，因此，查找函数应该是一个函数模板。模板参数是数据元素的类型。静态查找表可以存放在一个数组中，也可以存放在 C+＋的标准模板库中的类模板vector中。</p><h2 id="无序表的查找——顺序查找"><a href="#无序表的查找——顺序查找" class="headerlink" title="无序表的查找——顺序查找"></a>无序表的查找——顺序查找</h2><p>由于无序表中元素无序，只能顺序查找按顺序检查保存在数组中的集合元素，直到找到一个匹配为止。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqSearch</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;<span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    data[<span class="hljs-number">0</span>].key = x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = size;data[i].key != x;i --);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这样写少了一次检查下标是否合法的比较，利用0处作为哨岗<br>时间复杂度为O(N)</p><h2 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h2><p>当集合中的元素是按照关键字值的次序存放在数组时，称为<strong>有序表</strong>。</p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>以按递增顺序存储为例</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqSearch</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;<span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    data[<span class="hljs-number">0</span>].key = x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = size;data[i].key &gt; x;i --);<br>    <span class="hljs-keyword">if</span>(data[i].key == x &amp;&amp; i != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqSearch</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;<span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-built_in">int</span> low = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> high = size;<br>    <span class="hljs-built_in">int</span> mid;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        mid = (low + high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(data[mid] == x)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[mid] &lt; x)&#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(logN)</p><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>假设分布均匀，则可利用公式判断位置：<br><code>next = low + (high - low + 1)*(x - a[low])/(a[high] - a[low])</code><br>但缺点同样很明显：计算太繁杂了（鼠鼠现在的算力手算兴许是算不出来的吧🤣🤣🤣）<br>所以使用插值查找需满足2个假设：<br>1.访问一个数据元素必须比一个典型的指令费时得多。例如，数组可能在磁盘里而不是在内存里，而且每次比较都需要<strong>访问一次磁盘</strong>。<br>2.这些数据必须不仅有序，而且分布相当均匀，这可以使每次估计都相当准确。</p><h3 id="分块查找😋😋😋"><a href="#分块查找😋😋😋" class="headerlink" title="分块查找😋😋😋"></a>分块查找😋😋😋</h3><p>这不是小作业刚做完的嘛嘻嘻，爽到了🥰🥰🥰<br>这不是Bookstore的文件存储测试，可爱的（逆天的阴间的）BlockList嘛🤣现在还挺喜欢BlockList的，笑死了，感觉还是挺好写的嘻嘻嘻<br><img src="/img/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE.png" alt="分块查找表"></p><p>这张图真是太清楚了，如果早点看到，一切就会不同吧😥<br>总结一下，分块查找分两个阶段。先查找索引表，<strong>确定数据所在的块</strong>。由千索引表是有序的，可以采取<strong>顺序查找或二分查找</strong>。第二步是<strong>块内查找</strong>。如果块内是有序的，可以采用二分查找。如果块内是无序的，则只能采用顺序查找。<br>挺简单的，这是真心话，真简单，真的太简单了。真服了🤡</p><p>时间复杂度即便都采用顺序查找，也可以达到O(sqrt(N))，还是很快的？<br>尽情期待B PLUS TREE~~~</p><h2 id="STL不给用，就不说了（也没啥值得说的bushi）"><a href="#STL不给用，就不说了（也没啥值得说的bushi）" class="headerlink" title="STL不给用，就不说了（也没啥值得说的bushi）"></a>STL不给用，就不说了（也没啥值得说的bushi）</h2>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构3</title>
    <link href="/2025/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"/>
    <url>/2025/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-3-队列"><a href="#数据结构-3-队列" class="headerlink" title="数据结构 3 队列"></a>数据结构 3 队列</h1><h2 id="Where-队列？"><a href="#Where-队列？" class="headerlink" title="Where 队列？"></a>Where 队列？</h2><p>计算机中CPU将时间切成很多个小的时间单元，实际上是轮流在为用户服务，存在一个等待运行的过程——尽情期待《操作系统》（bushi）</p><p>银行ATM 取款机 排队的过程</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>难以判断是满是空时，我们一般选择牺牲一个单元（但似乎记录一下队列的长度也可以解决问题）</p><p>循环队列类同样需要由队列的抽象类派生<br>即便是循环队列同样可能存在存储空间不够的情况，所以我们仍然需要私有成员函数doubleSpace，需要注意的是，这里的doubleSpace函数在平移数据时，<strong>需要从front开始</strong></p><h2 id="队列链接实现"><a href="#队列链接实现" class="headerlink" title="队列链接实现"></a>队列链接实现</h2><p>使用不带头结点的单链表实现，同时需要记录头尾结点的位置（空间换时间），这样就使得入队（在链表尾处实现）和出队（在链表头实现）的复杂度都是O(1)的时间复杂度。<br>注意：这里是因为在链表头插入删除都很方便，但在链表尾处插入操作是O(1)的，但删除操作需要将队尾元素前一个元素的next指针置空，复杂度达到了O(n)，故我们考虑在头处删除（对应出队操作），在尾处插入（对应入队操作）</p><p>更要注意的是，在enQueue（入队操作）时，如果尾结点是空指针，<strong>需要进行特判</strong>（RE启动！）<br>deQueue操作需要返回出队元素的值，所以还要先保存那个值，同时记得delete（leak启动！）还有一个特殊情况，就是当队中只有一个元素时，将其出队后，需要将尾结点也置空。</p><h2 id="STL中的队列"><a href="#STL中的队列" class="headerlink" title="STL中的队列"></a>STL中的队列</h2><p>和栈一样，是容器适配器，借助已有线性表。由于vector在表头操作很糟糕，所以我们一般采用list和deque。<br>包含头文件<br><code> #include&lt;queue&gt;</code></p><h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><h3 id="列车车厢重排"><a href="#列车车厢重排" class="headerlink" title="列车车厢重排"></a>列车车厢重排</h3><p>一列货运列车共有n节车厢，每节车厢将被放在不同的车站。假定n个车站的编号分别为1 – n，货运列车按照第n站到第1站的次序经过这些车站。车厢的编号与它们的目的地相同。为了便于从列车上卸掉相应的车厢，必须重新排列这些车厢，将第n节车厢放在最后，第1节车厢放在最前面。</p><p>Thought：利用k根轨道重排n节车厢，初始排列次序在数组in中</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">arrange</span><span class="hljs-params">(<span class="hljs-type">int</span> in[],<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    linkQueue&lt;<span class="hljs-type">int</span>&gt; *buffer = <span class="hljs-keyword">new</span> linkQueue&lt;<span class="hljs-type">int</span>&gt;;<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">putbuffer</span>(buffer,k,in[i])) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">checkbuffer</span>(buffer,k,last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">putbuffer</span><span class="hljs-params">(linkQueue&lt;<span class="hljs-type">int</span>&gt;*buffer,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> in)</span></span>&#123;<br>    <span class="hljs-type">int</span> avail = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; size;j ++)&#123;<br>        <span class="hljs-keyword">if</span>(buffer[j].<span class="hljs-built_in">isEmpty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(avail == <span class="hljs-number">-1</span>)&#123;<br>                avail = j;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(buffer[j].<span class="hljs-built_in">getTail</span>() &lt; in &amp;&amp; buffer[j].<span class="hljs-built_in">getTail</span>() &gt; max)&#123;<br>                avail = j;<br>                max = buffer[j].<span class="hljs-built_in">getTail</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(avail != <span class="hljs-number">-1</span>)&#123;<br>        buffer[avail].<span class="hljs-built_in">enQueue</span>(in);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkbuffer</span><span class="hljs-params">(linkQueue&lt;<span class="hljs-type">int</span>&gt;*buffer,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;last)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag)&#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; size;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(!buffer[j].<span class="hljs-built_in">isEmpty</span>()&amp;&amp; buffer[j].<span class="hljs-built_in">getHead</span>() == last + <span class="hljs-number">1</span>)&#123;<br>                last ++;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排队系统的模拟"><a href="#排队系统的模拟" class="headerlink" title="排队系统的模拟"></a>排队系统的模拟</h3><p><strong>模拟</strong>（simulation）是计算机的一个重要应用，是指用计算机来仿真现实系统的操作并收集统计数据。</p><p><strong>虚拟时间</strong><br>模拟系统是一个虚拟的系统，一般不需要使用真实的精确时间，只要用一个时间单位即可，这个时间单位叫做一个嘀嗒。一个嘀嗒可以表示1秒，也可以表示1分钟，也可以表示一小时，这根据应用来决定。</p><p><strong>时间驱动的模拟</strong><br>工作过程：沿着时间轴模拟这一时刻发生的事情，并做相应的处理<br>如龟兔赛跑</p><h3 id="事件驱动的模拟"><a href="#事件驱动的模拟" class="headerlink" title="事件驱动的模拟"></a>事件驱动的模拟</h3><p>工作过程：按事件发生的时间一件一件处理<br>如排队系统的模拟<br>特点:</p><ul><li>事件不是连续发生的</li><li>没有必要模拟没有事件发生的时间</li></ul><h3 id="如何产生顾客到达事件和服务时间"><a href="#如何产生顾客到达事件和服务时间" class="headerlink" title="如何产生顾客到达事件和服务时间"></a>如何产生顾客到达事件和服务时间</h3><p>尽管服务时间和顾客到达的间隔时间是可变的，但从统计上来看是服从一定的概率分布。<br>要生成顾客的到达时间或生成服务时间必须掌握如何按照某个概率生成事件。<br>如顾客到达的间隔时间服从[a，b]之间的均匀分布，则可以生成一个[a，b]之间的一个随机数x，表示前一个顾客到达后，经过了x的时间后又有一个顾客到达了。<br><code>rand() * (b – a + 1)/(RAND_MAX + 1) + a</code></p><h3 id="设计单服务台排队系统"><a href="#设计单服务台排队系统" class="headerlink" title="设计单服务台排队系统"></a>设计单服务台排队系统</h3><p>设计一个只有一个服务台的排队系统，希望通过这个模拟器得到顾客的平均排队时间。顾客到达的时间间隔服从[arrivaLow, arrivalHigh]的均匀分布；服务时间长度服从[serviceTimeLow, serviceTimeHigh]间的均匀分布；一共模拟customNum个顾客。要求统计顾客的平均排队时间。</p><h3 id="模拟过程"><a href="#模拟过程" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>生成所有的顾客到达事件，按到达时间排成一个队列。</p><ul><li>依次处理队列中的每个元素，直到队列为空</li><li>检查顾客的到达时间和当前时间，计算等待时间，记入累计值；</li><li>生成顾客服务时间</li><li>将当前事件拨到该顾客的离开时间</li><li>返回累计值除以顾客数的结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms2</title>
    <link href="/2025/03/01/Introduction-to-Algorithms2/"/>
    <url>/2025/03/01/Introduction-to-Algorithms2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：风止于秋水，我止于你"><a href="#Before：风止于秋水，我止于你" class="headerlink" title="Before：风止于秋水，我止于你"></a>Before：风止于秋水，我止于你</h5><h1 id="Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort"><a href="#Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort" class="headerlink" title="Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort"></a>Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort</h1><h2 id="Base-on"><a href="#Base-on" class="headerlink" title="Base on ?"></a>Base on ?</h2><p><strong>Runway Reservation System</strong>!!!(My favourite plane! We’re saved!)</p><p><img src="/img/Runway.png" alt="Runway Reservation System"></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Each node x in the binary tree has a key <strong>key(x)</strong>.Nodes other than the root have a <strong>parent p(x)</strong>.Nodes may have a left child <strong>left(x)</strong> and&#x2F;or a right child <strong>right(x)</strong>.<br>ps：ALL POINTERS!Unlike in the Heap.</p><p><strong>Characteristics</strong>：for any node x, for all nodes y in the left subtree of x, key(y) ≤ key(x). For all nodes y in the right subtree of x key(y) ≥ key(x).</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>As the picture shows below🤓<br><img src="/img/BST%E6%8F%92%E5%85%A5.png" alt="BST insert operation"></p><p>Under the problem,we need to do the “Within K minutes Check” before inserting.If doesn’t follow,then stop the insertion.</p><h2 id="Find-Exists-find-val"><a href="#Find-Exists-find-val" class="headerlink" title="Find Exists : find(val)"></a>Find Exists : find(val)</h2><p>Follow left and right pointers until you find it or hit NIL.</p><h2 id="Find-the-minimum-element-in-a-BST-findmin"><a href="#Find-the-minimum-element-in-a-BST-findmin" class="headerlink" title="Find the minimum element in a BST : findmin()"></a>Find the minimum element in a BST : findmin()</h2><p>Just go left until you can’t.</p><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><p>All the operations above have an O(h) time complexity.<br>ps: <strong>h is the height of BST</strong></p><p>We may find a problem: somehow in a tricky (or abstract) way of insertion, the BST may turn to a <strong>List</strong>.So the complexity will be O(n),but we hope O(logn).😣😣😣</p><p>We’re gonna talk about it next time in the <strong>AVL Chapter</strong>😋😋😋<br>Balanced BSTs to the rescue in the next lecture!</p><h2 id="Find-the-next-larger-element-next-larger-x"><a href="#Find-the-next-larger-element-next-larger-x" class="headerlink" title="Find the next larger element: next_larger(x)"></a>Find the next larger element: next_larger(x)</h2><p>IF right child is not NIL,return minimun(x -&gt; right)<br>    else y &#x3D; parent(x)</p><pre><code class="hljs">while y not NIL and x = right(y)    x =  y    y = parent(y)return y;</code></pre><h2 id="How-many-planes-are-scheduled-to-land-at-times-≤-t"><a href="#How-many-planes-are-scheduled-to-land-at-times-≤-t" class="headerlink" title="How many planes are scheduled to land at times ≤ t?"></a>How many planes are scheduled to land at times ≤ t?</h2><p>Algorithm:<br>1.Walk down tree to find desired time( find t pos )<br>2.Add in nodes that are smaller<br>3.Add in subtree sizes to the left( record the size of the subtrees)</p><h2 id="附上早上手写的BST"><a href="#附上早上手写的BST" class="headerlink" title="附上早上手写的BST"></a>附上早上手写的BST</h2><p>（由于赶时间就没写类模板了，int型BST凑合看看吧😢）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by JaneZ on 2025/3/2.</span><br><span class="hljs-comment">//</span><br>#ifndef BST_H<br>#define BST_H<br>#include &lt;cstdio&gt;<br><br>class BinarySearchTree &#123;<br>private:<br>    struct treeNode &#123;<br>        treeNode *parent;<br>        treeNode *left;<br>        treeNode *right;<br>        int count; <span class="hljs-comment">//单个结点出现次数</span><br>        int size; <span class="hljs-comment">//以该结点为根 的子树大小</span><br>        int value; <span class="hljs-comment">//存储的值，这里以整数为例</span><br><br>        treeNode(treeNode *p = nullptr,treeNode *l = nullptr,treeNode *r = nullptr,int c = <span class="hljs-number">1</span>,int s = <span class="hljs-number">1</span>,int v = <span class="hljs-number">0</span>):<br>        parent(p),left(l),right(r),count(c),size(s),value(v)&#123;&#125;<br>    &#125;;<br><br>    treeNode *root;<br><br>    treeNode *buildTree(treeNode *other) &#123;<br>        <span class="hljs-keyword">if</span>(other != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">treeNode</span> *r = new treeNode(nullptr,nullptr,nullptr,other-&gt;</span><span class="hljs-function"><span class="hljs-title">count</span>,other-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>,other-&gt;</span>value);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = buildTree(other -&gt;</span> left);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = buildTree(other -&gt;</span> right);<br>            return r;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            return nullptr;<br>        &#125;<br>    &#125;<br><br>    void clear(treeNode *r) &#123;<br>        <span class="hljs-keyword">if</span>(r != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> left);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> right != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> right);<br>            &#125;<br>            delete r;<br>        &#125;<br>    &#125;<br>public:<br>    BinarySearchTree():root(nullptr)&#123;&#125;<br><br>    BinarySearchTree(const BinarySearchTree &amp;other) &#123;<br>        root = buildTree(other.root);<br>    &#125;<br><br>    ~BinarySearchTree() &#123;<br>        clear(root);<br>    &#125;<br><br>    treeNode *search(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == val) &#123;<br>            return r;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &lt; r -&gt;</span> value)&#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> right,val);<br>        &#125;<br>    &#125;<br><br>    treeNode *insert(treeNode *r,int key) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            r = new treeNode(nullptr,nullptr,nullptr,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,key);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == key) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span>count ++;<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &lt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> left,key);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &gt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//返回新的根结点</span><br>    treeNode *remove(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(val &lt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = remove(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> right,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> count &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> count --;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr ) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> right;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> right == nullptr) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> left;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//用右子树的最小值作为新的根结点</span><br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *pos = findMin(r -&gt;</span> right);<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> = pos -&gt;</span> count;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">value</span> = pos -&gt;</span> value;<br>                    <span class="hljs-function"><span class="hljs-title">pos</span> -&gt;</span> count = <span class="hljs-number">1</span>;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,pos -&gt;</span> value);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    treeNode *findMin(treeNode *r) &#123;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> = r -&gt;</span> left;<br>        &#125;<br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名</span><br>    int queryRank(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value == val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                return <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value &gt; val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">return</span> queryRank(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> 1 + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名为第k名的树</span><br>    int queryKth(treeNode *r,int k) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> left ,k);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> count &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,k - (r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> : 0) - r -&gt;</span> count);<br>    &#125;<br>&#125;;<br><br>#endif <span class="hljs-comment">//BST_H</span><br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Still an easy one.Can’t wait to see AVL!<br>立下flag，争取这周搞定用AVL实现的map!😋</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Algorithms1</title>
    <link href="/2025/03/01/Introduction-to-Algorithms1/"/>
    <url>/2025/03/01/Introduction-to-Algorithms1/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"><a href="#Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭" class="headerlink" title="Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 @three-hats-user 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"></a>Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 <a href="https://github.com/Jxint001">@three-hats-user</a> 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭</h4><h1 id="Introduction-to-Algorithms-1-Heaps-and-heap-sort"><a href="#Introduction-to-Algorithms-1-Heaps-and-heap-sort" class="headerlink" title="Introduction to Algorithms 1  Heaps and heap sort"></a>Introduction to Algorithms 1  Heaps and heap sort</h1><h2 id="Priority-Queues-Definition"><a href="#Priority-Queues-Definition" class="headerlink" title="Priority Queues Definition"></a>Priority Queues Definition</h2><p>A data structure implementing a set S of elements,each associated with a key,supporting the following operations: </p><ul><li>insert(S,x)</li><li>max(S)</li><li>extract_max(S):return element of S with largest key and remove it from S</li><li>increase_key(S,x,k):increase the value of element x’ s key to new value k</li></ul><p>Priority Queues can be built by using Heap or AVL.</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>As I said seconds before,<strong>Heap</strong> is one of the Implementations of a priority queue.</p><p>First,we are going to visualize an <strong>Array</strong> as a <strong>nearly complete binary tree</strong>（完全二叉树）</p><p>Let’s just talk about <strong>Max Heap</strong> here（Min Heap is exactly the same）</p><p><strong>Max Heap Property</strong>:The key of a node is $\geq$ than the key children.<br>For example:</p><p><img src="/img/%E5%A4%A7%E6%A0%B9%E5%A0%86%E4%BE%8B%E5%AD%90.png" alt="Max Heap Example"></p><p>Almost the same basic characteristics as Binary Tree</p><p>Here’re some simple Heap Operations:</p><ul><li>build max heap: produce a max-heap from an unordered array</li><li><strong>max_heapify</strong>: correct a single violation(违反) of the heap property in a subtree at its root</li><li>insert,extract_max,heapsort</li></ul><h3 id="The-most-important-procedure-Max-heapify"><a href="#The-most-important-procedure-Max-heapify" class="headerlink" title="The most important procedure: Max_heapify"></a>The most important procedure: Max_heapify</h3><p>• Assume that the trees rooted at left(i) and right(i) are max-heaps.</p><p>• If element A[i] violates the max-heap property, correct violation by “trickling” element A[i] down the tree, making the subtree rooted at index i a max-heap.</p><p>Here is an example of Max_heapify:<br><img src="/img/Heapify1.png" alt="Max_heapify1"><br><img src="/img/Heapify2.png" alt="Max_heapify2"><br><img src="/img/Heapify3.png" alt="Max_heapify3"></p><p>Time Complexity: O(logN)</p><h3 id="Build-Max-Heap"><a href="#Build-Max-Heap" class="headerlink" title="Build Max Heap"></a>Build Max Heap</h3><p>For n&#x2F;2 to 1  &#x2F;&#x2F;从后往前第一个非叶节点开始<br>    do Max_heapify(A,i)</p><p>这里我们很容易“看出”时间复杂度是O(NlogN)，然而真的如此嘛？<br>可以想一下，最底一层的非叶结点进行的操作次数至多只有1次，而并非logN次，只有根结点才会进行logN次操作，所以经过数学推导，我们可以验证，建堆操作的时间复杂度是O(N)</p><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p>I think it’s just a simple use of Max_Heap.Easy to understand and I will just show the thoughts.<br>(1)Build Max_Heap from an unordered array.<br>(2)Find A[1] (the biggest element)<br>(3)Swap elements A[1] and A[n]<br>(4)Discard(移除) n from the heap<br>(5)Run MaxHeapify to fix the missing 1 place<br>(6)Go to Step 2 until empty</p><p>The time complexity of Heap Sort is O(NlogN)</p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>这节的内容整体还是挺容易的，特别是在写完priority_queue之后😋<br>Keep Going!</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic2</title>
    <link href="/2025/02/28/Mathematical-Logic2/"/>
    <url>/2025/02/28/Mathematical-Logic2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"><a href="#Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅" class="headerlink" title="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"></a>Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅</h5><h5 id="Result：果断重开了"><a href="#Result：果断重开了" class="headerlink" title="Result：果断重开了"></a>Result：果断重开了</h5><h5 id="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"><a href="#Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！" class="headerlink" title="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"></a>Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！</h5><h1 id="Mathematical-Logic-2-一阶逻辑的语义"><a href="#Mathematical-Logic-2-一阶逻辑的语义" class="headerlink" title="Mathematical Logic 2 一阶逻辑的语义"></a>Mathematical Logic 2 一阶逻辑的语义</h1><h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><p>在不同的场合下，同一个一阶逻辑命题可能有不同的含义。如对∀v0Rv0v0，既可以解读成“任意自然数都整除自己”（真），也可以解读成“任何实数都小于自己”（假）<br>So：讨论语义时首先需要确定讨论的数学对象</p><p>刚刚的例子中，自然数和实数明确了讨论对象取自怎样的集合，这个集合称作<strong>域</strong>（universe），记为A</p><p>确定符号集中每个符号的含义，就是确定每个符号对应的元素、集合或映射具体是什么：</p><ul><li>一个n元关系就是某个A^n的子集 a(R)</li><li>一个n元函数就是某个A^n到A的映射 a(f)</li><li>每个常数符号对应A中某个特定元素 a(c)</li></ul><p>我们把这个从符号到其具体含义的映射记为a。<br>A 和 a 确定了一阶逻辑中变量的“定义域”和符号集中每个符号的含义。我们把二元组(A,a)记为 𝔄，称作<strong>S-结构</strong>。</p><p>对于符号集S &#x3D; {R,f,c}，我们通常将a(R)写作$R^𝔄$或$R^A$，a(f)写作$f^𝔄$或$f^A$，a(c)写作$c^𝔄$或$c^A$。</p><h2 id="Interpretation-解释"><a href="#Interpretation-解释" class="headerlink" title="Interpretation 解释"></a>Interpretation 解释</h2><p>Structure给出了变量的定义域和符号集的语义，但我们接下来还有<strong>terms</strong>和<strong>formulas</strong></p><p><strong>一个term的语义是从一个term到universe中一个元素的映射</strong>——$\beta$<br>为了确定这个映射，我们首先需要知道term中的每个变量代表universe当中的哪个元素，这就是要我们给出一个$v_i$ -&gt; A 的映射$\beta$</p><p>所以我们把一个S-structure和一个S-assignment的二元组称作I &#x3D; (𝔄,$\beta$)<br>定义<strong>解释</strong>的语义</p><ul><li>对于变量x，I(x) &#x3D; $\beta$(x)</li><li>对于常量c，I(c) &#x3D; $c^𝔄$</li><li>对于n元函数关系f $\in$ S，$t_1,t_2,…,t_n$均为S-terms。那么有I(ft_1 … t_n) &#x3D; $f^𝔄$(I(t_1),I(t_2),…,I(t_n))</li></ul><p><strong>formula的语义是从一个term到“真或假”的映射(类似于bool?)</strong><br>对于一个formula 𝜑  ，我们用记号 I |&#x3D; 𝜑  来表示 公式 𝜑 的语义为真，读作I 满足𝜑 ，|&#x3D; 即称为<strong>满足关系</strong>。（ 解释 I 满足公式 𝜑  ）</p><p>下面是一些原子性&#x2F;关于逻辑连词&#x2F;量词的情况<br><img src="/img/%E8%A7%A3%E9%87%8A%E6%BB%A1%E8%B6%B3%E5%85%AC%E5%BC%8F.png" alt="解释满足formulas"></p><p>(a) 当且仅当I(t_1)，I(t_2)是universe下的同一个元素<br>(b) 当且仅当 (I(t_1),…,I(t_n)) 属于$R^𝔄$<br>(c) 当且仅当 解释I 不满足公式 𝜑<br>(d) 当且仅当 解释I 满足公式 𝜑 且 解释I 满足公式Ψ<br>(e) 当且仅当 解释I 满足公式 𝜑  或 解释I 满足公式Ψ<br>(f) （一个有点神奇的解释）当且仅当 I |&#x3D; φ（语法上）表明解释I 满足公式 𝜑 （语义上）<br>(g) 当且仅当（还有一个当且仅当，亿点点绕）（解释I 满足 公式 𝜑 当且仅当解释I 满足公式Ψ）</p><p>比较复杂的就是 ∀ 和 ∃<br>(h) 想说的意思是：当且仅当universe中每个元素为公式 𝜑 中出现的x赋值并保持其他变量赋值不变，公式 𝜑 始终不变</p><p>为此我们定义一个描述为formula中的某个特定变量赋特殊的值的方便的符号：<br><img src="/img/Assignment.png" alt="修改赋值函数"></p><p>于是新的解释I 变为了：<br><img src="/img/%E6%96%B0%E8%A7%A3%E9%87%8A.png" alt="新的解释"><br>这表示在解释I 中，将变量 𝑥 的赋值修改为 𝑎，其他部分保持不变。</p><p>于是(h)表示的即为：对于域 𝐴中的每一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 都为真。</p><p>(i) （也是同理）存在域 𝐴中的一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 为真。</p><p>如果一个公式 𝜑 是valid(恒真)，那么所有的解释都能满足公式 𝜑</p><p>逻辑推论的定义：<br>Φ 是一个S-公式的集合；<br>公式 𝜑 是一个单独的S-公式<br>如果 Φ |&#x3D; 𝜑，表示 𝜑 是 Φ 的逻辑推论，即公式 𝜑 可以从 Φ 中逻辑推导出来</p><p>我们称公式 𝜑 是可满足的，如果存在一个S-解释I，使得公式 𝜑 在解释I下为真</p><p>公式 𝜑 和公式 Ψ 是逻辑等价的，如果 𝜑 |&#x3D; Ψ 且 Ψ |&#x3D; 𝜑</p><p><img src="/img/%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7.png" alt="逻辑等价例子"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/">https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/</a></p><p>这位博主真的救命，讲的太清楚了</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure13</title>
    <link href="/2025/02/27/Data-Structure13/"/>
    <url>/2025/02/27/Data-Structure13/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：priority-queue终于启动了！"><a href="#Before：priority-queue终于启动了！" class="headerlink" title="Before：priority_queue终于启动了！"></a>Before：priority_queue终于启动了！</h5><h5 id="情书只有三行，爱意起于一瞬，结局愿是一生"><a href="#情书只有三行，爱意起于一瞬，结局愿是一生" class="headerlink" title="情书只有三行，爱意起于一瞬，结局愿是一生"></a>情书只有三行，爱意起于一瞬，结局愿是一生</h5><h1 id="Data-Structure-13-优先级队列"><a href="#Data-Structure-13-优先级队列" class="headerlink" title="Data Structure 13 优先级队列"></a>Data Structure 13 优先级队列</h1><h2 id="优先级队列是什么？"><a href="#优先级队列是什么？" class="headerlink" title="优先级队列是什么？"></a>优先级队列是什么？</h2><p>元素之间的关系是由<strong>元素的优先级</strong>决定的，而不是由入队的先后次序决定。在优先级队列中，优先级最高的元素是队头元素，优先级最低的元素是队尾元素。</p><h2 id="基于树的优先级队列"><a href="#基于树的优先级队列" class="headerlink" title="基于树的优先级队列"></a>基于树的优先级队列</h2><p>基于线性表的优先级队列入队出队的时间复杂度总有一个会到O(N)，我们不可以接受这个时间复杂度，所以：<br>我们介绍一种基于树状组织的优先级队列——<strong>二叉堆</strong>。它可以使入队和出队操作的最坏情况下时间复杂度是O(logN)。</p><h2 id="优先级队列的存储实现"><a href="#优先级队列的存储实现" class="headerlink" title="优先级队列的存储实现"></a>优先级队列的存储实现</h2><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆是一棵满足结构性和有序性的二叉树，鉴于树状结构能给出指数的时间性能，所以将优先级队列组织成树是很自然的。我们需要保证树的高度尽可能小，所以这棵树最好是满二叉树，如果不满完全二叉树也可以。</p><p>完全二叉树可以采用顺序存储，利用父子结点的下标关系。另一个特性是有序性，堆的有序性是指最小的（或最大的）元素位于根的位置。</p><p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于&#x2F;小于等于其父亲的键值。<br>当根结点是最小元素时，称为<strong>最小化堆</strong>，当根结点是最大元素时，称为<strong>最大化堆</strong>。在优先级队列中如果数值越小优先级越高，则采用最小化堆存储；反之，如果数值越大优先级越高，则采用最大化堆存储。</p><h3 id="优先队列类的定义"><a href="#优先队列类的定义" class="headerlink" title="优先队列类的定义"></a>优先队列类的定义</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priorityQueue</span>: <span class="hljs-keyword">public</span> queue&lt;Type&gt;&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">int</span> capacity = <span class="hljs-number">100</span>);<br>        <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">const</span> Type data[],<span class="hljs-type">int</span> size);<br>        ~<span class="hljs-built_in">priorityQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp;x)</span></span>;<br>        <span class="hljs-function">Type <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">Type <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> currentSize; <span class="hljs-comment">//队列中元素个数</span><br>        Type *array; <span class="hljs-comment">//二叉堆数组起始地址</span><br>        <span class="hljs-type">int</span> maxSize; <span class="hljs-comment">//数组规模</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(<span class="hljs-type">int</span> hole)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优先队列的运算实现——以大根堆为例"><a href="#优先队列的运算实现——以大根堆为例" class="headerlink" title="优先队列的运算实现——以大根堆为例"></a>优先队列的运算实现——以大根堆为例</h3><p>首先是不带初始数据构造函数、析构函数、判空和取首函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">priorityQueue</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">capacity</span> = <span class="hljs-symbol">100</span>)&#123;<br>    <span class="hljs-built_in">array</span> = new Type[capacity];<br>    maxSize = capacity;<br>    currentSize = <span class="hljs-number">0</span>;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::~<span class="hljs-symbol">priorityQueue</span>()&#123;<br>    delete []<span class="hljs-built_in">array</span>;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> currentSize == <span class="hljs-number">0</span>;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">Type</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">getHead</span>()&#123;<br>    <span class="hljs-keyword">if</span>(!isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>enQueue操作，即入队的过程，我们把它称作<strong>向上过滤</strong>，这种实现方法是在下一个可用的位置创建一个空结点，然后把它沿着堆往上冒，这个过程的时间复杂度是O(logN)。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">enQueue</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">Type</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(currentSize == maxSize - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">double</span>Space();<br>    &#125;<br>    <span class="hljs-built_in">int</span> pos = ++currentSize;<br>    <span class="hljs-keyword">while</span>(pos != <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[pos] &gt; <span class="hljs-built_in">array</span>[pos/<span class="hljs-number">2</span>])&#123;<br>            <span class="hljs-built_in">int</span> tmp = <span class="hljs-built_in">array</span>[pos];<br>            <span class="hljs-built_in">array</span>[pos] = <span class="hljs-built_in">array</span>[pos/<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">array</span>[pos/<span class="hljs-number">2</span>] = tmp;<br>            pos /= <span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>deQueue操作，即出队的过程，二叉堆中我们要做的是删除根结点。我们的核心思想是：把根结点和完全二叉树中的最后一个结点交换值，然后删除最后一个结点，将根结点分别与左右结点进行比较，把它沿着堆往下过滤，这一过程称为<strong>向下过滤</strong>，时间复杂度同样是O(logN)。</p><p>实现这一过程，我们需要调用一个私有成员函数<code>void percolateDown(int hole);</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">Type</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">deQueue</span>()&#123;<br>    <span class="hljs-comment">//交换</span><br>    Type deNode;<br>    deNode = <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[currentSize - <span class="hljs-number">1</span>];<br>    percolateDown(<span class="hljs-number">1</span>); <span class="hljs-comment">//向下过滤根结点</span><br><br>    <span class="hljs-keyword">return</span> deNode;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">percolateDown</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">hole</span>)&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span> * hole &lt;= currentSize)&#123;<br>        <span class="hljs-keyword">if</span>(hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= currentSize)&#123;<br>            <span class="hljs-comment">//说明左右结点均存在</span><br>            Type tmp;<br>            <span class="hljs-built_in">int</span> x;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole + <span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole])&#123;<br>                tmp = <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole];<br>                x = <span class="hljs-number">2</span> * hole;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tmp = <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole + <span class="hljs-number">1</span>];<br>                x = <span class="hljs-number">2</span> * hole + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp &gt; <span class="hljs-built_in">array</span>[hole])&#123;<br>                Type t = <span class="hljs-built_in">array</span>[hole];<br>                <span class="hljs-built_in">array</span>[hole] = tmp;<br>                <span class="hljs-built_in">array</span>[x] = t;<br>                hole = x;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//只有左结点存在</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[hole] &gt; <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole])&#123;<br>                Type tmp = <span class="hljs-built_in">array</span>[hole];<br>                <span class="hljs-built_in">array</span>[hole] = <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole];<br>                <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole] = tmp;<br>                hole = <span class="hljs-number">2</span> * hole;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是如何构造这个二叉堆了<br>最简单的做法是执行N次enQueue操作（类似于二分查找），时间复杂度达到了O(NlogN)，考虑一种复杂度更低的建堆方法。</p><p>我们可以从编号最大的非叶结点开始，对结点进行<strong>向下过滤</strong>，这样计算下来的时间复杂度来到了O(N)（具体推导可见Introduction to Algorithms）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">buildHeap</span>()&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = currentSize / <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">1</span>;i--)&#123;<br>        percolateDown(i);<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">priorityQueue</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">Type</span> <span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size</span>)&#123;<br>    currentSize = size;<br>    maxSize = size + <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">array</span> = new Type[maxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt;= currentSize;i++)&#123;<br>        <span class="hljs-built_in">array</span>[i] = data[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    buildHeap();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="However"><a href="#However" class="headerlink" title="However"></a>However</h2><p>我觉得这样写却有一些不美观，虽然利用数组下标节省了很多空间，但在处理归并堆时，使用数组就不太合适了，所以priority_queue同样可以用二叉链表实现，而且我们可以将push和pop的操作都统一到merge里去，就非常简洁了。</p><p>我在STLite2025——priority_queue类的实现中用了一个二叉链表来实现大根堆（实则维护了一棵<strong>左偏树</strong>）。害还不是因为一定要归并队列，不然谁还用链表写啊（真占内存）</p><p>先介绍一下<strong>左偏树</strong>（也可以叫<strong>左偏堆</strong>）<br>左偏树具有堆的性质，优点在于<strong>可以快速合并</strong>。对于一棵二叉树，我们定义外节点为子节点数小于两个的节点（省流：有空子节点的结点），定义一个节点的 <strong>dist</strong> 为其到子树中最近的外节点所经过的边的数量。空节点的 <strong>dist</strong> 为0。<br>特别注意：左偏树并不是一棵完全二叉树，故dist与树的深度没有关系</p><p>如下图所示，这是一棵左偏树：<br><img src="/img/%E5%B7%A6%E5%81%8F%E6%A0%911.png" alt="左偏树"></p><p>这，也是一棵左偏树：<br><img src="/img/%E5%B7%A6%E5%81%8F%E6%A0%912.png" alt="左偏树"></p><p>左偏树作为一个可并堆，核心操作在于归并堆merge操作：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl">Node *mergeHeap(Node *l,Node *r) &#123;<br>    <span class="hljs-keyword">if</span>(l == nullptr) &#123;<br>        return r;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>        return l;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(Compare()(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>,r -&gt;</span> <span class="hljs-keyword">data</span>)) &#123;<br>        std::swap(l ,r ); <span class="hljs-comment">//这一步是为了维护左子树的根结点一定较大</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">l</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = mergeHeap(l -&gt;</span> right,r);<br>    <span class="hljs-comment">// 这一步将左子树的右子树与右子树合并，这样左偏值最多增大 1</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(l -&gt;</span> left == nullptr) &#123;<br>        <span class="hljs-function"><span class="hljs-title">std</span>::swap(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>, l -&gt;</span> right);<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> != nullptr &amp;&amp; l -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">dist</span> &lt; l -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> dist) &#123;<br>        <span class="hljs-function"><span class="hljs-title">std</span>::swap(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>, l -&gt;</span> right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">if</span>(l -&gt;</span> right == nullptr) &#123;<br>        <span class="hljs-function"><span class="hljs-title">l</span> -&gt;</span> dist = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">l</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">dist</span> = l -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> dist + <span class="hljs-number">1</span>;<br>    &#125;<br>    return l;<br>&#125;<br></code></pre></td></tr></table></figure><p>merge操作合并两个大小分别为 n 和 m 的堆复杂度是O(logN + logM)，实现了对数级复杂度</p><h2 id="其他可并堆"><a href="#其他可并堆" class="headerlink" title="其他可并堆"></a>其他可并堆</h2><h3 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h3><p>斜堆是满足堆的有序性，但没有任何平衡条件限定的二叉树。在斜堆中，不能保证树的深度是对数的。但从平均的概念上能够保证所有的操作都是对数的时间性能。它比左偏堆简单，不需要为结点保存空路径信息。</p><p>归并策略是：根结点值比较大的堆与根结点比较小的堆的右子堆归并，在完成一个归并前，对产生的临时树的右路径上的每个结点交换它们的左右孩子。</p><h3 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h3><p>二项堆不是用一棵满足堆的有序性的二叉树表示，而是用一个森林表示。森林中的每一棵树都有一定的约束，称为二项树。二项树是满足堆的有序性的树。高度为0的二项树是只有根结点的树，高度为k的二项树凡是将一棵B_(k - 1)加到另一棵B_(k - 1)的根上形成的。在这片森林中，每个高度的二项树之多只有一棵。</p><p><img src="/img/%E4%BA%8C%E9%A1%B9%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="二项树结构"></p><p>从二项树的特性可以看出，对给定的元素个数，可以构造唯一的一个二项堆。（二进制表示整数）<br>二项堆的归并操作：由低到高依次归并两个优先级队列中高度相同的树，也就是<strong>归并两个二项堆中对应的树</strong>。入队操作可以看成是归并的特例，出队操作只需删除最小根结点的二项树，将其裂成一个二项堆，再将其与原有二叉堆合并即可。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>树状结构正式结束！明天（尽量）进入集合结构！</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://oi-wiki.org/ds/heap/">https://oi-wiki.org/ds/heap/</a><br><a href="https://oi-wiki.org/ds/leftist-tree/">https://oi-wiki.org/ds/leftist-tree/</a><br><a href="https://www.luogu.com.cn/article/uoeyv3gq">https://www.luogu.com.cn/article/uoeyv3gq</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>Priority Queue</tag>
      
      <tag>Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure12</title>
    <link href="/2025/02/26/Data-Structure12/"/>
    <url>/2025/02/26/Data-Structure12/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）"><a href="#Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）" class="headerlink" title="Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）"></a>Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）</h5><h5 id="喜欢日升日落，喜欢璀璨星河，喜欢得不到的你"><a href="#喜欢日升日落，喜欢璀璨星河，喜欢得不到的你" class="headerlink" title="喜欢日升日落，喜欢璀璨星河，喜欢得不到的你"></a>喜欢日升日落，喜欢璀璨星河，喜欢得不到的你</h5><h1 id="Data-Structure-12-哈夫曼树-树和森林"><a href="#Data-Structure-12-哈夫曼树-树和森林" class="headerlink" title="Data Structure 12 哈夫曼树 树和森林"></a>Data Structure 12 哈夫曼树 树和森林</h1><h2 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h2><p>背景：<br>大多数计算机采用<strong>ASCII 编码</strong>，ASCII编码是一种等长的编码，每个字符的编码长度相同。但我们有一些常用的ASCII字符，也有一些较不常用的字符。如果所有字符均等长，将会造成保存文本空间较为庞大。所以我们可以让<strong>使用频率较高</strong>的字符拥有较短的编码，<strong>使用频率较低</strong>的字符拥有较长的编码，使得保存文本的空间减少。</p><p>举一个例子，现在有一个文本，下列字符的出现频率分别为：<br>a(10),e(15),i(12),s(3),t(4),空格(13),换行(1)</p><p>那么其占用的空间可以这样计算：</p><p><img src="/img/%E6%AD%A3%E5%B8%B8%E7%BC%96%E7%A0%81.png" alt="正常编码占用空间"></p><p>占用空间为：3*（10 + 15 + 12 + 3 + 4 + 13 + 1） &#x3D; 174 bit</p><p>而若采用不等长编码，文本存储空间将会大大节省：</p><p>3 * 10 + 2 * 15 + 2 * 12 + 5 * 3 + 4 * 4 + 2 * 13 + 5 * 1 &#x3D; 146 bit</p><p>那么如何找到这个优化的编码呢？可以先构建一棵哈夫曼树，再从哈夫曼树获得哈夫曼编码</p><h2 id="哈夫曼树构建"><a href="#哈夫曼树构建" class="headerlink" title="哈夫曼树构建"></a>哈夫曼树构建</h2><p>我们构建一棵<strong>完全二叉树</strong>，在这棵树中，字符仅被存放在叶结点中，每个字符的编码是从根结点到叶结点的路径，<strong>0表示左子树，1表示右子树</strong>。<br>Example：如果从根结点出发，向右，向左，再向右，表示的即为101。</p><p>我们可以得到：若一个字符到根结点，经过的树枝数为L，在文本中出现的次数为w，则占用的存储空间为 L*w。每个字符总的存储量被定义为这个编码的<strong>代价</strong>。</p><p>按照上述建树的方式，我们可以将先前例子中的文本表示成一棵瓦努请安二叉树：<br><img src="/img/%E7%AD%89%E9%95%BF%E7%BC%96%E7%A0%81%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="等长编码下的完全二叉树"><br>我们考虑对这棵树进行一些优化，比如可以看到换行字符的父结点只有一个子结点，故我们考虑将换行符移到其父结点的位置，这样换行符的存储空间就减小了 1bit，得到一个比原来更优的存储方案。这样一种存储方案其实还包含了字符间的一个性质：<strong>没有一个字符的编码会是另一个另一个字符编码的前缀。</strong><br>换句话说，字符编码可以有不同的长度，只要每个字符的编码与其他任何字符编码的前缀不同即可。这种编码方式称为<strong>前缀编码</strong>。</p><p>上述问题的最优二叉树如下图所示：</p><p><strong>我们要找到一棵最小代价的二叉树！！！</strong><br>隆重推出：</p><h2 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h2><p>下面是Huffman Tree的构造规则：<br>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。n个权值分别设为 w_1、w_2、… 、w_n。<br>(1)将w_1、w_2、… 、w_n看成是有n棵树的森林（每棵树仅有一个结点）；<br>(2)在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br>(3)从森林中删除选取的两棵树，并将新树加入森林；<br>(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树（最优二叉树）</p><h2 id="哈夫曼树类的实现"><a href="#哈夫曼树类的实现" class="headerlink" title="哈夫曼树类的实现"></a>哈夫曼树类的实现</h2><p>我们采用动态数组来实现哈夫曼树，优势在于：父子节点关系可以通过下标计算，代码更简洁<br>思路已经很清楚了，就直接上代码了😋</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hfTree</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>            Type data;<br>            <span class="hljs-type">int</span> parent,lchild,rchild; <span class="hljs-comment">// 存地址（数组下标）</span><br>            <span class="hljs-type">int</span> weight; <span class="hljs-comment">// 权值</span><br>        &#125;;<br>        Node *elem;<br>        <span class="hljs-type">int</span> length;<br>    <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hfCode</span>&#123; <span class="hljs-comment">// 哈夫曼编码信息</span><br>            Type data;<br>            string code;<br>        &#125;;<br><br>        <span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *x,<span class="hljs-type">const</span> <span class="hljs-type">int</span> *w,<span class="hljs-type">int</span> size);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCode</span><span class="hljs-params">(hfCode result[])</span></span>;<br>        ~<span class="hljs-built_in">hfTree</span>()&#123;<br>            <span class="hljs-keyword">delete</span> []elem;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们首先要实现哈夫曼树类中最重要的一个函数——<strong>构造函数</strong>，我们需要在构造函数中实现哈夫曼树的构建。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fortran">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-keyword">Type</span>&gt;<br>hfTree&lt;<span class="hljs-keyword">Type</span>&gt;::hfTree(const <span class="hljs-keyword">Type</span> *x,const <span class="hljs-built_in">int</span> *w,<span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>)&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">min1</span>,min2; // 第一小、第二小的权值<br>    <span class="hljs-built_in">int</span> x,y; // 第一小、第二小的下标<br>    length = <span class="hljs-built_in">size</span> * <span class="hljs-number">2</span>;<br>    elem = new Node[<span class="hljs-built_in">size</span> * <span class="hljs-number">2</span>];<br><br>    for(<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">size</span>;i &lt; length;i ++)&#123;<br>        elem[i].<span class="hljs-keyword">data</span> = x[i - <span class="hljs-built_in">size</span>];<br>        elem[i].weight = w[i - <span class="hljs-built_in">size</span>];<br>        elem[i].parent = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    for(<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>        <span class="hljs-built_in">min1</span> = min2 = <span class="hljs-number">32647</span>;<br>        for(<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>;j &lt; length;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(elem[j].parent == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(elem[j].weight &lt; <span class="hljs-built_in">min1</span>)&#123;<br>                    min2 = <span class="hljs-built_in">min1</span>;<br>                    <span class="hljs-built_in">min1</span> = elem[j].weight;<br>                    y = x;<br>                    x = j;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(elem[j].weight &lt; min2)&#123;<br>                    min2 = elem[j].weight;<br>                    y = j;<br>                &#125;<br>            &#125;<br>            elem[x].parent = i;<br>            elem[y].parent = i;<br>            elem[i].lchild = y;<br>            elem[i].rchild = x;<br>            elem[i].weight = <span class="hljs-built_in">min1</span> + min2;<br>            elem[i].parent = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getCode函数用来获得字符对应的Huffman编码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">void</span> hfTree&lt;Type&gt;::<span class="hljs-built_in">getCode</span>(hfCode result[])&#123;<br>    <span class="hljs-type">int</span> size = length/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> p,c;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = size;i &lt; length;i++)&#123;<br>        result[i - size].data = elem[i].data;<br>        result[i - size].code = <span class="hljs-string">&quot;&quot;</span>;<br>        p = elem[i].parent;<br>        s = i;<br><br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p.lchild == s)&#123;<br>                result[i - size].code += <span class="hljs-string">&quot;0&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[i - size].code += <span class="hljs-string">&quot;1&quot;</span>;<br>            &#125;<br>            s = p;<br>            p = elem[p].parent;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>搞定！是不是挺简单的😋</p><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p><strong>不再是二叉树，而是n叉树，结点里该存什么？</strong></p><h3 id="树的存储实现"><a href="#树的存储实现" class="headerlink" title="树的存储实现"></a>树的存储实现</h3><ul><li><p>孩子链表示法<br>由于每个结点的孩子数量差异较大，如果开一个指针数组存孩子地址会造成大量空间的浪费，于是考虑用链表对所有子结点的地址进行存储<br><img src="/img/%E5%AD%A9%E5%AD%90%E9%93%BE.png" alt="孩子链表示法"></p></li><li><p>孩子兄弟链表示法（<strong>最常用的树的存储结构</strong>）<br>孩子兄弟链表示法中结点形式与二叉树一致，区别在于：<strong>左指针指向第一个儿子，右指针指向下一个兄弟</strong>（看到这里Jane不禁叫好，真是绝妙😝）<br><img src="/img/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E9%93%BE.png" alt="孩子兄弟链表示法"></p></li><li><p>双亲表示法<br>树上每个结点可以有多个儿子，但只能有一个父亲。所以想法很简单，通过指向父结点的指针将整棵树组织起来。这个结构可以直接存在数组里。<br><img src="/img/%E5%8F%8C%E4%BA%B2.png" alt="双亲表示法"></p></li></ul><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ul><li>前序遍历</li><li>后序遍历</li><li>层次遍历</li></ul><h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><p>树的孩子兄弟链表示法其实就可以把一棵树当成是二叉树进行考虑，<strong>把二叉树的左结点看作是第一个儿子，右节点看作是下一个兄弟</strong>。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2.png" alt="一般树向二叉树的转换"></p><p>我们还可以将森林转化成一棵大二叉树，利用了一个性质：<strong>根结点没有兄弟，即根结点没有右子树</strong>，只需以下2步：<br>（1）将森林里每一棵树转化成二叉树<br>（2）将B_i 作为B_(i-1)根结点的右子树</p><p><img src="/img/%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2.png" alt="将森林转化为一棵二叉树"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/sugarbliss/article/details/80315327">https://blog.csdn.net/sugarbliss/article/details/80315327</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>Huffman Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure11</title>
    <link href="/2025/02/25/Data-Structure11/"/>
    <url>/2025/02/25/Data-Structure11/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：全世界都在偶遇她，只有我没机会嘛😥"><a href="#Before：全世界都在偶遇她，只有我没机会嘛😥" class="headerlink" title="Before：全世界都在偶遇她，只有我没机会嘛😥"></a>Before：全世界都在偶遇她，只有我没机会嘛😥</h5><h1 id="Data-Structure-11-二叉链表遍历的非递归实现及二叉树的应用"><a href="#Data-Structure-11-二叉链表遍历的非递归实现及二叉树的应用" class="headerlink" title="Data Structure 11 二叉链表遍历的非递归实现及二叉树的应用"></a>Data Structure 11 二叉链表遍历的非递归实现及二叉树的应用</h1><h2 id="二叉链表遍历的非递归实现"><a href="#二叉链表遍历的非递归实现" class="headerlink" title="二叉链表遍历的非递归实现"></a>二叉链表遍历的非递归实现</h2><p>上一节翁阿姨的课上，我们讲到了通过栈对函数实现非递归调用，而今天所说的二叉链表遍历的非递归实现，同样也是依靠链接栈这一数据结构实现的。实现时需要注意进栈顺序的细节，下面给出代码实现。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">template &lt;class T&gt;<br>void binaryTree&lt;T&gt;::preOrder() const&#123;<br>    linkStack&lt;Node *&gt; s;<br>    s.push(root);<br>    <span class="hljs-keyword">while</span>(!s.isEmpty())&#123;<br>        Node *tmp = s.pop();<br>        <span class="hljs-function"><span class="hljs-title">cout</span> &lt;&lt; tmp -&gt;</span> <span class="hljs-keyword">data</span>;<br><br>        <span class="hljs-function"><span class="hljs-title">if</span>(tmp -&gt;</span> left != nullptr)&#123;<br>            <span class="hljs-function"><span class="hljs-title">s</span>.push(tmp -&gt;</span> left);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(tmp -&gt;</span> right != nullptr)&#123;<br>            <span class="hljs-function"><span class="hljs-title">s</span>.push(tmp -&gt;</span> right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而中序遍历在实现时则有一些不同，因为中序遍历要求<strong>先访问左子树</strong>，再访问根结点，最后访问<strong>右子树</strong>，所以在根结点出栈后不能先访问它，而将其暂存，先访问<strong>左子树</strong>，再访问它。为了解决这一问题，我们重新更换一种结点，记录结点进栈的次数。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct StNode&#123;<br>    Node *node<span class="hljs-comment">;</span><br>    int timePop<span class="hljs-comment">;</span><br>    StNode(Node *n <span class="hljs-operator">=</span> nullptr)&#123;<br>        node <span class="hljs-operator">=</span> n<span class="hljs-comment">;</span><br>        timePop <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    &#125;<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nsis">template &lt;class T&gt;<br>void binaryTree&lt;T&gt;::midOrder() const&#123;<br>    linkStack&lt;StNode&gt; s<span class="hljs-comment">;</span><br>    StNode <span class="hljs-literal">current</span>(root)<span class="hljs-comment">;</span><br><br>    while(!s.isEmpty())&#123;<br>        <span class="hljs-literal">current</span> = s.<span class="hljs-keyword">pop</span>()<span class="hljs-comment">;</span><br>        ++ <span class="hljs-literal">current</span>.timePop<span class="hljs-comment">;</span><br>        if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">2</span>)&#123;<br>            // 出栈<span class="hljs-number">2</span>次了<br>            cout &lt;&lt; <span class="hljs-literal">current</span>.node -&gt; data &lt;&lt; endl<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span> != nullptr)&#123;<br>                <span class="hljs-literal">current</span>.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;else&#123;<br>            // 重新被推回栈中<br>            s.<span class="hljs-keyword">push</span>(<span class="hljs-literal">current</span>)<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span> != nullptr)&#123;<br>                <span class="hljs-literal">current</span>.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是后序遍历，与中序遍历实现方法类似，但只有在第三次出栈时才会被访问</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nsis">template &lt;class T&gt;<br>void binaryTree&lt;T&gt;::postOrder() const&#123;<br>    linkStack&lt;StNode&gt; s<span class="hljs-comment">;</span><br>    StNode <span class="hljs-literal">current</span>(root)<span class="hljs-comment">;</span><br><br>    while(!s.isEmpty())&#123;<br>        <span class="hljs-literal">current</span> = s.<span class="hljs-keyword">pop</span>()<span class="hljs-comment">;</span><br>        ++ <span class="hljs-literal">current</span>.timePop<span class="hljs-comment">;</span><br><br>        if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">3</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-literal">current</span>.node -&gt; data &lt;&lt; endl<span class="hljs-comment">;</span><br>        &#125;else if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">2</span>)&#123;<br>            s.<span class="hljs-keyword">push</span>(<span class="hljs-literal">current</span>)<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span> != nullptr)&#123;<br>                s.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;else if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">1</span>)&#123;<br>            s.<span class="hljs-keyword">push</span>(<span class="hljs-literal">current</span>)<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span> != nullptr)&#123;<br>                s.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的应用——计算表达式"><a href="#二叉树的应用——计算表达式" class="headerlink" title="二叉树的应用——计算表达式"></a>二叉树的应用——计算表达式</h2><p>由于算术运算符是二元运算符，故可以很自然地表示成一棵二叉树，根结点表示运算符，左右孩子是运算数，这棵树被称为<strong>表达式树</strong>，既然如此，我们知道对这棵树的遍历是<strong>后序遍历</strong><br>下面就是一棵表达式树：<br><img src="/img/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91.png" alt="表达式树"></p><p>所描述的表达式为：**(4 - 2)<em>(10 + (4 + 6)&#x2F;2) + 2</em>*</p><p>这个逻辑构造似乎还是比较好理解的，所以，我们就直接来看看如何建树吧。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class calc&#123;<br>    enum <span class="hljs-keyword">Type</span>&#123;DATA,ADD,SUB,MULTI,DIV,OPAREN,CPAREN,EOL&#125;;<br><br>    struct <span class="hljs-keyword">node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">        Type</span> <span class="hljs-keyword">type</span>;<br>        int data;<br>        <span class="hljs-keyword">node</span> <span class="hljs-title">*lchild</span>,rchild;<br><br>        <span class="hljs-keyword">node</span><span class="hljs-title">(Type</span> t,int d = <span class="hljs-number">0</span>,<span class="hljs-keyword">node</span> <span class="hljs-title">*lc</span> = nullptr,<span class="hljs-keyword">node</span> <span class="hljs-title">*rc</span> = nullptr)&#123;<br>            <span class="hljs-keyword">type</span> = t;<br>            data = d;<br>            lchild = lc;<br>            rchild = rc;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*root</span>;<br><br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*create</span>(char *&amp;s); //创建一棵表达式树<br>    <span class="hljs-keyword">Type</span> getToken(char *&amp;s,int &amp;value); // 获得一个切片<br>    int result(<span class="hljs-keyword">node</span> <span class="hljs-title">*t</span>); //计算表达式结果<br><br>    public:<br>        calc(char *s)&#123;<br>            root = create(s);<br>        &#125;<br><br>        int result()&#123;<br>            if(root == nullptr)&#123;<br>                return <span class="hljs-number">0</span>;<br>            &#125;<br>            return result(root);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>create函数的实现</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xquery">calc::node *calc::create(char *&amp;s)&#123;<br>    calc::node *p,<span class="hljs-built_in">*root</span> = nullptr;<br>    Type returnType;<br>    int <span class="hljs-keyword">value</span>;<br><br>    while(*s)&#123;<br>        returnType = calc::getToken(s,<span class="hljs-keyword">value</span>);<br><br>        <span class="hljs-keyword">switch</span>(returnType)&#123;<br>            <span class="hljs-keyword">case</span> DATA:case OPAREN:<br>                <span class="hljs-keyword">if</span>(returnType == DATA)&#123;<br>                    <span class="hljs-type">node</span> *p = new <span class="hljs-type">node</span>(DATA,<span class="hljs-keyword">value</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    p = create(s);<br>                &#125;<br>                <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> != nullptr)&#123;<br>                    <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> -&gt; rchild == nullptr)&#123;<br>                       <span class="hljs-built_in"> root</span> -&gt; rchild = p;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                       <span class="hljs-built_in"> root</span> -&gt; rchild -&gt; rchild = p;<br>                    &#125;<br>                &#125;<br>                break;<br>            <span class="hljs-keyword">case</span> ADD: <span class="hljs-keyword">case</span> SUB:<br>                <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> == nullptr)&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span>,p);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span><span class="hljs-built_in">,root</span>);<br>                &#125;<br>                break;<br>            <span class="hljs-keyword">case</span> MULTI: <span class="hljs-keyword">case</span> DIV:<br>                <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> == nullptr)&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span>,p);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> -&gt; type == MULTI ||<span class="hljs-built_in"> root</span> -&gt; type == DIV)&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span><span class="hljs-built_in">,root</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                   <span class="hljs-built_in"> root</span> -&gt; rchild = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span><span class="hljs-built_in">,root</span> -&gt; rchild);<br>                &#125;<br>                break;<br>            <span class="hljs-keyword">case</span> CPAREN: caseEOL:<br>                <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>getToken 函数与先前在Bookstore-2024中写的TokenScanner类类似，故不描述了（好懒啊😅）</p><p>另一个比较有趣的函数——result</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xl">int calc::result(calc::node *t)&#123;<br>    int num1,num2;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> type == DATA)&#123;<br>        <span class="hljs-function"><span class="hljs-title">return</span> t -&gt;</span> <span class="hljs-keyword">data</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">num1</span> = calc(t -&gt;</span> lchild);<br>    <span class="hljs-function"><span class="hljs-title">num2</span> = calc(t -&gt;</span> rchild);<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> type == ADD)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 + num2;<br>        return num1 + num2;<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(t -&gt;</span> type == SUB)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 - num2;<br>        return num1 - num2;<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(t -&gt;</span> type == MULTI)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 * num2;<br>        return num1 * num2;<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(t -&gt;</span> type == DIV)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 / num2;<br>        return num1 / num2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclude"><a href="#Conclude" class="headerlink" title="Conclude"></a>Conclude</h2><p>这两天一直在写二叉树，总结一下，真是对<strong>递归</strong>很巧妙的应用呢！<br>下面就是<strong>Huffman Tree</strong>了，离priority_queue越来越近了😝</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure10</title>
    <link href="/2025/02/24/Data-Structure10/"/>
    <url>/2025/02/24/Data-Structure10/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：接Data-Structure-9，继续二叉链表…"><a href="#Before：接Data-Structure-9，继续二叉链表…" class="headerlink" title="Before：接Data Structure 9，继续二叉链表…"></a>Before：接Data Structure 9，继续二叉链表…</h5><h5 id="PS-Today-is-a-happy-day-for-Jane-maybe-you-can-guess-why"><a href="#PS-Today-is-a-happy-day-for-Jane-maybe-you-can-guess-why" class="headerlink" title="PS: Today is a happy day for Jane,maybe you can guess why?"></a>PS: Today is a happy day for Jane,maybe you can guess why?</h5><h1 id="Data-Structure-10-二叉链表"><a href="#Data-Structure-10-二叉链表" class="headerlink" title="Data Structure 10 二叉链表"></a>Data Structure 10 二叉链表</h1><h2 id="二叉链表类定义"><a href="#二叉链表类定义" class="headerlink" title="二叉链表类定义"></a>二叉链表类定义</h2><p>首先，回顾一下《C++程序设计思想与方法》，<strong>友元函数（friend function）</strong>是一个特殊的函数，它可以访问类的私有（private）和保护（protected）成员，即使它不是该类的成员函数。</p><p>下面给出定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-type">T</span>&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> binaryTree:public bTree&lt;<span class="hljs-type">T</span>&gt;&#123;</span><br><span class="hljs-class">    friend void printTree(<span class="hljs-title">const</span> <span class="hljs-title">binaryTree</span>&lt;<span class="hljs-type">T</span>&gt; &amp;<span class="hljs-title">t</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>);</span><br><span class="hljs-class">private:</span><br><span class="hljs-class">    struct <span class="hljs-type">Node</span>&#123;</span><br><span class="hljs-class">        <span class="hljs-type">Node</span> *left,right;</span><br><span class="hljs-class">        <span class="hljs-type">T</span> data;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        <span class="hljs-type">Node</span>():left(<span class="hljs-title">nullptr</span>),right(<span class="hljs-title">nullptr</span>)&#123;&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        <span class="hljs-type">Node</span>(<span class="hljs-type">T</span> <span class="hljs-title">data</span>,<span class="hljs-type">Node</span> *<span class="hljs-title">l</span> = <span class="hljs-title">nullptr</span>,<span class="hljs-type">Node</span> *<span class="hljs-title">r</span> == <span class="hljs-title">nullptr</span>)&#123;</span><br><span class="hljs-class">            left = l;</span><br><span class="hljs-class">            right = r;</span><br><span class="hljs-class">            data = <span class="hljs-type">Data</span>;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        ~<span class="hljs-type">Node</span>()&#123;&#125;</span><br><span class="hljs-class">    &#125;;</span><br><span class="hljs-class"></span><br><span class="hljs-class">    <span class="hljs-type">Node</span> *root; // 二叉树根结点</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    binaryTree():root(<span class="hljs-title">nullptr</span>)&#123;&#125;</span><br><span class="hljs-class">    binaryTree(<span class="hljs-type">T</span> <span class="hljs-title">x</span>):root(<span class="hljs-title">new</span> <span class="hljs-type">Node(x)</span>)&#123;&#125;</span><br><span class="hljs-class">    ~binaryTree();</span><br><span class="hljs-class"></span><br><span class="hljs-class">    void clear();</span><br><span class="hljs-class">    bool isEmpty() const;</span><br><span class="hljs-class">    <span class="hljs-type">T</span> <span class="hljs-type">Root</span>(<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const;</span><br><span class="hljs-class">    <span class="hljs-type">T</span> lChild(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const;</span><br><span class="hljs-class">    <span class="hljs-type">T</span> rChild(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const;</span><br><span class="hljs-class">    void delLeft(<span class="hljs-type">T</span> <span class="hljs-title">x</span>);</span><br><span class="hljs-class">    void delRight(<span class="hljs-type">T</span> <span class="hljs-title">x</span>);</span><br><span class="hljs-class">    void preOrder() const;</span><br><span class="hljs-class">    void midOrder() const;</span><br><span class="hljs-class">    void postOrder() const;</span><br><span class="hljs-class">    void levelOrder() const;</span><br><span class="hljs-class">    void createTree(<span class="hljs-type">T</span> <span class="hljs-title">flag</span>);</span><br><span class="hljs-class">    <span class="hljs-type">T</span> parent(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const&#123;&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">private:</span><br><span class="hljs-class">    <span class="hljs-type">Node</span> *find(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">    void clear(<span class="hljs-type">Node</span> *&amp;<span class="hljs-title">t</span>);</span><br><span class="hljs-class">    void preOrder(<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">    void midOrder(<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">    void postOrder(<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="二叉链表类的运算实现"><a href="#二叉链表类的运算实现" class="headerlink" title="二叉链表类的运算实现"></a>二叉链表类的运算实现</h2><p>首先是isEmpty、Root、clear和析构函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> root == <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">T</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Root</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">flag</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">clear</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    clear(t-&gt;left);<br>    clear(t-&gt;right);<br>    delete t;<br>    t = <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::~<span class="hljs-symbol">binaryTree</span>()&#123;<br>    clear(root);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是遍历函数的实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">preOrder</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout &lt;&lt; t-&gt;data;<br>    preOrder(t-&gt;left);<br>    preOrder(t-&gt;right);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">preOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    preOrder(root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">midOrder</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    midOrder(t-&gt;left);<br>    cout &lt;&lt; t-&gt;data;<br>    midOrder(t-&gt;right);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">midOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    midOrder(root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">postOrder</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    postOrder(t-&gt;left);<br>    postOrder(t-&gt;right);<br>    cout &lt;&lt; t-&gt;data;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">postOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    postOrder(root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">levelOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-comment">// 这里采用链接队列实现</span><br>    <span class="hljs-comment">// 类似于广度优先搜索（BFS）</span><br>    linkQueue&lt;Node *&gt; que;<br>    Node *tmp;<br>    que.enQueue(root);<br><br>    <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>        tmp = que.deQueue;<br>        cout &lt;&lt; tmp -&gt; data;<br>        <span class="hljs-keyword">if</span>(tmp -&gt; left)&#123;<br>            que.enQueue(tmp -&gt; left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp -&gt; right)&#123;<br>            que.enQueue(tmp -&gt; right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是find、lChild、rChild、delLeft、delRight函数实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">Node</span> *<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">find</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x,<span class="hljs-symbol">binaryTree</span></span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    Node *tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t-&gt;data == x)&#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp = find(x,t-&gt;left))&#123;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp = find(x,t-&gt;right))&#123;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">T</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">lChild</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T</span></span> <span class="hljs-symbol">flag</span>) <span class="hljs-symbol">const</span>&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; left == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp -&gt; left -&gt; data;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">T</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">rChild</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T</span></span> <span class="hljs-symbol">flag</span>) <span class="hljs-symbol">const</span>&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; right == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp -&gt; right -&gt; data;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">delLeft</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x</span>)&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; left == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    clear(tmp -&gt; left);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">delRight</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x</span>)&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; right == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    clear(tmp -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是createTree建树操作</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">template<span class="hljs-tag">&lt;class T&gt;</span><br>void binaryTree<span class="hljs-tag">&lt;T&gt;</span>::createTree(T flag)&#123;<br>    linkQueue<span class="hljs-tag">&lt;Node *&gt;</span>que;<br>    <span class="hljs-keyword">Node</span> <span class="hljs-title">*tmp</span>;<br>    T x,lData,rData;<br>    cin &gt;&gt; x;<br>    que.enQueue(new <span class="hljs-keyword">Node</span><span class="hljs-title">(x</span>));<br>    while(!que.isEmpty())&#123;<br>        tmp = que.deQueue();<br>        cin &gt;&gt; lDta &gt;&gt; rData;<br>        if(lData != flag)&#123;<br>            que.enQueue(tmp -&gt; left = new <span class="hljs-keyword">Node</span><span class="hljs-title">(lData</span>));<br>        &#125;<br>        if(rData != flag)&#123;<br>            que.enQueue(tmp -&gt; right = new <span class="hljs-keyword">Node</span><span class="hljs-title">(rData</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>附上友元函数打印树</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stata">void printTree(<span class="hljs-keyword">const</span> binaryTree&lt;T&gt; &amp;t,T flag)&#123;<br>    linkQueue&lt;T&gt;<span class="hljs-keyword">que</span>;<br>    <span class="hljs-keyword">que</span>.enQueue(t -&gt; root -&gt; data);<br>    <br>    <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">que</span>.isEmpty())&#123;<br>        T tmp = <span class="hljs-keyword">que</span>.deQueue();<br>        T <span class="hljs-keyword">l</span> = lChild(tmp,flag);<br>        T r = rChild(tmp,flag);<br>        cout &lt;&lt; tmp &lt;&lt; <span class="hljs-keyword">l</span> &lt;&lt; r &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">l</span> != flag)&#123;<br>            <span class="hljs-keyword">que</span>.enQueue(<span class="hljs-keyword">l</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r != flag)&#123;<br>            <span class="hljs-keyword">que</span>.enQueue(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic4</title>
    <link href="/2025/02/23/Java-Basic4/"/>
    <url>/2025/02/23/Java-Basic4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭"><a href="#Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭" class="headerlink" title="Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭"></a>Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭</h5><h1 id="Java-Basic-4"><a href="#Java-Basic-4" class="headerlink" title="Java Basic 4"></a>Java Basic 4</h1><h2 id="Good-program-design"><a href="#Good-program-design" class="headerlink" title="Good program design"></a>Good program design</h2><p>Correct &#x2F; Easy to understand &#x2F; Easy to modify &#x2F; speed</p><h3 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h3><p>Variables: nouns,lowercase first letter,capitals separating words<br>Methods: Verbs,lowercase first letter<br>Classes:nouns,uppercase first letter</p><h3 id="Good-Class-Design"><a href="#Good-Class-Design" class="headerlink" title="Good Class Design"></a>Good Class Design</h3><ul><li>Make fields and methods private by default 默认私有即可，无需强行private</li><li>Only make methods public if you need to 只有必要时将函数设为公有</li><li>If you need access to a field, create a method 我们建议将成员变量设成private，再通过get或set函数来获取值或修改值</li></ul><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><h3 id="Interval-Testing"><a href="#Interval-Testing" class="headerlink" title="Interval Testing"></a>Interval Testing</h3><p>Important cases<br>下界以下、等于下界、在区间内、等于上界、上界以上</p><h3 id="Eclipse-Warnings"><a href="#Eclipse-Warnings" class="headerlink" title="Eclipse Warnings"></a>Eclipse Warnings</h3><p>May not be a mistake, but it likely is.<br>Always fix all warning!</p><h3 id="Assertion-断言"><a href="#Assertion-断言" class="headerlink" title="Assertion 断言"></a>Assertion 断言</h3><p>断言用于验证代码是否按预期运行</p><ul><li>当断言条件为真时，程序正常运行，不会有额外操作。</li><li>当断言条件为假时，程序会崩溃并抛出错误。</li></ul><p><code>assert difference &gt;= 0</code><br>这行代码表示断言变量difference的值大于或等于0，如果不满足该条，程序将报错。</p><h2 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h2><p><img src="/img/interface.png" alt="Implementation/Interface"><br>Java接口可以在不了解对象内部工作原理的情况下对其进行操作。</p><ul><li>当处理相似但不完全相同的对象时，接口很有用</li><li>当想要使用他人编写的代码时，接口也很实用。通过定义接口，代码提供者可以明确对外提供的功能契约，使用者只需按照接口定义来调用，而无需关心具体实现细节</li></ul><p>类比：C++中的抽象基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Graphics<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drawable</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Graphics surface)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(Color color)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Graphics<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drawable</span>&#123;<br>    <span class="hljs-comment">//some stuff...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Graphics surface)</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>implement关键字：用于类与接口之间的关系，表明一个类要实现接口中定义的所有抽象方法。<strong>一个类可以实现多个接口</strong>，从而具备多种不同的行为。（与后文提到的extends一个重要的区别）</p><h3 id="Interface-Notes-关于抽象基类"><a href="#Interface-Notes-关于抽象基类" class="headerlink" title="Interface Notes 关于抽象基类"></a>Interface Notes 关于抽象基类</h3><ul><li>只有函数</li><li>不提供具体代码实现，只提供定义</li><li>一个类可以实现任意数量的接口<br>关于最后一点，在C++中，可以举个这样的例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 第一个抽象类，模拟第一个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数，模拟接口方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Flyable</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 第二个抽象类，模拟第二个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Swimmable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数，模拟接口方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Swimmable</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 一个类继承多个抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> : <span class="hljs-keyword">public</span> Flyable, <span class="hljs-keyword">public</span> Swimmable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 实现Flyable接口的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Duck is flying.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// 实现Swimmable接口的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Duck is swimming.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><p>当通过接口来引用对象时，只能访问接口中定义的成员（方法、常量等）<br>举个例子：<br><code>Drawable d = new BouncingBox(...);</code><br>d只能访问Grawable接口中定义的draw函数<br>相当于接口限定了外部可见功能的边界</p><h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Drawable d <span class="hljs-operator">=</span> new BouncingBox(...)<span class="hljs-comment">;</span><br>BouncingBox box <span class="hljs-operator">=</span> (BouncingBox) d<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>则box可以调用BouncingBox类中</p><h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>extends关键字：用于类与类之间的继承关系，即一个类（子类、派生类）可以继承另一个类（父类、基类）的属性和方法。<br>特别注意的是：<strong>在 Java 里，类的继承只支持单继承，也就是一个子类只能有一个直接父类。</strong><br>class A extends B{}：A是B的子类<br>A拥有B的全部成员变量和函数，且可以增加自己的成员变量和函数</p><p>Example:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    void eat() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Animal is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    void bark() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Dog is barking.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然A也可以通过implement替换父类中的某个函数<br>Example:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> speed;<br><br>    void move() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Vehicle is moving.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">extends</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> numDoors;<br><br>    <span class="hljs-variable">@Override</span><br>    void move() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is moving on the road.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>Java中的报错信息主要为以下几种：<br><img src="/img/Exceptions.png" alt="Java Exceptions"><br>Java 通过创建异常对象并抛出的方式处理异常</p><h3 id="throw-主动抛出异常"><a href="#throw-主动抛出异常" class="headerlink" title="throw 主动抛出异常"></a>throw 主动抛出异常</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>throws &amp; throw：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) throws ArrayOutOfBoundsException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= size())<br>        throw <span class="hljs-built_in">new</span> ArrayOutOfBoundsException(&quot;&quot;+<span class="hljs-keyword">index</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>throws关键字：用于方法声明中，它告诉 Java 这个get方法在执行过程中可能会抛出ArrayOutOfBoundsException（数组越界异常）</li><li>throw关键字：用于实际抛出一个ArrayOutOfBoundsException异常对象，并将index作为参数传递给异常构造函数，方便在异常处理时获取相关信息。</li></ul><h3 id="try-catch-捕获并处理异常"><a href="#try-catch-捕获并处理异常" class="headerlink" title="try-catch 捕获并处理异常"></a>try-catch 捕获并处理异常</h3><p>Java希望调用get函数来处理异常</p><ul><li>Catching it</li><li>Rethrowing it</li></ul><p>try块用于执行可能会抛出异常的代码。在执行过程中，一旦代码抛出异常，程序的执行流程就会立即改变。<br>catch块则是告诉 Java 当捕获到指定类型的异常时，应该执行什么样的处理逻辑。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">get</span>(<span class="hljs-number">-1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ArrayOutOfBoundsException err) &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;oh dear!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws Exception</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O-文件读写"><a href="#I-O-文件读写" class="headerlink" title="I&#x2F;O 文件读写"></a>I&#x2F;O 文件读写</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>以字节为单位进行数据读写，适用于处理所有类型的数据，如图片、音频等二进制文件。<br>InputStream（输入字节流的抽象类）和OutputStream（输出字节流的抽象类）</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>以字符为单位进行数据读写，适合处理文本数据。主要的字符流类有Reader（输入字符流的抽象类）和Writer（输出字符流的抽象类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;./src/readme&quot;</span>);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>        <span class="hljs-comment">//缓冲功能</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(line);<br>        &#125;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>MIT 6.092: Introduction To Programming In Java<br>完结撒花🎇🎆</p>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
      <tag>Exceptions</tag>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure9</title>
    <link href="/2025/02/22/Data-Structure9/"/>
    <url>/2025/02/22/Data-Structure9/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B-树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！"><a href="#Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B-树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！" class="headerlink" title="Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B+树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！"></a>Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B+树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！</h5><h1 id="Data-Structure-9-树"><a href="#Data-Structure-9-树" class="headerlink" title="Data Structure 9 树"></a>Data Structure 9 树</h1><p>为了满足一下某人的好奇心，决定先贴一张树的归纳总结的图，作为开端（自己宠自己）<br><img src="/img/%E6%A0%91%E5%A4%A7%E5%85%A8.png" alt="树的总结"></p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>首先，回顾一下树状结构的特点：只有一个直接前驱（除根结点外），但可以有多个直接后继。</p><p>树的递归定义：有n个结点的有限集合，或者是空集。拥有1个根结点，其余结点可分成m个互不相交的集合，这些集合本质上也是树，称作根节点的子树。<br>下面是树的一些基本术语：</p><ul><li>根节点  叶节点（没有直接后继的结点） 内部结点（除根叶结点外）</li><li>结点的度（一个结点的直接后继数目）  树的度（所有结点的度的最大值）</li><li>子结点（结点的直接后继结点） 父结点（结点的直接前驱） 祖先节点（每个结点通向根结点的唯一路径上的所有结点） 子孙结点（该结点所有子树中的全部结点）</li><li>兄弟结点（同一个结点的子结点互为兄弟结点）</li><li>结点层次（相当于家谱中的第几代） 树的高度（结点的最大层次） 结点高度（以该结点为根的子树高度）</li><li>有序树（把树中每个结点的子树看成自左向右有序的）</li><li>森林（M棵互不相交的树的集合）</li></ul><h2 id="树的基本运算"><a href="#树的基本运算" class="headerlink" title="树的基本运算"></a>树的基本运算</h2><p>（1）create() 创建空树<br>（2）clear() 清除树中所有结点<br>（3）isEmpty() 判别空树<br>（4）root() 找到根结点的值<br>（5）parent(x) 找到结点x的父结点值<br>（6）child(x,i) 找结点x的第i个子结点值<br>（7）remove(x,i) 删除结点i的第i棵子树<br>（8）traverse() 访问树上每一个结点<br>还是老样子，给出树的抽象类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tree</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//flag是结点不存在时的返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">child</span><span class="hljs-params">(T x,<span class="hljs-type">int</span> i,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T x,<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树-binary-tree"><a href="#二叉树-binary-tree" class="headerlink" title="二叉树 binary tree"></a>二叉树 binary tree</h2><p>放在第一个，那自然是因为它《简单且应用广泛》</p><p>二叉树是结点的有限集合，它或者为空，或者由一个根结点及两棵互不相交的左右子树构成，而其左、右子树又都是二叉树。<strong>注意：二叉树是有序树，必须严格区分左右子树。</strong>即使只有一棵子树，也要说明它是左子树还是右子树。</p><p>二叉树有5种基本形态：<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BD%A2%E6%80%81.png" alt="二叉树的5种基本形态"></p><p>满二叉树：一棵二叉树中任意一层结点数量都达到了最大值<br>完全二叉树：在满二叉树的最底层自右向左依次去掉若干个结点（不能跳过任何一个结点）。即满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。</p><p>下面是二叉树的一些常用性质：<br>1.一棵二叉树第i层最多有2^(i - 1)个结点<br>2.一棵高度为k的二叉树上，最多有2^k - 1 个结点<br>3.对于一棵非空二叉树，如果叶子结点数为n_0，度为2的结点数为n_2，则有n_0 &#x3D; n_2 + 1<br>证明：设二叉树中度数为1的结点数量为n_1，结点总数为n，那么自然有：<br>n &#x3D; n_0 + n_1 + n_2<br>再看树枝数量B，二叉树中每个结点（除根结点外）都有一根指向他们的树枝，所以有：<br>B &#x3D; n - 1<br>这些树枝都是由度为1、2的结点发出的，所以<br>n_1 + 2 * n_2 &#x3D; n - 1<br>所以<br>n_0 &#x3D; n_2 + 1<br>4.具有n个结点的完全二叉树高度为[log_2 n] + 1<br>5.如果对一棵有n个结点的完全二叉树中的结点按层自上而下，每一层按自左至右依次编号，若设根结点的编号为1，则对任一编号为i的结点，有：<br>（1）若i &#x3D; 1，则为根结点；若i&gt;1，则父结点编号为[i&#x2F;2]<br>（2）如果2i&gt;n，则编号为i的结点为叶子结点，没有儿子；否则，其左儿子的编号为2i<br>（3）如果2i + 1&gt;n，则编号为i的结点无右儿子；否则，其右儿子的编号为2i + 1</p><h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><p>（1）create() 创建空二叉树<br>（2）clear() 清除二叉树中所有结点<br>（3）isEmpty() 判别空二叉树<br>（4）root() 找到二叉树根结点的值<br>（5）parent(x) 找到结点x的父结点值<br>（6）lchild(x) 找结点x的左结点值<br>（7）rchild(x) 找结点x的右结点值<br>（8）deLeft(x) 删除结点x的左子树<br>（9）deRight(x) 删除结点x的右子树<br>（10）traverse() 访问二叉树上每一个结点<br>对于最后一个操作——traverse()，我们有以下几种方式实现遍历：</p><ul><li>前序遍历（先根遍历）：先访问根结点，然后前序遍历左子树，然后前序遍历右子树</li><li>中序遍历（中根遍历）：先中序遍历左子树，然后访问根结点，然后中序遍历右子树<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="二叉树中序遍历"></li><li>后序遍历（后根遍历）：先后序遍历左子树，然后后序遍历右子树，最后访问根结点</li><li>层次遍历：在访问了第k层的所有结点后，再按从左到右的次序访问第k+1层</li></ul><p>前序遍历+中序遍历可以确定一棵二叉树（通过前序遍历找到根结点，然后得到左子树右子树，下面就是递归了），同理，后序遍历+中序遍历也可以确定一棵二叉树，但前序遍历+后序遍历无法确定一棵二叉树（易举反例）</p><p>下面是二叉树的抽象类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bTree</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">Root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= O;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">lchild</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">rchild</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">preOreder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的顺序实现"><a href="#二叉树的顺序实现" class="headerlink" title="二叉树的顺序实现"></a>二叉树的顺序实现</h2><p>与线性结构一样，所谓的顺序存储就是将数据元素存放在一个<strong>数组</strong>中<br>若是完全二叉树，那显然用数组实现将会非常简单，结点的存储位置可以直接反应出结点的存储关系。</p><p>但如果需要存储的二叉树不是完全二叉树，情况就会比较不同。父子间数量关系（性质5）并不成立。可能的解决方案是在残缺位置上添加“虚结点”使之变成一棵完全二叉树。<br>如下图所示：<br><img src="/img/%E8%99%9A%E7%BB%93%E7%82%B9%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="虚结点二叉树"></p><h2 id="二叉树的链接实现"><a href="#二叉树的链接实现" class="headerlink" title="二叉树的链接实现"></a>二叉树的链接实现</h2><h3 id="标准存储方式——二叉链表"><a href="#标准存储方式——二叉链表" class="headerlink" title="标准存储方式——二叉链表"></a>标准存储方式——二叉链表</h3><p>在二叉链表中，每个存储结点由3个字段组成，存储数据元素值的数据字段以及指向左、右儿子的指针字段。如下所示：<br>| left | data | right | </p><p>下面是二叉链表存储示例：</p><p><img src="/img/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8.png" alt="二叉链表存储"></p><h3 id="广义标准存储方式——三叉链表"><a href="#广义标准存储方式——三叉链表" class="headerlink" title="广义标准存储方式——三叉链表"></a>广义标准存储方式——三叉链表</h3><p>在标准存储结构的基础上，再增加一个指向其父亲结点的指针，这就是广义标准存储方式<br>| data | left | parent | right |</p><p>下面是三叉链表存储示例：</p><p><img src="/img/%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8.png" alt="三叉链表存储"></p><h3 id="Conclude"><a href="#Conclude" class="headerlink" title="Conclude"></a>Conclude</h3><p>由于二叉链表的简洁，且查找父亲的操作较为少见，所以我们更为常用的还是<strong>二叉链表</strong></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.pdai.tech/md/algorithm/alg-basic-tree.html">https://www.pdai.tech/md/algorithm/alg-basic-tree.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic1</title>
    <link href="/2025/02/21/Mathematical-Logic1/"/>
    <url>/2025/02/21/Mathematical-Logic1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-数理逻辑是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是Yin-Qiang，Yijia-Chen的学生。后续会更新这门“抽象”的课的Lecture-Notes❤️"><a href="#Before-数理逻辑是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是Yin-Qiang，Yijia-Chen的学生。后续会更新这门“抽象”的课的Lecture-Notes❤️" class="headerlink" title="Before: 数理逻辑是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是Yin Qiang，Yijia Chen的学生。后续会更新这门“抽象”的课的Lecture Notes❤️"></a>Before: 数理逻辑是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是Yin Qiang，Yijia Chen的学生。后续会更新这门“抽象”的课的Lecture Notes❤️</h5><h1 id="Methematical-Logic-1-Introduction-The-Syntax-of-First-order-Logic"><a href="#Methematical-Logic-1-Introduction-The-Syntax-of-First-order-Logic" class="headerlink" title="Methematical Logic 1 Introduction &amp; The Syntax of First-order Logic"></a>Methematical Logic 1 Introduction &amp; The Syntax of First-order Logic</h1><h2 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h2><p>Four Problems mainly</p><ul><li>What is a mathematical proof</li><li>What makes a proof correct</li><li>Is there a boundary of provability</li><li>Can computers find proofs</li></ul><h3 id="Q1-What-is-a-mathematical-proof"><a href="#Q1-What-is-a-mathematical-proof" class="headerlink" title="Q1.What is a mathematical proof"></a>Q1.What is a mathematical proof</h3><p>Based on first-order logic</p><h3 id="Q2-What-makes-a-proof-correct"><a href="#Q2-What-makes-a-proof-correct" class="headerlink" title="Q2.What makes a proof correct"></a>Q2.What makes a proof correct</h3><p>Gödel Completeness Theorem</p><h3 id="Q3-Is-there-a-boundary-of-provability"><a href="#Q3-Is-there-a-boundary-of-provability" class="headerlink" title="Q3.Is there a boundary of provability"></a>Q3.Is there a boundary of provability</h3><p>Gödel’s First Incompleteness Theorem</p><h3 id="Q4-Can-computers-find-proofs"><a href="#Q4-Can-computers-find-proofs" class="headerlink" title="Q4.Can computers find proofs"></a>Q4.Can computers find proofs</h3><p>Any computer program cannot decide whether an arbitrary input mathematical statement has a proof.<br>Turing’s undecidability of the halting problem.(图灵停机问题不可判定)</p><p>Below is A Proof of Q4:<br>φP,x has a proof | P will eventually halt on input x<br>1.construct the mathematical statement φx,x<br>2.call the program T on input φx,x<br>3.if T(φx,x) &#x3D; yes then run forever else halt</p><p>Then we can get that H(H) haltss iff H(H) does not halt.(Using what we know up)</p><h2 id="The-Syntax-of-First-order-Logic-一阶逻辑语法"><a href="#The-Syntax-of-First-order-Logic-一阶逻辑语法" class="headerlink" title="The Syntax of First-order Logic 一阶逻辑语法"></a>The Syntax of First-order Logic 一阶逻辑语法</h2><h3 id="Alphabets-字母表"><a href="#Alphabets-字母表" class="headerlink" title="Alphabets 字母表"></a>Alphabets 字母表</h3><p>an nonempty set of symbols 非空符号的集合</p><h3 id="Word-词"><a href="#Word-词" class="headerlink" title="Word 词"></a>Word 词</h3><p>A word w over A(an Alphabet) is a finite sequence of symbols in A,i.e,<br>$$<br>w &#x3D; w_1w_2…w_n<br>$$<br>$<br>w_i \in A<br>$<br>$A^*$ denotes the set of all words over A</p><h3 id="Countable-Set"><a href="#Countable-Set" class="headerlink" title="Countable Set"></a>Countable Set</h3><p>There exists an injective function(单射) α from N onto M<br>At most countable: if M is either finite or countable</p><p>Two lemmas<br>1.These three equivalent:<br>(1)M is at most countable<br>(2)an surjective function f:N -&gt; M<br>(3)an injective function f:M -&gt; N<br>2.A is most countable,then $A^*$ is countable.</p><h3 id="Terms-项"><a href="#Terms-项" class="headerlink" title="Terms 项"></a>Terms 项</h3><p>Variable Constant are both S-terms.<br>And if f is a n-ary function symbol in S,then f(S-terms) is also a S-term.</p><h3 id="Formula-公式"><a href="#Formula-公式" class="headerlink" title="Formula 公式"></a>Formula 公式</h3><p>The set $L^S$ of S-formulas contains precisely those words in $A^∗_S$ which can be obtained by applying the following rules finitely many times.<br><img src="/img/Formula.png" alt="Formula Rules"></p><h3 id="Variables-变量"><a href="#Variables-变量" class="headerlink" title="Variables 变量"></a>Variables 变量</h3><p>Let t be a S-term, then var(t) is the set of variables in t.</p><h3 id="Free-Variables-自由变元"><a href="#Free-Variables-自由变元" class="headerlink" title="Free Variables 自由变元"></a>Free Variables 自由变元</h3><p>We say that an occurrence of x in φ is free if it is not in the scope of any ∀x or ∃x.<br>只有出现在约束范围内的变量才算是约束出现的</p><h3 id="Sentence-句子"><a href="#Sentence-句子" class="headerlink" title="Sentence 句子"></a>Sentence 句子</h3><p>If free(φ) is ∅,then it’s a sentence. 没有自由变元<br>Reflect Mathematical characteristics.<br>$L_N^S$:&#x3D; {φ | φ an S-formula with free(φ) ⊆ {v0, . . . , vn−1}}.</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure8</title>
    <link href="/2025/02/20/Data-Structure8/"/>
    <url>/2025/02/20/Data-Structure8/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：字符串是琴弦，想弹琴了🎸🎹🪕"><a href="#Before：字符串是琴弦，想弹琴了🎸🎹🪕" class="headerlink" title="Before：字符串是琴弦，想弹琴了🎸🎹🪕"></a>Before：字符串是琴弦，想弹琴了🎸🎹🪕</h5><h1 id="Data-Structure-8-字符串"><a href="#Data-Structure-8-字符串" class="headerlink" title="Data Structure 8 字符串"></a>Data Structure 8 字符串</h1><h2 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h2><p>字符串是由若干个字符按照一定顺序组合而成，如果把单个字符看作一个元素，则可把字符串看成是一个字符类型的线性表。但区别在于，线性表中的个体大多相互独立，强调的是对表中某个元素的操作，而字符串更强调的是整体的操作，是对多个字符串的同时操作。关于字符串的基本操作有以下几种：<br>1.求字符串中元素个数length(s)<br>2.字符串输出disp(s)<br>3.判断两个字符串相等equal(s1,s2)、大于greater(s1,s2)大于等greaterEqual(s1, s2)、小于less(s1,s2)小于等于lessEqual(s1,s2)，按字母序判断两个字符串的大小，返回true或者false<br>4.字符串赋值copy(s1,s2)，将字符串s2赋值给另一个字符串s1。如t的值“SHANGHAI”,s的值是“UNIVERSITY”，执行copy(t,s)后，t的值变为“UNIVERSITY”。<br>5.字符串连接cat(s1,s2)，将字符串s2中的字符序列连接到字符串s1的字符序列之后。<br>6.取子串substr(s,start,len)，在字符串 s 中从start开始取长度为len的子串。<br>7.字符串插入insert(s1, start, s2)<br>8.删除子串remove(s, start, len)<br>9.查找子串search(s1,s2)</p><h2 id="字符串的顺序实现"><a href="#字符串的顺序实现" class="headerlink" title="字符串的顺序实现"></a>字符串的顺序实现</h2><p>字符串本质上是一个线性表，因而可以采用顺序存储。我们要做的是创建一个字符类型的数组。我们常说C风格字符串和C++字符串，那么C语言和C++在字符串这一数据结构的处理上有何区别呢？</p><p><img src="/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E6%AF%94.png" alt="C风格字符串与C++字符串对比"></p><p>而更为底层的区别在于，C语言的字符串是采用静态的顺序存储，使用一个以null(‘\0’)字符结尾的字符数组来保存字符串，而C++中则把字符串封装成了一种数据类型string，采用动态的顺序存储，并用运算符重载实现了赋值、连接、比较等操作，使字符串类型的变量能与整型、实型等内置类型的变量一样用运算符操作。</p><p>那么顺序串的存储实现采用一个动态的字符数组（一个动态数组自然需要一个指向数组首地址的指针和数组的大小两个量），但由于C++字符串必须以’\0’结尾，故不管该字符数组后面还有多少元素，一旦遇到’\0’，即终止，故字符串类的动态字符数组不需要记录数组的大小。</p><h2 id="字符串类的顺序实现"><a href="#字符串类的顺序实现" class="headerlink" title="字符串类的顺序实现"></a>字符串类的顺序实现</h2><p>在上代码前，让我们先明晰一下，字符串类的实现要点：</p><p>1.构造函数：接受一个字符串常量作为参数。构造函数会动态分配一个数组来存储这个字符串。<br>2.拷贝构造函数和析构函数：由于使用了动态内存分配，需要定义拷贝构造函数来正确处理对象的拷贝，以及析构函数来释放分配的内存。（<strong>回顾《程序设计思想与方法》</strong>，存在动态内存分配时，简单的浅拷贝（按位复制）会导致多个对象共享同一块内存。这可能导致析构时多次释放同一内存（double free），引发未定义行为。）<br>3.运算符的重载（字符串操作包含很多运算符运算）：输出、赋值、比较、输出。（<strong>回顾《程序设计思想与方法》</strong>，运算符重载通常定义为友元函数，出于对称性的考虑，即如果其中一个操作数不是类的对象，重载为成员函数可能会导致不对称性；也出于自然语法中输入输出运算符的左操作数通常是流对象，而不是自定义类的对象。）</p><p>下面给出字符串类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqString</span>&#123;<br>    <span class="hljs-keyword">friend</span> seqString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ofstream &amp;os,<span class="hljs-type">const</span> seqString &amp;s);<br><br>    <span class="hljs-type">char</span> *data;<br>    <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> seqString &amp;other);<br>        ~<span class="hljs-built_in">seqString</span>();<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-comment">// 补充说明一下这里添加const的原因：</span><br>        <span class="hljs-comment">//  保证函数不会修改对象；允许在常量对象上调用</span><br>        seqString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> seqString&amp;other);<br>        <span class="hljs-function">seqString <span class="hljs-title">subStr</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">const</span> seqString &amp;s)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>** 有趣的是，这里字符串类居然没有使用类模板？！不会是因为elemType都是char吧🤣🤣🤣</p><p>接下来就是字符串类的具体实现了，话不多说，上代码！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">seqString::seqString(<span class="hljs-keyword">const</span> char*s)&#123;<br>    int i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    len = i;<br>    <span class="hljs-keyword">data</span> = new char[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt;= len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = s[i];<br>    &#125;<br>&#125;<br><br>seqString::seqString(<span class="hljs-keyword">const</span> seqString &amp;other)&#123;<br>    <span class="hljs-keyword">data</span> = new char[other.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt;= other.len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = other.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    len = other.len;<br>&#125;<br><br>seqString::~seqString()&#123;<br>    delete []<span class="hljs-keyword">data</span>;<br>&#125;<br><br>int seqString::length() <span class="hljs-keyword">const</span>&#123;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br>seqString &amp;seqString::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> seqString&amp;other)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    delete []<span class="hljs-keyword">data</span>;<br>    len = other.len;<br>    <span class="hljs-keyword">data</span> = new char[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt;= len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = other.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>seqString seqString::substr(int start,int num)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    seqString s;<br>    <span class="hljs-keyword">if</span>(start + num &gt; len)&#123;<br>        s.len = len - start;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        s.len = num;<br>    &#125;<br>    delete []s.<span class="hljs-keyword">data</span>;<br>    s.<span class="hljs-keyword">data</span> = new char[s.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; s.len;i ++)&#123;<br>        s.<span class="hljs-keyword">data</span>[i] = <span class="hljs-keyword">data</span>[start + i];<br>    &#125;<br>    s.<span class="hljs-keyword">data</span>[s.len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br>void seqString::insert(int start,<span class="hljs-keyword">const</span> seqString &amp;s)&#123;<br>    char *tmp = <span class="hljs-keyword">data</span>;<br>    <span class="hljs-keyword">if</span>(start &gt; len || start &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    len += s.len;<br>    <span class="hljs-keyword">data</span> = new char[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; start; i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = tmp[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = start; i &lt; start + s.len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = s.<span class="hljs-keyword">data</span>[i - start];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = start + s.len; i &lt;= len; i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = tmp[i - s.len];<br>    &#125;<br>    <br>    delete tmp;<br>&#125;<br><br>void seqString::remove(int start,int num)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(start + num &gt;= len)&#123;<br>        <span class="hljs-keyword">data</span>[start] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        len = start;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = start + num; i &lt; len; i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i - num] =<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    len -= num;<br>    <span class="hljs-keyword">data</span>[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>seqString <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    seqString tmp;<br>    tmp.len = s1.len + s2.len;<br>    delete []tmp.<span class="hljs-keyword">data</span>;<br>    tmp.<span class="hljs-keyword">data</span> = new char[tmp.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; s1.len; i ++)&#123;<br>        tmp.<span class="hljs-keyword">data</span>[i] = s1.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; s2.len; i ++)&#123;<br>        tmp.<span class="hljs-keyword">data</span>[s1.len + i] = s2.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    tmp.<span class="hljs-keyword">data</span>[tmp.len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1.len != s2.len)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt;= s1.len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-keyword">data</span>[i] != s2.<span class="hljs-keyword">data</span>[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 == s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; s1.len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-keyword">data</span>[i] &gt; s2.<span class="hljs-keyword">data</span>[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-keyword">data</span>[i] &lt; s2.<span class="hljs-keyword">data</span>[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 &gt; s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s1 == s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 &gt;= s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 &gt; s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ofstream &amp;os,<span class="hljs-keyword">const</span> seqString &amp;s)&#123;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; s.len; i ++)&#123;<br>        os &lt;&lt; s.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串类的链接实现"><a href="#字符串类的链接实现" class="headerlink" title="字符串类的链接实现"></a>字符串类的链接实现</h2><p>正常的链表理应当在一个结点中存储一个字符，这种存储方式使insert和remove操作容易实现，但太浪费空间。在每个结点中，数据只占一个字节，而指针却要占多个字节。为了提高空间利用率，可使每个结点存放多个字符，称为<strong>块状链表</strong>😅😅😅😅😅流汗黄豆贴满了，应该能看出JaneZ对块状链表的无语了吧，一个差点要了我命的数据结构，《重生之JaneZ要斩了块状链表》，即将上演。</p><p>下图是一张块状链表的示意图：</p><p><img src="/img/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="块状链表存储字符串"><br>块状链表提高了空间的利用率，但插入和删除时会引起数据的大量移动.例如在上图中的字符串中删除”C”，所有结点的数据都要发生变化。数据插入也是如此。为了提高插入和删除的效率，块状链表通常允许结点有一定的空闲空间。</p><p>如在上图的字符串中删除”C”只需在第一个结点中删除”C”，其他结点保持不变。如要删除”EFGI”只需删除第2个结点，并在原第3个结点中删除”I”。当需要在”F”后插入字符串”UVXYZ”时，先形成两个新的结点”UVX”和”YZ”，然后将结点”EFG”分裂成两个结点”EF”和”G”，将两个新结点插入它们之间。为了保证块状链表不退化成单个字符的链表，检查新插入的最后一个结点和后面一个结点能否合并成一个结点。</p><p><img src="/img/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8%E8%BF%87%E7%A8%8B.png" alt="块状链表执行insert操作具体过程"></p><p>一些实现要点：链接串类的存储采用带头结点的块状链表。由于采用链接存储，在链接串类中定义了一个私有的内嵌类node，即链表中的结点类。每个结点由3部分组成：结点中的有效字符数、保存字符串的字符数组以及一个指向后继结点的指针。链接串类有 3 个数据成员：指向头结点的指针、字符串的长度以及每个结点的容量。</p><p>下面给出代码实现：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkString</span>&#123;<br>    <span class="hljs-keyword">friend</span> linkString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ofstream &amp;os,<span class="hljs-type">const</span> linkString &amp;s);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">int</span> size;<br>        Node *next;<br>        <span class="hljs-type">char</span> *data;<br><br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>,Node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>            data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s];<br>            next = n;<br>            size = s;<br>        &#125;<br>    &#125;;<br><br>    Node *head;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span> nodeSize;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//释放块状链表的存储空间</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPos</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> &amp;pos,Node *&amp;p)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">//找到第start个字符所在的结点地址p以及在结点中的位置pos </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(Node *p,<span class="hljs-type">int</span> pos)</span></span>;<br>    <span class="hljs-comment">//split函数将指针p指向的结点以位置pos为界分裂成两个结点。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(Node *p)</span></span>;<br>    <span class="hljs-comment">//merge函数检查p指向的结点是否能与它的直接后继合并成一个结点。 </span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> linkString &amp;other);<br>        ~<span class="hljs-built_in">linkString</span>();<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        linkString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> linkString&amp;other);<br>        <span class="hljs-function">linkString <span class="hljs-title">subStr</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">const</span> linkString &amp;s)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关于块状链表的性能，研究表明（事实上好像未必），块状链表的结点容最与结点个数相同时算法的效率是最高的。所以将结点数量设为 $\sqrt{len}$ </p><p>具体实现：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs xl">linkString::linkString(const char *s = <span class="hljs-string">&quot;&quot;</span>)&#123;<br>    Node *p;<br><br>    int i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&quot;\0&quot;</span>)&#123;<br>            break;<br>        &#125;<br>    &#125;<br>    len = i;<br>    nodeSize = <span class="hljs-built_in">sqrt</span>(len);<br><br>    <span class="hljs-keyword">while</span>(*s)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(<span class="hljs-number">1</span>);<br>        <span class="hljs-function"><span class="hljs-title">for</span>( ; p -&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> &lt; nodeSize &amp;&amp; *s; p -&gt;</span> size ++,s ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span>size] = *s;<br>        &#125;<br>    &#125;<br>&#125;<br><br>linkString::linkString(const linkString &amp;other)&#123;<br>    Node *p = head = new Node(<span class="hljs-number">1</span>);<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *otherp = other.head -&gt;</span> next;<br>    <span class="hljs-keyword">while</span>(otherp)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(<span class="hljs-number">1</span>);<br>        <span class="hljs-function"><span class="hljs-title">for</span>(;p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> &lt; other.nodeSize &amp;&amp; otherp -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>];p -&gt;</span> size ++, otherp ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>] = otherp -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">otherp</span> = otherp -&gt;</span> next;<br>    &#125;<br>    len = other.len;<br>    nodeSize = other.nodeSize;<br>&#125;<br><br>void clear()&#123;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *p = head -&gt;</span> next;<br>    Node *tmp;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        tmp = p;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>        delete tmp;<br>    &#125;<br>&#125;<br><br>~linkString()&#123;<br>    clear();<br>    delete head;<br>&#125;<br><br>int linkString::length() const&#123;<br>    return len;<br>&#125;<br><br>linkString &amp;linkString::operator=(const linkString&amp;other)&#123;<br>    <span class="hljs-keyword">if</span>(other == this)&#123;<br>        return *this;<br>    &#125;<br><br>    clear();<br>    Node *p = head;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *otherp = other.head -&gt;</span> next;<br>    <span class="hljs-keyword">while</span>(otherp)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(<span class="hljs-number">1</span>);<br>        <span class="hljs-function"><span class="hljs-title">for</span>(;p-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> &lt; other.nodeSize &amp;&amp; otherp-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>];p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> ++, otherp-&gt;</span><span class="hljs-keyword">data</span> ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>] = otherp-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span>size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">otherp</span> = otherp -&gt;</span> next;<br>    &#125;<br>    len = other.len;<br>    nodeSize = other.nodeSize;<br>    return *this;<br>&#125;<br><br>void linkString::findPos(int start,int &amp;pos,Node *&amp;p) const&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        return;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">p</span> = head -&gt;</span> next;<br>    int count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(start - count &gt; p.size)&#123;<br>            count += p.size;<br>            <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pos = start - count;<br>            return;<br>        &#125;<br>    &#125;<br>&#125;<br><br>linkString linkString::subStr(int start,int num)&#123;<br>    linkString tmp;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        return tmp;<br>    &#125;<br>    Node *p;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *tmpp = tmp -&gt;</span> head;<br>    int pos;<br><br>    <span class="hljs-keyword">if</span>(start + num &gt; len)&#123;<br>        num = len - start ;<br>    &#125;<br>    findPos(start,pos,p);<br>    tmp.len = num;<br>    tmp.nodeSize = <span class="hljs-built_in">sqrt</span>(num);<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; num;)&#123;<br>        <span class="hljs-function"><span class="hljs-title">tmpp</span> = tmpp -&gt;</span> next = new Node(nodeSize);<br><br>        <span class="hljs-function"><span class="hljs-title">for</span>(;tmpp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> &lt; tmp.nodeSize &amp;&amp; i &lt; tmp.len;i ++,tmpp-&gt;</span>size ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(pos == p -&gt;</span> size)&#123;<br>                <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>                pos = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">tmpp</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[tmpp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>] = p -&gt;</span> <span class="hljs-keyword">data</span>[pos ++];<br>        &#125;<br>    &#125;<br><br>    return tmp;<br>&#125;<br><br>void linkString::split(Node *p,int pos)&#123;<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = new node(nodeSize,p -&gt;</span> next);<br><br>    <span class="hljs-function"><span class="hljs-title">for</span>(int i = pos; i &lt; p -&gt;</span> size; i ++)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[i - pos] = p -&gt;</span> next[i];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> = p -&gt;</span> size - pos ;<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> size = pos;<br>&#125;<br><br>void linkString::merge(Node *p)&#123;<br>    NO<span class="hljs-function"><span class="hljs-title">de</span> *tmp = p -&gt;</span> next;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(tmp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + p -&gt;</span> size &lt;= nodeSize)&#123;<br>        <span class="hljs-function"><span class="hljs-title">for</span>(int i = p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>; i &lt; tmp-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> + p -&gt;</span> size; i ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[i] = tmp -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[i - p -&gt;</span> size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> = tmp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + p -&gt;</span> size;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = tmp -&gt;</span> next;<br>        delete tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐下面是比较重要的insert和remove的实现：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xl">void linkString::insert(int start,const linkString &amp;s)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span>||start &gt;= len)&#123;<br>        return;<br>    &#125;<br><br>    Node *p;<br>    Node *tmp;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *stmp = s.head -&gt;</span> next;<br>    int pos;<br><br>    findpos(start,pos,p);<br>    split(p,pos);<br>    <span class="hljs-function"><span class="hljs-title">tmp</span> = p -&gt;</span> next;<br><br>    <span class="hljs-keyword">while</span>(stmp)&#123;<br>        <span class="hljs-function"><span class="hljs-title">for</span>(pos = 0;pos &lt; stmp -&gt;</span> size;pos ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(pos == p -&gt;</span> size)&#123;<br>                <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(nodeSize);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>] = stmp -&gt;</span> <span class="hljs-keyword">data</span>[pos];<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> size ++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">stmp</span> = stmp -&gt;</span> next;<br>    &#125;<br><br>    len += s.len;<br>    merge(p);<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> next = tmp;<br>&#125;<br><br>void linkString::remove(int start,int num)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span>||start &gt;= len)&#123;<br>        return;<br>    &#125;<br>    Node *p;<br>    int pos;<br>    findPos(start,pos,p);<br>    split(p,pos);<br><br>    <span class="hljs-keyword">if</span>(start + num &gt; len)&#123;<br>        num = len - start;<br>        len = start;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        len -= num;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        N<span class="hljs-function"><span class="hljs-title">ode</span> *tmp = p -&gt;</span> next;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(num - tmp-&gt;</span>size &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-function"><span class="hljs-title">num</span> -= tmp -&gt;</span> size;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = tmp -&gt;</span> next;<br>            delete tmp;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            split(tmp,num);<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = tmp -&gt;</span> next;<br>            delete tmp;<br>            break;<br>        &#125;<br>    &#125;<br>    merge(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>重载运算符部分与顺序实现类似，较容易，就不写了（bushi）。又一遍块状链表真是把人快搞死了😅，真难写啊呜呜呜…字符串相关算法（kmp，字符串哈希等）上学期上机课有过介绍，就不会再出现了（偷懒😋）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CSDN:<a href="https://blog.csdn.net/yf210yf/article/details/8777131">https://blog.csdn.net/yf210yf/article/details/8777131</a><br>CSDN:<a href="https://blog.csdn.net/tuolaji8/article/details/51362698">https://blog.csdn.net/tuolaji8/article/details/51362698</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构2</title>
    <link href="/2025/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"/>
    <url>/2025/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构2-线性表"><a href="#数据结构2-线性表" class="headerlink" title="数据结构2 线性表"></a>数据结构2 线性表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表的抽象类中，少了构造函数（对应create函数），多了析构函数。我们将create函数交给了具体类的构造函数。那为什么要加析构函数呢？这里的虚析构函数是为了防止派生类中出现内存泄漏。计算机看到抽象类的析构函数时，才回去找到派生类中的析构函数，防止派生类出现内存泄漏。<br><code>virtual ~list()&#123;&#125;;</code></p><h3 id="什么是顺序实现？"><a href="#什么是顺序实现？" class="headerlink" title="什么是顺序实现？"></a>什么是顺序实现？</h3><p>线性表中结点存放在存储器上一块连续的空间中，即一个<strong>数组</strong>。且这个数组一定是动态数组。借助存储空间的连续性，结点可以按照其逻辑顺序依次存放。顺序表类的定义同样不太常见，是一个类模板的继承。在实现时，我们需要注意顺序存储的容量问题，有2种解决方法，要么不执行操作（这不好吧），要么让用户觉得这是一个无限的空间，即程序员需要增设一个扩大空间的函数。<br>但顺序表同样存在一个问题，当执行insert操作时，最坏时间复杂度达到了O(N)，remove操作也同样如此，所以当执行插入删除操作次数较少时，适合用顺序实现（静态的）</p><h3 id="什么是链接实现"><a href="#什么是链接实现" class="headerlink" title="什么是链接实现"></a>什么是链接实现</h3><p>每个结点存放在独立的存储空间中，结点间的逻辑关系依靠存储单元中附加的指针给出。通常用链表实现，具体有单链表、双链表和循环链表</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>注意：struct默认成员是public，而class默认成员是private</p><p>所以，在整个单链表类中，我们将Node类定为private，但Node类内部成员均为public，这是因为我们需要在Node结构体外调用各种数据成员，但是从外部来看，class外的成员无需知晓内部实现，更无需调用Node结构体中成员变量。</p><p>执行insert操作时，可以调用一个<strong>私有的</strong>move函数，返回指向相应结点的指针。同样在remove操作时，也是调用move函数定位。</p><h2 id="双链表-循环链表"><a href="#双链表-循环链表" class="headerlink" title="双链表 循环链表"></a>双链表 循环链表</h2><p>对于：有经常要找前驱的操作</p><p>循环链表又分为单循环链表、双循环链表，单循环链表很适合解决约瑟夫环问题</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL（标准模板库）：C++中数据结构的实现，这些数据结构称为集合或容器</p><ul><li>vector: 线性表的顺序实现<br>特有操作：[]的重载，按下标访问元素</li><li>list: 线性表的双链表实现<br>特有操作：表头的插入和删除</li></ul><h2 id="迭代器操作"><a href="#迭代器操作" class="headerlink" title="迭代器操作"></a>迭代器操作</h2><p>迭代器：指向容器中元素的抽象指针<br>迭代器都被定义为对应容器的公有内嵌类，所有迭代器都有相同的名字</p><ul><li>const_iterator</li><li>iterator</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>FILO 先进后出结构<br>进栈运算在最坏情况下的时间复杂度是O(N)，这很不公平，因为很少发生doubleSpace()的情况。为了更加合理，我们提出均摊分析法，把多出的次数分摊到先前进栈、出栈操作中每个插入只多了一个复制操作，因此从平均的意义上讲，插入运算的时间复杂度还是常批的。</p><p>STL中的栈是一个容器适配器，借助vector、list、deque</p><h2 id="栈的应用（QUITE-IMPORTANT-FOR-THE-COMPILER）"><a href="#栈的应用（QUITE-IMPORTANT-FOR-THE-COMPILER）" class="headerlink" title="栈的应用（QUITE IMPORTANT FOR THE COMPILER）"></a>栈的应用（QUITE IMPORTANT FOR THE COMPILER）</h2><h3 id="递归函数的非递归实现"><a href="#递归函数的非递归实现" class="headerlink" title="递归函数的非递归实现"></a>递归函数的非递归实现</h3><p>递归函数中，每次递归调用都要花费系统时间和空间。于是我们的想法是：把递归函数变成非递归函数。</p><p>首先，我们需要知道计算机是如何进行函数调用的————栈！！！<br>栈中保存的是调用结束后回到的地址，如果递归函数调用层次过深，可能会导致Stack Over Flow(爆栈)。</p><p>为了变成一个非递归函数，我们可以考虑<strong>自己维护一个栈</strong>。<br>举个例子：快速排序<br>递归实现：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">quickSort</span>(a,low,mid-<span class="hljs-number">1</span>);<br><span class="hljs-built_in">quickSort</span>(a,mid+<span class="hljs-number">1</span>,high);<br></code></pre></td></tr></table></figure><p>非递归实现：设置一个栈，记录要做的工作（即要排序的数据段）</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">struct Node &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先将整个数组进栈，弹出一个区间，将区间分成两半，若区间长度大于2，则进栈</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> quickSort(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> size)&#123;<br>    seqStack&lt;Node&gt; st;<br>    <span class="hljs-type">int</span> mid,<span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>;<br>    Node s;<br><br>    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    s.left = <span class="hljs-number">0</span>;<br>    s.right = size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>        s = st.pop();<br>        start = s.left;<br>        end = s.right;<br>        mid = divide(a,<span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>);<br><br>        <span class="hljs-keyword">if</span>(mid - <span class="hljs-keyword">start</span> &gt; <span class="hljs-number">1</span>)&#123;<br>            s.left = <span class="hljs-keyword">start</span>;<br>            s.right = mid <span class="hljs-number">-1</span>;<br>            st.push(s);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">end</span> - mid &gt; <span class="hljs-number">1</span>)&#123;<br>            s.left = mid + <span class="hljs-number">1</span>;<br>            s.right = <span class="hljs-keyword">end</span>;<br>            st.push(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="符号平衡检查"><a href="#符号平衡检查" class="headerlink" title="符号平衡检查"></a>符号平衡检查</h3><ul><li>检查程序中括号是否匹配<br><strong>遇到右括号时，与最近遇到的、没有匹配的左括号匹配</strong><br>使用栈的思想：<br>遇到左括号，进栈，遇到右括号，将栈顶元素出栈并进行比较</li></ul><p>还有几个特殊情况：<br>当括号出现在注释、字符常量、字符串常量</p><ul><li>balance类实现<br>在balance类中，为什么用输入文件流对象ifstream而不是string类文件名？<br>读文件是通过文件流对象的，类中各种小函数可能都需要对文件进行读写，使用文件流对象会更加简洁。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">balance</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    ifstream fin;<br>    <span class="hljs-built_in">int</span> currentLines;<br>    <span class="hljs-built_in">int</span> errors;<br>    <span class="hljs-keyword">struct</span> Symbol&#123;<br>        <span class="hljs-built_in">char</span> Token;<br>        <span class="hljs-built_in">int</span> theLine;<br>    &#125;; <br>    <span class="hljs-built_in">enum</span> CommentType&#123;<br>        <span class="hljs-comment">//C++和C注释风格不一样</span><br>        SlashSlash;<br>        SlashStar;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    balance(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *s);<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">checkBalance</span>()</span>; <span class="hljs-comment">// 返回出错数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>balance类有2种执行方式：</p><ul><li>用户通过键盘输入文件名</li><li>将要检查的源文件名作为命令行参数<br>我们就可以利用main函数的参数<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h3><ul><li>中缀和后缀表达式<br>中缀表达式：运算符在2个运算数之间 a + b<br>中缀表达式的计算：运算符的优先级和结合性<br>后缀表达式：运算符在运算数后面 a b +<br>这就可以采用栈来存储最近的2个运算数了</li></ul><p>对于后缀表达式：</p><ul><li>初始化一个栈</li><li>依次读入后缀式的操作数和运算符直到结束<br>若读到的是操作数，则将其进栈<br>若读到的是运算符，则将栈顶的两个操作数出栈，后弹出的操作数为被操作数，先弹出的为操作数，将得到的操作数完成运算符所规定的运算，并将结果进栈</li><li>当栈中只剩有一个操作数时，弹出该操作数，它就是表达式的值</li></ul><p>程序员希望看到中缀表达式而不是后缀表达式<br>我们希望编译器将中缀表达式转化为后缀表达式<br><strong>遍历中缀表达式时，无法确定当前处理的运算符是否能够运算，但能确定它之前的运算符是否能运算</strong></p><ul><li>中缀转后缀算法<br>若读入的是<strong>操作数</strong>，立即输出<br>若读入的是<strong>闭括号</strong>，则将栈中的运算符依次出栈并输出，直到遇到相应的开括号，将开括号出栈<br>若读入的是<strong>开括号</strong>，则进栈<br>若读入的是<strong>运算符</strong>，如果栈顶运算符优先级<strong>高于或等于</strong>读入的运算符，则栈顶运算符出栈；直到栈顶运算符优先级低于读入的运算符为止，读入的运算符进栈<br>在读入操作结束时，将栈中所有的剩余运算符依次出栈并输出，直至栈空为止</li></ul><h3 id="简单计算器类实现"><a href="#简单计算器类实现" class="headerlink" title="简单计算器类实现"></a>简单计算器类实现</h3><p>使用方法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int main()&#123;<br>    calc.exp(<span class="hljs-string">&quot;3 * (7 + 5) / 6 - 2&quot;</span>)<span class="hljs-comment">;</span><br>    cout &lt;&lt; exp.result() &lt;&lt; endl<span class="hljs-comment">;</span><br>    <br>    exp <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3 * 7 + 5&quot;</span><span class="hljs-comment">;</span><br>    cout &lt;&lt; exp.result &lt;&lt; endl<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：增加乘法运算符，优先级最高！</strong><br>也就是说，只要出现乘方运算符，直接进栈，如果遇到其他运算符（当栈顶是乘方运算符时），乘方运算符直接出栈</p><p>关于calc类的设计，我们需要：</p><ul><li>一个字符串（保存表达式）</li><li>构造和析构函数</li><li>计算表达式结果</li><li>赋值运算符重载</li></ul><p>重点在于“计算表达式的结果”——result函数的实现</p><p>计算器中的表达式中的运算数都是常量，没有必要先转换成后缀表达式，在计算后缀表达式的值。可以将转换和计算两个步骤合并起来，边转换边计算<br><strong>在中缀转后缀时，发现某个运算符可以出栈时，则直接执行运算</strong><br>运算过程需要用到两个栈：中缀表达式转后缀表达式时的运算符栈，执行后缀表达式运算时的运算数栈 opStack dataStack</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>List</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure7</title>
    <link href="/2025/02/19/Data-Structure7/"/>
    <url>/2025/02/19/Data-Structure7/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：新学期第一篇DS！写于物理学实验绪论课上😋"><a href="#Before：新学期第一篇DS！写于物理学实验绪论课上😋" class="headerlink" title="Before：新学期第一篇DS！写于物理学实验绪论课上😋"></a>Before：新学期第一篇DS！写于物理学实验绪论课上😋</h5><h1 id="Data-Structure-7-队列"><a href="#Data-Structure-7-队列" class="headerlink" title="Data Structure 7 队列"></a>Data Structure 7 队列</h1><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><p>队列是一种特殊的<strong>线性表</strong>，插入限定在表的一端，删除限定在表的另一端；允许进行插入的一端成为<strong>队尾</strong>，允许进行删除的一端称为<strong>队头</strong>；位于队头的元素称为<strong>队头元素</strong>，位于队尾的元素称为<strong>队尾元素</strong>。因为这一性质，队列也被称为FIFO表（先进先出）。<br><img src="/img/%E9%98%9F%E5%88%97.png" alt="队列示意图"><br>队列的基本操作有如下5种：</p><ul><li>创建一个队列create()</li><li>入队enQueue(x)：将x插入队尾</li><li>出队deQueue()：删除队头元素</li><li>读队头元素getHead()</li><li>判空isEmpty()</li></ul><p>下面是队列的抽象类定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">queue</span>();<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="顺序队列的存储实现-用一维数组实现"><a href="#顺序队列的存储实现-用一维数组实现" class="headerlink" title="顺序队列的存储实现 用一维数组实现"></a>顺序队列的存储实现 用一维数组实现</h2><p>1.队头位置固定<br>如下图所示：<br><img src="/img/%E9%98%9F%E5%A4%B40.png" alt="队头固定在位置0"><br>入队、读取队头元素、判空操作的复杂度均为O(1)，而入队操作的复杂度为O(N)，其实现方式类似于vector类的实现，故在这里不做具体实现<br>2.队头位置不固定的顺序实现<br>一旦入队后，存储位置保持不变，而队头位置在变化，只需增加一个变量front，用于存储队头位置，这样一来所有操作的复杂度均为O(1)<br>如下图所示：<br><img src="/img/%E9%98%9F%E5%A4%B4%E4%B8%8D%E5%9B%BA%E5%AE%9A.png" alt="队头位置不固定"><br>但是这种做法的弊端在于空间很快会被用完，空间利用率低，于是我们有了：<br>3.循环队列 <strong>最常用方案</strong><br>我们可以将数列看作是首尾相连的，利用前面的空间，这样每次出队操作，有<code>front = (front + 1)%MaxSize;</code><br>如下图所示：<br><img src="/img/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="循环队列"><br>但是这会带来一个问题，就是队空和队满是，均有<code>front == rear</code>，两种情况无法区分。这时候我们可以联想在链表实现时我们构建的head结点，不存储元素。同样这种思想可以应用在这里，我们可以牺牲一个空间单元，规定front指向的单元不能存储元素，作为服务台，这样一来，队满的条件为：<br><code>(rear + 1)%MaxSize == front</code><br>队伍为空的条件为：<br><code>rear == front</code><br>下面给出循环队列的定义：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqQueue</span>: <span class="hljs-keyword">public</span> queue&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        elemType *elem;<br>        <span class="hljs-type">int</span> front,rear;<br>        <span class="hljs-type">int</span> MaxSize;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>);<br>        ~<span class="hljs-built_in">seqQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="循环队列的具体实现"><a href="#循环队列的具体实现" class="headerlink" title="循环队列的具体实现"></a>循环队列的具体实现</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">seqQueue</span>(<span class="hljs-title">int</span> <span class="hljs-title">size</span>)</span>&#123;<br>    elem = new elemType[size];<br>    MaxSize = size;<br>    front = <span class="hljs-number">0</span>;<br>    rear = <span class="hljs-number">0</span>;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::~<span class="hljs-title">seqQueue</span>()</span>&#123;<br>    <span class="hljs-keyword">delete</span> []elem;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">enQueue</span>(<span class="hljs-title">const</span> <span class="hljs-title">elemType</span>&amp; <span class="hljs-title">x</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>((rear + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span> == front)&#123;<br>        <span class="hljs-regexp">//</span> 队伍已满<br>        doubleSpace(); <span class="hljs-regexp">//</span>扩大空间<br>    &#125;<br>    rear = (rear + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span>;<br>    elem[rear] = <span class="hljs-keyword">x</span>;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">elemType</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">deQueue</span>()</span>&#123;<br>    <span class="hljs-keyword">if</span>(!isEmpty())&#123;<br>        front = (front + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span>;<br>        <span class="hljs-keyword">return</span> elem[front];<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">elemType</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">getHead</span>() <span class="hljs-title">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> elem[(front + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span>];<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">bool</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">isEmpty</span>() <span class="hljs-title">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> front == rear;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">doubleSpace</span>()</span>&#123;<br>    elemType *tmp = elem;<br>    elem = new elemType[<span class="hljs-number">2</span> * MaxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= MaxSize; i ++)&#123;<br>        elem[i] = tmp[(front + i)<span class="hljs-variable">%MaxSize</span>];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>    front = <span class="hljs-number">0</span>;<br>    rear = MaxSize;<br>    MaxSize *= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列的链接实现"><a href="#队列的链接实现" class="headerlink" title="队列的链接实现"></a>队列的链接实现</h2><p>和上一章节讨论的栈的链接实现类似，链接队列同样用单链表实现，将单链表的表头作为队头，表尾作为队尾（出于时间复杂度均控制在O(1)的考虑），下面是链接队列的示意图：<br><img src="/img/%E9%93%BE%E6%8E%A5%E9%98%9F%E5%88%97.png" alt="链接队列"><br>类似地，给出链接队列的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkQueue</span>: <span class="hljs-keyword">public</span> queue&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>            elem data;<br>            Node *next;<br>            <span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> elemType&amp; x,node *N = <span class="hljs-literal">nullptr</span>)&#123;<br>                data = x;<br>                next = N;<br>            &#125;<br>            <span class="hljs-built_in">Node</span>()&#123;<br>                next = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            ~<span class="hljs-built_in">Node</span>()&#123;&#125;<br>        &#125;;<br>        node *front;<br>        node *rear;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkQueue</span>();<br>        ~<span class="hljs-built_in">linkQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是具体的链接队列实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">linkQueue</span>()&#123;<br>    front = <span class="hljs-literal">null</span>ptr;<br>    rear = <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::~<span class="hljs-symbol">linkQueue</span>()&#123;<br>    Node *tmp;<br>    <span class="hljs-keyword">while</span>(front != <span class="hljs-literal">null</span>ptr)&#123;<br>        tmp = front;<br>        front = front -&gt; next;<br>        delete tmp;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">enQueue</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span>&amp; <span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(rear == <span class="hljs-literal">null</span>ptr)&#123;<br>        front = new node(x);<br>        rear =  front;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        rear -&gt; next =  new node(x);<br>        rear = rear -&gt; next;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">deQueue</span>()&#123;<br>    Node *p = front;<br>    front = front -&gt; next;<br>    <span class="hljs-keyword">if</span>(front == <span class="hljs-literal">null</span>ptr)&#123;<br>        rear = <span class="hljs-literal">null</span>ptr;<br>    &#125;<br>    elemType tmp = p -&gt; data;<br>    delete p;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">getHead</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> front -&gt; data; <br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> front == <span class="hljs-literal">null</span>ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL中的队列"><a href="#STL中的队列" class="headerlink" title="STL中的队列"></a>STL中的队列</h2><p>与栈类似，STL中的队列也是一个容器适配器，借助于list或deque实现。所以同栈一样，在使用stl::queue时，需要指明2个参数，第一个为队列元素类型，第二个为借助的底层容器，若不指明则默认为deque<br>这里是第二次出现deque这个容器了，那么就让我们来了解一下这个似乎我们不常听闻的底层容器吧😄<br>⭐deque是一个双向队列（double-ended queue），可以在队列的两端进行元素的插入和删除操作。deque是C++STL（标准模板库）中的一种容器，可以用于存储各种类型的元素。特点是可以在队列的两端进行元素的操作，并且可以高效地在队列的任意位置进行元素的插入和删除操作。<br>其成员函数有如下这些：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在队列的尾部插入元素。</span><br><span class="hljs-function"><span class="hljs-title">emplace_front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//与push_front()的作用一样 </span><br><span class="hljs-function"><span class="hljs-title">push_front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在队列的头部插入元素。</span><br><span class="hljs-function"><span class="hljs-title">emplace_back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//与push_back()的作用一样 </span><br><span class="hljs-function"><span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//删除队列尾部的元素。</span><br><span class="hljs-function"><span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//删除队列头部的元素。</span><br><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回队列尾部元素的引用。</span><br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回队列头部元素的引用。</span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><span class="hljs-comment">//清空队列中的所有元素。</span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><span class="hljs-comment">//判断队列是否为空。</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回队列中元素的个数。</span><br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回头位置的迭代器</span><br><span class="hljs-function"><span class="hljs-title">end</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回尾+1位置的迭代器</span><br><span class="hljs-function"><span class="hljs-title">rbegin</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回逆头位置的迭代器 </span><br><span class="hljs-function"><span class="hljs-title">rend</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回逆尾-1位置的迭代器 </span><br><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在指定位置插入元素 </span><br><span class="hljs-function"><span class="hljs-title">erase</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在指定位置删除元素 </span><br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CSDN：<a href="https://blog.csdn.net/H1727548/article/details/130959610">https://blog.csdn.net/H1727548/article/details/130959610</a></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>关于队列的应用，后续会结合上机课内容，在算法部分另开一章进行解释</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构1</title>
    <link href="/2025/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/"/>
    <url>/2025/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新"><a href="#Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新" class="headerlink" title="Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新"></a>Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新</h5><h2 id="数据结构-1-引言"><a href="#数据结构-1-引言" class="headerlink" title="数据结构 1 引言"></a>数据结构 1 引言</h2><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>集合结构：两两无关<br>线性结构：除首尾元素外，每个元素仅有一个前驱和一个后驱<br>树形结构：除根元素外，每个元素都只有一个前驱，后驱数量不限<br>图型结构：每个元素可以有任意数量的前驱和后驱</p><h3 id="数据结构的操作"><a href="#数据结构的操作" class="headerlink" title="数据结构的操作"></a>数据结构的操作</h3><p>创建和释放：构造函数 + 析构函数<br>更新：插入 更新（修改）删除<br>查找：访问 搜索 遍历</p><h3 id="数据结构存储实现"><a href="#数据结构存储实现" class="headerlink" title="数据结构存储实现"></a>数据结构存储实现</h3><p>存储结点：每个存储结点存放一个数据元素<br>结点间的关系：比如链表中指向next结点的指针是一种链接存储；而vector类中我们使用的是数组存储；而对于集合结构这种杂乱的数据结构时，可用哈希存储，用一个哈希函数将数据元素与元素存储位置关联起来；另外还有索引存储，分别设置数据区和索引区<br>附加信息：比如链表中的头尾结点</p><h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><p>三个时间性能：</p><ul><li>最好情况下的时间复杂度</li><li>最坏情况下的时间复杂度</li><li>平均情况下的时间复杂度</li></ul><p>时间复杂度的表示一般有2种方法：<strong>大O表示法</strong>（取运行时间函数的主项）和 F（n）表示法（通常选择比较简单的函数形式）。有：O（1）&lt; O(logN)&lt; O(N)&lt; O(NlogN)&lt; O(N^2)&lt; O(N^3) ; O(2^N)&lt; O(N!)&lt; O(N^N)<br>那么时间复杂度应该如何计算呢?<br>核心在于：在整个程序中找出最复杂、运行时间最长的程序段的时间复杂度<br>空间性能：</p><ul><li>存储被处理数据所需的空间</li><li>实现操作所需的额外空间<br>空间复杂度一般按最坏情况处理，和时间复杂度一样同样使用大O表示法</li></ul><h3 id="经典举例：最大连续子序列和问题"><a href="#经典举例：最大连续子序列和问题" class="headerlink" title="经典举例：最大连续子序列和问题"></a>经典举例：<strong>最大连续子序列和问题</strong></h3><p>方法一：O(N^3)</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> MaxSum;<br>for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">n</span> ; i ++)&#123;<br>    for(<span class="hljs-built_in">int</span> j = i ; j &lt; <span class="hljs-built_in">n</span> ; j ++)&#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> k = i ; k &lt;= j ; k ++)&#123;<br>            <span class="hljs-built_in">sum</span> += a[k];<br>        &#125; <br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">sum</span> &gt; MaxSum)&#123;<br>            MaxSum = <span class="hljs-built_in">sum</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：O(N^2)</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> MaxSum = <span class="hljs-number">0</span> ;<br>for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">size</span> ; i ++)&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span> ;<br>    for(<span class="hljs-built_in">int</span> j = i ; j &lt; <span class="hljs-built_in">size</span> ; j ++)&#123;<br>        <span class="hljs-built_in">sum</span> += a[j];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &gt; MaxSum )&#123;<br>            MaxSum = <span class="hljs-built_in">sum</span>;<br>            start = i;<br>            <span class="hljs-keyword">end</span> = j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：分治法 O(NlogN)<br>共有3种情况：</p><ul><li>全部出现在前半部分，直接递归计算</li><li>全部出现在前半部分，直接递归计算</li><li>前半部分开始，后半部分结束</li></ul><p>那么方法也是相对应的：</p><ul><li>递归计算前半部分最大连续子序列和</li><li>递归计算后半部分最大连续子序列和</li><li>通过2个连续循环计算前半部分开始，后半部分结束的最大连续子序列和</li></ul><p>下面是代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> MaxSum(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right ,<span class="hljs-type">int</span> &amp;<span class="hljs-keyword">start</span>,<span class="hljs-type">int</span> &amp;<span class="hljs-keyword">end</span>)&#123;<br>    <span class="hljs-keyword">if</span>(left == right)&#123;<br>        start = left;<br>        end = right;<br>        <span class="hljs-keyword">if</span>(a[left] &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> MaxLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> MaxRight = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> MaxLeftTmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> MaxRightTmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> startL,endL,startR,endR;<br>    <span class="hljs-type">int</span> center = (left + right)/<span class="hljs-number">2</span>;<br>    MaxLeft = MaxSum(a,left,center,startL,endL);<br>    MaxRight = MaxSum(a,center + <span class="hljs-number">1</span>,right,startR,endR);<br>    <span class="hljs-type">int</span> leftSum,rightSum;<br>    start = center;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = center;i &gt;= left;i <span class="hljs-comment">--)&#123;</span><br>        leftSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftSum &gt; MaxLeftTmp)&#123;<br>            MaxLeftTmp = leftSum;<br>            start = i; <br>        &#125;<br>    &#125;<br>    end = center + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = center + <span class="hljs-number">1</span>;i &lt;= right;i ++)&#123;<br>        rightSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightSum &gt; MaxRightTmp)&#123;<br>            MaxRightTmp = rightSum;<br>            end = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> MaxTmp = MaxLeftTmp + MaxRightTmp;<br>    <span class="hljs-keyword">if</span>(MaxTmp &gt;= MaxLeft &amp;&amp; MaxTmp &gt;= MaxRight)&#123;<br>        <span class="hljs-keyword">return</span> MaxTmp;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(MaxLeft &gt;= MaxTmp &amp;&amp; MaxLeft &gt;= MaxRight)&#123;<br>        start = startL;<br>        end = endL;<br>        <span class="hljs-keyword">return</span> MaxLeft;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        start = startR;<br>        end = endR;<br>        <span class="hljs-keyword">return</span> MaxRight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算以下复杂度，得到T(N) &#x3D; 2T(N&#x2F;2) + N; 可以解得复杂度为O（NlogN）</p><p>方法四：穷举法的再优化 O(N)<br>通过一点逻辑判断，我们可以知道，<strong>所有与最大连续子序列毗连的连续子序列一定有负的（或0），否则会包含它们</strong>。故我们可以做出改进：当检测出一个负子序列时，可以直接让start增加到j + 1。这样一来，我们只需要：</p><p>$$<br>一个循环<br>$$</p><p>下面给出代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> MaxSumProcess(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> size)&#123;<br>    <span class="hljs-type">int</span> MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i ++)&#123;<br>        thisSum += a[i];<br>        <span class="hljs-keyword">if</span>(thisSum &lt;= <span class="hljs-number">0</span>)&#123;<br>            thisSum = <span class="hljs-number">0</span>;<br>            MaxSum = <span class="hljs-number">0</span>;<br>            tmp = i + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &gt; MaxSum)&#123;<br>            MaxSum = thisSum;<br>            start = tmp;<br>            end = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(start == size)&#123;<br>        MaxSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这种类似于动态规划的方法，时间复杂度达到了O(N)!</p><h3 id="数据结构的实现"><a href="#数据结构的实现" class="headerlink" title="数据结构的实现"></a>数据结构的实现</h3><p>过程化程序设计 VS 面向对象程序设计：过程化程序设计通过定义一组变量进行存储实现，通过一组算法进行运算实现，但是无法将数据结构定义成一个真正的程序，程序员必须掌握每个数据结构的实现。而面向对象的程序设计将存储与运算封装为类，每个数据结构可表示为一个类模板，有利于代码的重用。<br>每种数据结构用一个抽象类描述，指出该数据结构提供的操作。而每种数据结构可以有若干种实现的方法，每种实现就是一个类（从抽象类继承）。</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Time and Space Complexity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic3</title>
    <link href="/2025/02/11/Java-Basic3/"/>
    <url>/2025/02/11/Java-Basic3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Welcome-back-to-JaneZ’s-Java-Learning"><a href="#Before：Welcome-back-to-JaneZ’s-Java-Learning" class="headerlink" title="Before：Welcome back to JaneZ’s Java Learning!"></a>Before：Welcome back to JaneZ’s Java Learning!</h5><h2 id="Java-Basic-3"><a href="#Java-Basic-3" class="headerlink" title="Java Basic 3"></a>Java Basic 3</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Public VS Private ————对于fields和methods而言<br>Public: 可以被其他对象调用  Private: 只可被类内成员调用<br>那么为什么要对访问权限进行公有和私有的区分呢？</p><ul><li>为了保护私有信息</li><li>声明其他对象应该如何调用当前类</li><li>将实现与接口分离————意味着你可以自由地修改类的内部实现，而不影响使用该类的其他代码，只要公共接口保持不变</li></ul><h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><p>在函数中定义的变量只能在该函数中进行访问，而在类中定义的变量可以在类的所有函数中进行访问<br>函数级别的变量只在函数内部有效，而类级别的变量在整个类中都有效</p><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>用于引用当前对象的实例，其作用在于：</p><ul><li>明确作用域（Clarifies scope）：<br>当类中的成员变量和方法参数同名时，使用this关键字可以明确指出要访问的是成员变量而不是参数。</li><li>表示“my object”：<br>this关键字用于引用当前对象，即调用方法的对象。</li></ul><h3 id="Java的包-Package"><a href="#Java的包-Package" class="headerlink" title="Java的包 Package"></a>Java的包 Package</h3><p>类似于C++中的namespace(名字空间)</p><ul><li>每个类都属于一个包，包是组织类的一种形式</li><li>同一包中的类具有相似的用途。例如，所有与图形用户界面相关的类可能放在一个名为 gui 的包中。</li><li>包只是目录</li><li>需要导入其他包中的类<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> com.example.data;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataModel</span> </span>&#123;<br>    // 数据模型相关的代码<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h4><p>在C++中，我们有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> myapp &#123;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace myapp</span><br></code></pre></td></tr></table></figure><p>而相应的在Java中，我们有：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package com.example.myapp; <span class="hljs-comment">// 文件路径</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义的基本格式为：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> path.to.package.foo<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="包的使用方式"><a href="#包的使用方式" class="headerlink" title="包的使用方式"></a>包的使用方式</h4><p>在C++中，我们有<code>using namespace std</code><br>而相应的在Java中，我们有：<code>import path.to.package.foo.Foo</code></p><h4 id="为什么包？（好奇怪的句子"><a href="#为什么包？（好奇怪的句子" class="headerlink" title="为什么包？（好奇怪的句子"></a>为什么包？（好奇怪的句子</h4><ul><li>组合相似功能<br>包可以用来将功能相似的类组合在一起。这样做可以提高代码的模块化，使得相关功能更加集中和易于管理。</li><li>区分相似名称<br>包还可以用来区分具有相似名称的类，以避免命名冲突。<br>例如，shopping.List 和 packing.List 这两个类虽然名称相似，但它们位于不同的包中，分别代表购物清单和打包清单。通过使用包，我们可以清楚地区分这两个类，即使它们的名称相同。</li></ul><h4 id="特殊的包"><a href="#特殊的包" class="headerlink" title="特殊的包"></a>特殊的包</h4><p>首先，同一包内的类可以互相访问。<br>其次，还有一个比较特殊的包：java.lang<br>所有位于 java.lang 包中的类都不需要显式导入就可以在任何地方使用。这是Java语言规范的一部分，java.lang 包被视为Java程序的基础包，其中包含了一些最常用的类，如 String、Math、System 等。</p><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><p>起因是在使用deepseek时看到了这样一个界面：<br><img src="/img/deepseekAPI.png" alt="deepseekAPI"><br>一直对<strong>API</strong>为何物充满了疑问，出于好奇还充了10块钱买了五百万tokens，但并不知道应该如何使用😅（最近资源紧张似乎已经买不了了🤣）<br>在看到这里时十分激动，于是立刻开始了学习！<br>首先，我先问了deepseek✌，API是什么？<br><img src="/img/APIanswer.png" alt="APIanswer"><br><strong>Application Programing Interface!</strong><br>好像也没有那么抽象嘛？我的理解是就是一种很不错的工具，通过标准化接口简化开发，提升效率，广泛应用于数据访问、服务集成和微服务架构中。而我们要讨论的Java API，其实就类似于C++&#x2F;Python中的标准库（standard library）<br>Java语言包含了大量的包（packages）和类（classes），开发者可以利用Java提供的现有类来完成特定的任务，而不需要从头开始编写代码，这样可以节省时间和努力。<br>C++中的标准模板库（STL）我们已经挺熟悉的了，那么接下来，让我们看看Java API中有什么相应的数据结构：<br>1.ArrayList<br>我们知道在C++中有std::vector，可以动态地调节数组的大小，而在Java中，有一个具有同样功能的容器————<strong>ArrayList</strong>，其用法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ArrayList&lt;Book&gt; books = <span class="hljs-keyword">new</span> ArrayList&lt;Book&gt;();<br>books.<span class="hljs-keyword">add</span>(b);<br>books.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span> , a); <span class="hljs-comment">//相当于insert</span><br>books.<span class="hljs-keyword">remove</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//相当于remove</span><br></code></pre></td></tr></table></figure><p>2.Set<br>同样的，我们知道在C++中有std::set，表示集合，而在Java中，有一个具有相似功能的容器————<strong>Set</strong>，其特点如下：</p><ul><li>集合中每个对象只存储一份，即不允许重复</li><li>集合中的对象没有索引，不能通过索引访问对象<br>下面是两种主要的Set实现：</li><li>TreeSet，对应C++中的std::set  有序</li><li>HashSet，对应C++中的std::unordered_set  无序但查找更快</li></ul><p>3.Map<br>更加同样的，我们知道在C++中有std::map，表示映射，而在Java中，有一个具有相似功能的容器————<strong>Map</strong>，其特点如下：</p><ul><li>存储的是键值对（key-value pair）</li><li>可以通过查找键（key）来获取对应的值（value）<br>下面是两种主要的Map实现：</li><li>TreeMap，对应C++中的std::map  有序</li><li>HashMap，对应C++中的std::unordered_map  无序但查找更快</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure6</title>
    <link href="/2025/02/10/Data-Structure6/"/>
    <url>/2025/02/10/Data-Structure6/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎"><a href="#Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎" class="headerlink" title="Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎"></a>Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎</h5><h2 id="Data-Structure-6-栈的链接实现及栈的应用"><a href="#Data-Structure-6-栈的链接实现及栈的应用" class="headerlink" title="Data Structure 6 栈的链接实现及栈的应用"></a>Data Structure 6 栈的链接实现及栈的应用</h2><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>在上一章节的内容中，我们学习了顺序栈相关知识，知道顺序栈的实现本质是在维护一个动态数组，那么在本章节中要讲解的<strong>链接栈</strong>与顺序栈的实现有何区别呢？</p><h3 id="链接栈的存储实现"><a href="#链接栈的存储实现" class="headerlink" title="链接栈的存储实现"></a>链接栈的存储实现</h3><p>由于与栈相关的操作都是在栈顶进行的，所以并不需要直接前驱，使用单链表即可，也不需要头结点。下图是一个存储的图示：<br><img src="/img/%E9%93%BE%E6%8E%A5%E6%A0%88%E5%AD%98%E5%82%A8.png" alt="链接栈存储"><br>话不多说，上链接栈定义代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>            node *next;<br>            elemType data;<br>            <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>                next = n;<br>                data = x;<br>            &#125;<br>            <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>            ~<span class="hljs-built_in">node</span>();<br>        &#125;;<br><br>        node *top_p; <span class="hljs-comment">//栈顶结点</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkStack</span>();<br>        ~<span class="hljs-built_in">linkStack</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="链接栈运算实现"><a href="#链接栈运算实现" class="headerlink" title="链接栈运算实现"></a>链接栈运算实现</h3><p>构造函数&amp;析构函数：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">linkStack</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">linkStack</span>()</span>&#123;<br>    top_p = nullptr;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">linkStack</span>&lt;<span class="hljs-title">elemType</span>&gt;::~<span class="hljs-title">linkStack</span>()</span>&#123;<br>    node *<span class="hljs-keyword">q</span>;<br>    <span class="hljs-keyword">while</span>(t != nullptr)&#123;<br>        <span class="hljs-keyword">q</span> = top_p;<br>        top_p = top_p -&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">q</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进栈、出栈、判空、取栈顶元素：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">push</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    top_p = new node(x , top_p);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">pop</span>()&#123;<br>    node *p = top_p;<br>    top_p = top_p -&gt; next;<br>    elemType x = p -&gt; data;<br>    delete p;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> top_p == <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">top</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> top_p -&gt; data;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="STL中的栈"><a href="#STL中的栈" class="headerlink" title="STL中的栈"></a>STL中的栈</h3><p>在STL中，借助于其他容器存储数据的容器称作<strong>容器适配器</strong>。栈借助线性表进行存储，故属于容器适配器。栈可以借助的容器有vector、list和deque。在调用STL::stack时，如果不指定第二个参数，则默认是用deque来存储数据。<br>For example: <code>$stack&lt;int , vector&lt;int&gt;&gt;$</code> <code>$stack&lt;int , list&lt;int&gt;&gt;$</code></p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>1.递归调用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> printInt(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span> &lt; <span class="hljs-number">10</span>)&#123;<br>        cout.put(<span class="hljs-built_in">num</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        printInt(<span class="hljs-built_in">num</span>/<span class="hljs-number">10</span>);<br>        cout.put(<span class="hljs-built_in">num</span>%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是应用递归函数实现对一个正整数的打印的函数<br>2.括号配对 balance类的定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">balance</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        ifstream fin; <span class="hljs-comment">//待检测文件流</span><br>        <span class="hljs-built_in">int</span> curremtLine; <span class="hljs-comment">//当前处理的行号</span><br>        <span class="hljs-built_in">int</span> errors; <span class="hljs-comment">//现有的错误数量</span><br>    <span class="hljs-keyword">struct</span> Symbol&#123; <span class="hljs-comment">//栈元素类型</span><br>        <span class="hljs-built_in">char</span> token;<br>        <span class="hljs-built_in">int</span> TheLine; <br>    &#125;;<br>    <span class="hljs-built_in">enum</span> Slash&#123;<br>        SlashSlash; <span class="hljs-comment">//C++注释</span><br>        SlashStar; <span class="hljs-comment">//C注释</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">CheckMatch</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> Symb I, <span class="hljs-built_in">char</span> Symb2, <span class="hljs-built_in">int</span> Line I, <span class="hljs-built_in">int</span> Line2</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">char</span> <span class="hljs-title">GetNextSymbol</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PutBackChar</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> ch</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkipComment</span>(<span class="hljs-params"><span class="hljs-built_in">enum</span> CommentType type</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkipQuote</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> type</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">char</span> <span class="hljs-title">NextChar</span>()</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        balance(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *s);<br>        <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">CheckBalance</span>()</span>; <span class="hljs-comment">//检查括号是否匹配</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">noFile</span>&#123;&#125;; <span class="hljs-comment">//若检查文件不存在，抛出此异常</span><br></code></pre></td></tr></table></figure><p>具体实现就不给出了（还是太懒了😢😢😢）</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次交流</title>
    <link href="/2025/02/09/%E4%B8%80%E6%AC%A1%E4%BA%A4%E6%B5%81/"/>
    <url>/2025/02/09/%E4%B8%80%E6%AC%A1%E4%BA%A4%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。"><a href="#Before-今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。" class="headerlink" title="Before: 今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。"></a>Before: 今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。</h5><p>🦈🐬🦭🐳🐋🐟🐠🐡🦐🦑🐙🦞🦀🐚🪸🪼</p><h1 id="大一上学期"><a href="#大一上学期" class="headerlink" title="大一上学期"></a>大一上学期</h1><h2 id="收获-🎖️"><a href="#收获-🎖️" class="headerlink" title="收获 🎖️"></a>收获 🎖️</h2><h3 id="学习层面"><a href="#学习层面" class="headerlink" title="学习层面"></a>学习层面</h3><ul><li>新鲜的知识 ———— 数分 线代 程设</li><li>从未接触过的知识体系</li><li>新的看待科学的眼光</li><li>各类工具的使用</li></ul><h3 id="同学交往"><a href="#同学交往" class="headerlink" title="同学交往"></a>同学交往</h3><ul><li>一些玩的很好的朋友</li><li>一些大佬请教问题</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>学会了一些chore ———— 很多事情只能靠自己，不做不行</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>渐渐地在从高中生思维走出来，慢慢适应大学生活 </p><h2 id="遗憾-😢"><a href="#遗憾-😢" class="headerlink" title="遗憾 😢"></a>遗憾 😢</h2><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间分配很不合理，缺少规划意识</p><h3 id="急于求成"><a href="#急于求成" class="headerlink" title="急于求成"></a>急于求成</h3><p>学习浮躁，喜欢和他人作比较，经常莫名其妙地焦虑</p><h2 id="针对性措施"><a href="#针对性措施" class="headerlink" title="针对性措施"></a>针对性措施</h2><h3 id="时间管理-1"><a href="#时间管理-1" class="headerlink" title="时间管理"></a>时间管理</h3><ul><li>列 todoList</li><li>每天最后可以以日记的形式对一天进行复盘</li></ul><h3 id="急于求成-1"><a href="#急于求成-1" class="headerlink" title="急于求成"></a>急于求成</h3><ul><li>“榜样的力量” 找到一个比自己优秀的人，像TA看齐 ————目标意识</li><li>学业上稳扎稳打，不要一味追求速度，重视完成的质量</li></ul><h1 id="新学期（大一下学期）"><a href="#新学期（大一下学期）" class="headerlink" title="新学期（大一下学期）"></a>新学期（大一下学期）</h1><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="做出改变"><a href="#做出改变" class="headerlink" title="做出改变"></a>做出改变</h3><ul><li>减少无意义的社交</li><li>对问题进行更加深入的思考 ————深度思考</li></ul><h3 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h3><ul><li>反思旧学期存在的问题</li><li>为新学期指定可执行性强的计划</li></ul><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><ul><li>多与老师、学长、同学进行交流</li><li>一个问题想3遍</li></ul><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><h3 id="每天11-30睡"><a href="#每天11-30睡" class="headerlink" title="每天11:30睡"></a>每天11:30睡</h3><p>😴😴😴</p><h3 id="每天6-30-7-00起床"><a href="#每天6-30-7-00起床" class="headerlink" title="每天6:30 - 7:00起床"></a>每天6:30 - 7:00起床</h3><p>🛏️🛏️🛏️</p><h3 id="（无特殊情况）图书馆待到10-30"><a href="#（无特殊情况）图书馆待到10-30" class="headerlink" title="（无特殊情况）图书馆待到10:30"></a>（无特殊情况）图书馆待到10:30</h3><p>🧑‍💻👨‍💻👩‍💻</p><h3 id="尽量少点外卖，多去食堂"><a href="#尽量少点外卖，多去食堂" class="headerlink" title="尽量少点外卖，多去食堂"></a>尽量少点外卖，多去食堂</h3><p>🍚🍛🍙</p><h3 id="（由于身体原因）禁止任何含咖啡因的食物"><a href="#（由于身体原因）禁止任何含咖啡因的食物" class="headerlink" title="（由于身体原因）禁止任何含咖啡因的食物"></a>（由于身体原因）禁止任何含咖啡因的食物</h3><p>❌❌❌</p><h3 id="按时服用药物"><a href="#按时服用药物" class="headerlink" title="按时服用药物"></a>按时服用药物</h3><p>💊💊💊</p><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><h3 id="“立志”"><a href="#“立志”" class="headerlink" title="“立志”"></a>“立志”</h3><p>种下一个梦想，为之奋斗<br>追逐心中的那束光</p><h3 id="“正能量”"><a href="#“正能量”" class="headerlink" title="“正能量”"></a>“正能量”</h3><p>做一个快乐、正面、积极、幸福、知足的人❤️</p>]]></content>
    
    
    
    <tags>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic2</title>
    <link href="/2025/02/09/Java-Basic2/"/>
    <url>/2025/02/09/Java-Basic2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：快开学了（-还没玩够呢呜呜呜😢-）"><a href="#Before：快开学了（-还没玩够呢呜呜呜😢-）" class="headerlink" title="Before：快开学了（ 还没玩够呢呜呜呜😢 ）"></a>Before：快开学了（ 还没玩够呢呜呜呜😢 ）</h5><p>下面是一点碎碎念吧：<br>昨天和fz学弟吃饭，震惊于学弟对物竞的执着，想必是没法把学弟骗来泥交了吧🤣🤣🤣。想起了3年前的自己对数竞也是一样的痴迷，励志要把一生都献给纯数研究。当时应该还在学物竞，尝试着数物双修。还是在寒假后放弃了物理，选了数学，当然最后也只以高二的省一草草收场。有时候想，如果当时跟大多数人一样学了物理，大概至少也有个国一吧。经常嘴上说自己物理差数学好，其实细想自己还是挺喜欢物竞的。下学期也是终于有物理课了，希望能借此找到以前对物理的热爱❤️</p><h2 id="Java-Basic-2"><a href="#Java-Basic-2" class="headerlink" title="Java Basic 2"></a>Java Basic 2</h2><h3 id="Good-Programing-Style-代码风格"><a href="#Good-Programing-Style-代码风格" class="headerlink" title="Good Programing Style 代码风格"></a><strong>Good Programing Style 代码风格</strong></h3><ul><li>Rule 1 : 使用好的&#x2F;有意义的变量名</li><li>Rule 2 : 正确的缩进  Ctrl + shift + F 可自动调节缩进</li><li>Rule 3 : 空格 （特别是在复杂的表达式中） 空行 增强可读性</li><li>Rule 4 : 不要重复测试 可能存在多个条件判断中不必要的重复检查等问题，使得代码不够简洁和高效。</li></ul><h3 id="循环-Loops"><a href="#循环-Loops" class="headerlink" title="循环 Loops"></a>循环 Loops</h3><p>Java中有几个循环语句，与C ++ 中几乎一致</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">( condition )</span></span>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(initialization; condition ; updata)</span></span>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="break-continue"><a href="#break-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h4><p>与C ++ 中用法一致</p><h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 Arrays"></a>数组 Arrays</h3><p>与C ++ 同样都是 0 ~ base - 1</p><h4 id="Arrays-的定义"><a href="#Arrays-的定义" class="headerlink" title="Arrays 的定义"></a>Arrays 的定义</h4><p>int[] values;  &#x2F;&#x2F;整型一维数组<br>int[][] values; &#x2F;&#x2F;整型二维数组<br>如果想创建一个固定大小的数组，使用运算符 new<br>int[] values &#x3D; new int[5];</p><h4 id="Arrays-初始化"><a href="#Arrays-初始化" class="headerlink" title="Arrays 初始化"></a>Arrays 初始化</h4><p>注意：这种方法只能在声明变量时使用：<br>int[] values &#x3D; {12 , 24 , -23 , 47};</p><h4 id="Arrays-访问"><a href="#Arrays-访问" class="headerlink" title="Arrays 访问"></a>Arrays 访问</h4><p>同样是下标访问  values[index]</p><h4 id="length-变量"><a href="#length-变量" class="headerlink" title="length 变量"></a>length 变量</h4><p>Java数组在这里与C++数组存在一点区别：<br>C++中length变量只存在于STL容器中，普通数组并不具备这一变量，但Java中则存在<br>For example:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span>[] <span class="hljs-keyword">values</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">12</span>];<br><span class="hljs-type">int</span> size = <span class="hljs-keyword">values</span>.length;<br></code></pre></td></tr></table></figure><h4 id="String-Array"><a href="#String-Array" class="headerlink" title="String Array"></a>String Array</h4><p>Java中允许字符串数组（C ++ 中并不允许string数组）</p><h3 id="Object-Oriented-Programing-面向对象编程"><a href="#Object-Oriented-Programing-面向对象编程" class="headerlink" title="Object Oriented Programing 面向对象编程"></a>Object Oriented Programing 面向对象编程</h3><h4 id="Why-use-classes"><a href="#Why-use-classes" class="headerlink" title="Why use classes ?"></a>Why use classes ?</h4><p><img src="/img/whyclasses1.png" alt="Why use classes"><br><img src="/img/whyclasses2.png" alt="Why use classes"></p><h4 id="Class-Definition"><a href="#Class-Definition" class="headerlink" title="Class Definition"></a>Class Definition</h4><p><code>Baby myBaby = new Baby();</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baby</span></span>&#123;<br>    fields<br>    methods<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数-constructer"><a href="#构造函数-constructer" class="headerlink" title="构造函数 constructer"></a>构造函数 constructer</h4><ul><li>函数名即为类名</li><li>没有返回值</li><li>通常初始化fields</li><li>每个类至少需要一个构造函数<br>For example:<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span>&#123;<br>    <span class="hljs-type">String</span> name;<br>    <span class="hljs-type">boolean</span> isMale;<br>    <span class="hljs-built_in">Baby</span>(<span class="hljs-type">String</span> myname , <span class="hljs-type">boolean</span> malebaby)&#123;<br>        name = myname;<br>        isMale = malebaby;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="调用类"><a href="#调用类" class="headerlink" title="调用类"></a>调用类</h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">Baby</span> <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">Baby</span> <span class="hljs-type">Jane</span> = new <span class="hljs-type">Baby</span>(<span class="hljs-string">&quot;JaneZ&quot;</span> , <span class="hljs-literal">false</span> );<br><span class="hljs-type">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">Jane</span>.name);<br><span class="hljs-type">Jane</span>.sayhi();<br></code></pre></td></tr></table></figure><h3 id="基本数据类型-VS-引用数据类型"><a href="#基本数据类型-VS-引用数据类型" class="headerlink" title="基本数据类型 VS 引用数据类型"></a>基本数据类型 VS 引用数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>包括 int（整数）、long（长整数）、double（双精度浮点数）、boolean（布尔值）、char（字符）、short（短整数）、byte（字节）、float（单精度浮点数）</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>数组和对象<br>所占的空间比基本数据类型要大的多</p><h3 id="Java-对Object-的存储——引用！"><a href="#Java-对Object-的存储——引用！" class="headerlink" title="Java 对Object 的存储——引用！"></a>Java 对Object 的存储——引用！</h3><p><strong>Reference</strong>: Object的存储位置<br>遵循对对象的引用 &lt;-&gt; 按照指示前往一所房子<br>改变对象中的字段 &lt;-&gt; 挪动房子里的家具</p><h3 id="静态数据类型和函数"><a href="#静态数据类型和函数" class="headerlink" title="静态数据类型和函数"></a>静态数据类型和函数</h3><p>静态字段或函数是为类声明（class declaration）而定义的<br>也就是说，它们属于类本身，而不是类的某个具体实例</p><h4 id="Why-public-static-void-main-String-arguments"><a href="#Why-public-static-void-main-String-arguments" class="headerlink" title="Why public static void main(String[] arguments)"></a>Why <code>public static void main(String[] arguments)</code></h4><ul><li>无需实例化：程序启动时，Java 虚拟机（JVM）需要直接调用 main 方法来执行程序。如果 main 方法不是 static，JVM 就需要先实例化一个类的对象，然后才能调用 main 方法，但在程序启动初期，没有合适的机制来创建对象，所以将 main 声明为 static，JVM 可以直接通过类名调用它，无需创建类的实例。</li><li>内存和性能考虑：静态方法在类加载时就已经绑定到类上，调用时不需要额外的对象创建开销，这有助于提高程序启动的效率，并且在程序启动阶段也更符合内存管理和性能优化的需求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure5</title>
    <link href="/2025/02/09/Data-Structure5/"/>
    <url>/2025/02/09/Data-Structure5/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：JaneZ今天更新频率有点高啊😎😎😎（-这么良心的up还不快三连一下🤣🤣🤣-）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（-应该坐完了永初路——福建路这一段-），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（-nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕"><a href="#Before：JaneZ今天更新频率有点高啊😎😎😎（-这么良心的up还不快三连一下🤣🤣🤣-）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（-应该坐完了永初路——福建路这一段-），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（-nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕" class="headerlink" title="Before：JaneZ今天更新频率有点高啊😎😎😎（ 这么良心的up还不快三连一下🤣🤣🤣 ）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（ 应该坐完了永初路——福建路这一段 ），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（ nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕"></a>Before：JaneZ今天更新频率有点高啊😎😎😎（ 这么良心的up还不快三连一下🤣🤣🤣 ）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（ 应该坐完了永初路——福建路这一段 ），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（ nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕</h5><p><img src="/img/Metro.png" alt="清凉山地铁站"></p><h2 id="Data-Structure-5-栈"><a href="#Data-Structure-5-栈" class="headerlink" title="Data Structure 5 栈"></a>Data Structure 5 栈</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ul><li>一种特殊的线性表，插入删除运算限定在表的某一端进行</li><li>允许进行插入删除操作的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong></li><li>处于栈顶位置中的数据元素称为<strong>栈顶元素</strong>，若栈中没有元素，则称为<strong>空栈</strong></li><li>LIFO表（后进先出表）</li></ul><h3 id="栈的抽象类"><a href="#栈的抽象类" class="headerlink" title="栈的抽象类"></a>栈的抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">stack</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//判栈空</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//进栈</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//出栈</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//取栈顶元素</span><br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">stack</span>(); <span class="hljs-comment">//虚析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="栈的顺序实现"><a href="#栈的顺序实现" class="headerlink" title="栈的顺序实现"></a>栈的顺序实现</h3><p>栈的顺序实现称为<strong>顺序栈</strong><br>顺序栈的实现需要3个变量：</p><ul><li>一个指向栈元素类型的指针（指向动态数组的首地址）</li><li>一个表示数组规模的整型数</li><li>一个表示栈顶位置的整型数<br><img src="/img/%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%AD%98%E5%82%A8.png" alt="顺序栈存储"></li></ul><h4 id="下面是一个顺序栈类的定义"><a href="#下面是一个顺序栈类的定义" class="headerlink" title="下面是一个顺序栈类的定义"></a>下面是一个顺序栈类的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqStack</span> : <span class="hljs-keyword">public</span> stack&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        elemType *elem;<br>        <span class="hljs-type">int</span> top_p;<br>        <span class="hljs-type">int</span> maxSize;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);<br>        ~<span class="hljs-built_in">seqStack</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> top_p == <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">push</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(top_p == maxSize <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">double</span>Space();<br>    &#125;<br>    top_p ++;<br>    elem[top_p] == x;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">pop</span>()&#123;<br>    top_p --;<br>    <span class="hljs-keyword">return</span> elem[top_p + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">top</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> elem[top_p];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">seqList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">doubleSpace</span>()</span>&#123;<br>    elemType *tmp = elem;<br>    elem = new elemType[<span class="hljs-number">2</span> * maxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSize ; i ++)&#123;<br>        elem[i] = tmp[i];<br>    &#125;<br>    maxSize *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure4</title>
    <link href="/2025/02/07/Data-Structure4/"/>
    <url>/2025/02/07/Data-Structure4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：JaneZ换了一家咖啡店，人在Manner-Coffee-身后10米有一只孔雀（附上图片🥶🥶🥶-）"><a href="#Before：JaneZ换了一家咖啡店，人在Manner-Coffee-身后10米有一只孔雀（附上图片🥶🥶🥶-）" class="headerlink" title="Before：JaneZ换了一家咖啡店，人在Manner Coffee ,身后10米有一只孔雀（附上图片🥶🥶🥶 ）"></a>Before：JaneZ换了一家咖啡店，人在Manner Coffee ,身后10米有一只孔雀（附上图片🥶🥶🥶 ）</h5><p><img src="/img/%E5%AD%94%E9%9B%80.png" alt="孔雀"></p><h2 id="Data-Structure-4-约瑟夫环-动态内存分配"><a href="#Data-Structure-4-约瑟夫环-动态内存分配" class="headerlink" title="Data Structure 4 约瑟夫环 动态内存分配"></a>Data Structure 4 约瑟夫环 动态内存分配</h2><h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><p>约瑟夫环是一个很经典的循环链表问题，初次见于OJ上一道经典的题——春樱对决（ ACMOJ1088 ）<br>下面给出约瑟夫环问题一个最简单的例子（报到3倍数击毙）</p><h4 id="构建循环链表"><a href="#构建循环链表" class="headerlink" title="构建循环链表"></a>构建循环链表</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">head</span> <span class="hljs-operator">=</span> p  new node(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>for(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">; i &lt; n ; i ++)&#123;</span><br>    p <span class="hljs-operator">=</span> p -&gt; next <span class="hljs-operator">=</span> new node(i)<span class="hljs-comment">;</span><br>&#125;<br>p -&gt; next <span class="hljs-operator">=</span> head<span class="hljs-comment">; //首尾相连</span><br></code></pre></td></tr></table></figure><h4 id="删除结点（也就是击毙的操作）"><a href="#删除结点（也就是击毙的操作）" class="headerlink" title="删除结点（也就是击毙的操作）"></a>删除结点（也就是击毙的操作）</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">q = head;<br><span class="hljs-function"><span class="hljs-title">while</span>(q -&gt;</span> next != q)&#123;<br>    <span class="hljs-function"><span class="hljs-title">p</span> = q -&gt;</span> next;<br>    <span class="hljs-function"><span class="hljs-title">q</span> = p -&gt;</span> next;<br>    <span class="hljs-comment">//删除q</span><br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = q -&gt;</span> next;<br>    delete q;<br>    <span class="hljs-function"><span class="hljs-title">q</span> = p -&gt;</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><h4 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h4><ul><li>存储在内存中一个被称为<strong>堆</strong>的区域中，由一个堆管理器进行管理</li><li>new 操作时分配一块空间，delete 操作时回收一块空间<br>但是不断的 new delete 操作会导致内存空间的碎片化，应该如何管理这些内存片段呢？😢</li></ul><h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><ul><li>所有的空闲片段形成一个集合，按地址顺序排列就得到了线性表，故堆空间的管理实际上就是在<strong>维护一个线性表</strong></li><li>由于该线性表经常需要删除操作（就是 new ）,并且delete操作时可能需要把一些潜在的相邻的闲置空间进行合并，所以用双链表比较合适</li></ul><h4 id="模拟动态内存管理的memory类（感觉这种理解很有意思）"><a href="#模拟动态内存管理的memory类（感觉这种理解很有意思）" class="headerlink" title="模拟动态内存管理的memory类（感觉这种理解很有意思）"></a>模拟动态内存管理的memory类（感觉这种理解很有意思）</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class memory&#123;<br>    struct <span class="hljs-keyword">node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">        int</span> <span class="hljs-literal">start</span>; //起始地址<br>        int end; //终止地址<br>        <span class="hljs-keyword">node</span> <span class="hljs-title">*prev</span>; <br>        <span class="hljs-keyword">node</span> <span class="hljs-title">*next</span>;<br>        <span class="hljs-keyword">node</span><span class="hljs-title">(int</span> s, int e,<span class="hljs-keyword">node</span> <span class="hljs-title">*p</span> = nullptr,<span class="hljs-keyword">node</span> <span class="hljs-title">*n</span> = nullptr)&#123;<br>            <span class="hljs-literal">start</span> = s;<br>            end = e;<br>            prev = p;<br>            next = n;<br>        &#125;<br>        <span class="hljs-keyword">node</span><span class="hljs-title">()&#123;</span><br><span class="hljs-title">            prev</span> = nullptr;<br>            next = nullptr;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*head</span>;<br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*tail</span>;<br><br>    public:<br>        memory(int capacity);<br>        int malloc(int size); //申请一块大小为size的空间，返回起始地址<br>        void free(int <span class="hljs-literal">start</span>,int size); //释放从<span class="hljs-literal">start</span>开始、大小为size的空间<br>        ~memory();<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xquery">memory::memory(int capacity)&#123;<br>   <span class="hljs-built_in"> head</span> = new <span class="hljs-type">node</span>;<br>   <span class="hljs-built_in"> head</span> -&gt; <span class="hljs-keyword">next</span> = new <span class="hljs-type">node</span>(<span class="hljs-number">0</span> , capacity - <span class="hljs-number">1</span>,<span class="hljs-built_in"> head</span>);<br>   <span class="hljs-built_in"> head</span> -&gt; <span class="hljs-keyword">next</span> -&gt; <span class="hljs-keyword">next</span> =<span class="hljs-built_in"> tail</span> = new <span class="hljs-type">node</span>;<br>   <span class="hljs-built_in"> tail</span> -&gt; prev =<span class="hljs-built_in"> head</span> -&gt; <span class="hljs-keyword">next</span>;<br>&#125;<br><br>memory::~memory()&#123;<br>    <span class="hljs-type">node</span> *p =<span class="hljs-built_in"> head</span>;<br>    <span class="hljs-type">node</span> *q;<br>    while(p != nullpter)&#123;<br>        q = p -&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">int malloc(int size)&#123;<br>    <span class="hljs-function"><span class="hljs-title">node</span> *p = head -&gt;</span> next;<br>    int returnValue;<br>    <span class="hljs-function"><span class="hljs-title">while</span>(p != tail &amp;&amp; p -&gt;</span> <span class="hljs-function"><span class="hljs-title">end</span> - p -&gt;</span> start + <span class="hljs-number">1</span> &lt; size)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p == tail)&#123;<br>        return -<span class="hljs-number">1</span>; <span class="hljs-comment">//没有找到</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">returnValue</span> = p -&gt;</span> start;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(p -&gt;</span> <span class="hljs-function"><span class="hljs-title">end</span> - p -&gt;</span> start + <span class="hljs-number">1</span> == size)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">prev</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = p -&gt;</span> next;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">prev</span> = p -&gt;</span> prev;<br>        delete p;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> start += size;<br>    &#125;<br>    return returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xl">void memory::free(int start, int size)&#123;<br>    <span class="hljs-function"><span class="hljs-title">node</span> *p = head -&gt;</span> next;<br>    node *np;<br>    <span class="hljs-function"><span class="hljs-title">while</span>(p != tail &amp;&amp; p -&gt;</span> start &lt; start)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(p != tail &amp;&amp; start + size == p -&gt;</span> start)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> start = start;<br>        np = p;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-function"><span class="hljs-title">np</span> = new node(start , start + size - 1 ,p -&gt;</span> prev, p );<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">prev</span> -&gt;</span> next = np;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> prev = np;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">p</span> = np -&gt;</span> prev;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(p -&gt;</span> <span class="hljs-function"><span class="hljs-title">end</span> + 1 == np -&gt;</span> start)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = np -&gt;</span> next;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> end == start + size - <span class="hljs-number">1</span>;<br>        delete np;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure3</title>
    <link href="/2025/02/07/Data-Structure3/"/>
    <url>/2025/02/07/Data-Structure3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-最近装了个虚拟机（-为了Games101配的环境-），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（-打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了-）"><a href="#Before-最近装了个虚拟机（-为了Games101配的环境-），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（-打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了-）" class="headerlink" title="Before: 最近装了个虚拟机（ 为了Games101配的环境 ），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（ 打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了 ）"></a>Before: 最近装了个虚拟机（ 为了Games101配的环境 ），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（ 打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了 ）</h5><h2 id="Data-Structure-3-双链表-容器-迭代器"><a href="#Data-Structure-3-双链表-容器-迭代器" class="headerlink" title="Data Structure 3 双链表 容器 迭代器"></a>Data Structure 3 双链表 容器 迭代器</h2><p>在上一节中，我们非常详细地实现了一个单链表类（算是对上学期所学进行了一个复习），我个人认为，双链表与单链表并不存在多么显著的区别。所以本章节中关于双链表的部分会相对比较简洁。</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul><li>定义：（和单链表不同的地方）每个结点既保存直接后继结点的地址，也保存直接前驱结点的地址（单链表只保存直接后继结点的地址）</li><li>拥有直接前驱结点的地址实际上意味着双链表可以从后向前访问</li><li>双链表中既包含了一个头结点head ,还包含了一个尾结点tail；保存一个双链表事实上就是保存头尾两个结点的地址<br>下面是一个双链表类的定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dLinkList</span>: <span class="hljs-keyword">public</span> list &lt;elemType&gt;&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>        elemType data;<br>        node *prev;<br>        node *next;<br><br>        <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType&amp; x ,node *p = <span class="hljs-literal">nullptr</span>, node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>            data = x;<br>            prev = p;<br>            next = n;<br>        &#125;<br>        <span class="hljs-built_in">node</span>():<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>node *head;<br>node *tail;<br><span class="hljs-type">int</span> currentLength;<br><span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">dLinkList</span>();<br>    ~<span class="hljs-built_in">dLinkList</span>()&#123;<br>        <span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">delete</span> head;<br>        <span class="hljs-keyword">delete</span> tail;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h3><ul><li>本质上我们所说的数据结构，就是在<strong>保存一组相互之间具有某种关系的数据元素</strong>。而C++把每个数据结构的实现称为<strong>一个容器</strong></li><li>在设计容器时，我们通常为每种容器定义一个相应的表示其中对象位置的类型，称作<strong>迭代器</strong>，相当于指向容器中对象的指针</li><li>设计一个迭代器包括2个部分:<br>(1) 如何标识容器中某一对象的位置<br>(2) 如何实现迭代器的操作</li><li>为了方便用户使用，STL将迭代器类（iterator , const_iterator）定义成相应容器类的公有内嵌类</li><li>注意：iterator类可通过迭代器修改指向元素的值，而const_iterator只可以通过迭代器读取指向元素的值</li></ul><h4 id="下面是一些迭代器自身的常见操作："><a href="#下面是一些迭代器自身的常见操作：" class="headerlink" title="下面是一些迭代器自身的常见操作："></a>下面是一些迭代器自身的常见操作：</h4><p><img src="/img/%E8%BF%AD%E4%BB%A3%E5%99%A8.png" alt="迭代器自身操作"></p><h4 id="这是我手搓的STL-list类中内嵌iterator类（-const-iterator类几乎同理，只是const版本🤣🤣🤣-）的实现："><a href="#这是我手搓的STL-list类中内嵌iterator类（-const-iterator类几乎同理，只是const版本🤣🤣🤣-）的实现：" class="headerlink" title="这是我手搓的STL list类中内嵌iterator类（ const_iterator类几乎同理，只是const版本🤣🤣🤣 ）的实现："></a>这是我手搓的STL list类中内嵌iterator类（ const_iterator类几乎同理，只是const版本🤣🤣🤣 ）的实现：</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        node* ptr;<br>    <span class="hljs-keyword">public</span>:<br>        iterator(node* p = nullptr) : ptr(p) &#123;&#125;<br><br>        iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            ptr = ptr-&gt;next;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        iterator&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>            ptr = ptr-&gt;prev;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>++(int) &#123;<br>            iterator tmp = *<span class="hljs-keyword">this</span>;<br>            ++(*<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>--(int) &#123;<br>            iterator tmp = *<span class="hljs-keyword">this</span>;<br>            --(*<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> noexcept &#123;<br>            <span class="hljs-keyword">return</span> ptr-&gt;<span class="hljs-keyword">data</span>;<br>        &#125;<br><br>        T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> noexcept &#123;<br>            <span class="hljs-keyword">return</span> &amp;(ptr-&gt;<span class="hljs-keyword">data</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* A operator to check whether two iterators are same (pointing to the same memory) */</span><br>        friend bool <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> iterator&amp; a, <span class="hljs-keyword">const</span> iterator&amp; b) &#123;<br>           <span class="hljs-keyword">return</span> (a.ptr == b.ptr);<br>        &#125;<br><br>        friend bool <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> iterator&amp; a, <span class="hljs-keyword">const</span> iterator&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> (a.ptr != b.ptr);<br>        &#125;<br><br>        friend <span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="以线性表为例"><a href="#以线性表为例" class="headerlink" title="以线性表为例"></a>以线性表为例</h3><h4 id="下面是一些list类和vector类中的迭代器相关操作："><a href="#下面是一些list类和vector类中的迭代器相关操作：" class="headerlink" title="下面是一些list类和vector类中的迭代器相关操作："></a>下面是一些list类和vector类中的迭代器相关操作：</h4><p><img src="/img/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.png" alt="迭代器相关操作"></p><h4 id="这是我手搓的STL-list类中与迭代器相关的一些操作的实现🫡🫡🫡："><a href="#这是我手搓的STL-list类中与迭代器相关的一些操作的实现🫡🫡🫡：" class="headerlink" title="这是我手搓的STL list类中与迭代器相关的一些操作的实现🫡🫡🫡："></a>这是我手搓的STL list类中与迭代器相关的一些操作的实现🫡🫡🫡：</h4><p>注：其实存在一些问题（ 因为我的实现并没有考虑模板类型T 不具有默认构造函数的情况 😢 ）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Return an iterator pointing to the first element. */</span><br>iterator <span class="hljs-built_in">begin</span>() noexcept &#123;<br>    return <span class="hljs-built_in">iterator</span>(head-&gt;next);<br>&#125;<br><br>const_iterator <span class="hljs-built_in">cbegin</span>() const noexcept &#123;<br>    return <span class="hljs-built_in">const_iterator</span>(head-&gt;next);<br>&#125;<br><br><span class="hljs-comment">/* Return an iterator pointing to one past the last element. */</span><br>iterator <span class="hljs-built_in">end</span>() noexcept &#123;<br>    return <span class="hljs-built_in">iterator</span>(tail);<br>&#125;<br><br>const_iterator <span class="hljs-built_in">cend</span>() const noexcept &#123;<br>    return <span class="hljs-built_in">const_iterator</span>(tail);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">iterator</span> insert(<span class="hljs-keyword">iterator</span> pos, <span class="hljs-keyword">const</span> T&amp; value) &#123;<br>    node* n = new node(value, pos.<span class="hljs-keyword">ptr</span>-&gt;prev, pos.<span class="hljs-keyword">ptr</span>);<br>    pos.<span class="hljs-keyword">ptr</span>-&gt;prev-&gt;next = n;<br>    pos.<span class="hljs-keyword">ptr</span>-&gt;prev = n;<br>    ++ currentLength;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">iterator</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xl">iterator erase(iterator pos) noexcept &#123;<br>    <span class="hljs-keyword">if</span> (pos == end()) &#123;<br>        return end();<br>    &#125;<br>    node* tmp = pos.ptr;<br>    <span class="hljs-function"><span class="hljs-title">iterator</span> it(tmp-&gt;</span>next);<br>    <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = tmp-&gt;</span>next;<br>    <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prev</span> = tmp-&gt;</span>prev;<br>    delete tmp;<br>    -- currentLength;<br>    return it;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maths-Analysis2</title>
    <link href="/2025/02/05/Maths-Analysis2/"/>
    <url>/2025/02/05/Maths-Analysis2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-好的，又来水文章了。今天要讲的是："><a href="#Before-好的，又来水文章了。今天要讲的是：" class="headerlink" title="Before: 好的，又来水文章了。今天要讲的是："></a>Before: 好的，又来水文章了。今天要讲的是：</h5><h2 id="Maths-Analysis-2-一致收敛判别法"><a href="#Maths-Analysis-2-一致收敛判别法" class="headerlink" title="Maths Analysis 2 一致收敛判别法"></a>Maths Analysis 2 一致收敛判别法</h2><h3 id="第一种：比较判别法"><a href="#第一种：比较判别法" class="headerlink" title="第一种：比较判别法"></a>第一种：比较判别法</h3><p><img src="/img/%E6%AF%94%E8%BE%83%E5%88%A4%E5%88%AB.png" alt="比较判别法"></p><h3 id="第二种：Dirichlet判别法"><a href="#第二种：Dirichlet判别法" class="headerlink" title="第二种：Dirichlet判别法"></a>第二种：Dirichlet判别法</h3><p><img src="/img/%E8%BF%AA%E5%88%A9%E5%85%8B%E9%9B%B7%E5%88%A4%E5%88%AB.png" alt="Dirichlet判别法"></p><h3 id="第三种：Abel判别法"><a href="#第三种：Abel判别法" class="headerlink" title="第三种：Abel判别法"></a>第三种：Abel判别法</h3><p><img src="/img/%E9%98%BF%E8%B4%9D%E5%B0%94%E5%88%A4%E5%88%AB.png" alt="Abel判别法"></p><h3 id="总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些"><a href="#总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些" class="headerlink" title="总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些"></a>总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些</h3><ul><li>收敛 &lt;-&gt; 一致收敛</li><li>有界 &lt;-&gt; 一致有界</li><li>其实今天仔细一想，对于函数列的问题，好像就应该讨论一致收敛而不是普通的收敛。主要是我觉得吧，普通收敛引入了一个很麻烦的x 😅😅😅</li></ul>]]></content>
    
    
    <categories>
      
      <category>Maths Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic1</title>
    <link href="/2025/02/03/Java-Basic1/"/>
    <url>/2025/02/03/Java-Basic1/</url>
    
    <content type="html"><![CDATA[<h5 id="JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）"><a href="#JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）" class="headerlink" title="JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）"></a>JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）</h5><h4 id="Before-我选择了MIT-6-092-Introduction-To-Programming-In-Java作为Java的入门，目标是快速上手Java"><a href="#Before-我选择了MIT-6-092-Introduction-To-Programming-In-Java作为Java的入门，目标是快速上手Java" class="headerlink" title="Before: 我选择了MIT 6.092: Introduction To Programming In Java作为Java的入门，目标是快速上手Java"></a>Before: 我选择了MIT 6.092: Introduction To Programming In Java作为Java的入门，目标是快速上手Java</h4><h2 id="Java-Basic-1"><a href="#Java-Basic-1" class="headerlink" title="Java Basic 1"></a>Java Basic 1</h2><h3 id="Compiling-Java"><a href="#Compiling-Java" class="headerlink" title="Compiling Java"></a>Compiling Java</h3><p>Source Code(.java) -&gt; javac -&gt; Byte Code -&gt; java</p><h3 id="Java版的Hello-world"><a href="#Java版的Hello-world" class="headerlink" title="Java版的Hello world"></a>Java版的Hello world</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] <span class="hljs-variable language_">arguments</span></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>,<span class="hljs-title function_">printIn</span>(<span class="hljs-string">&quot;Hello world.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Program-Structure"><a href="#Program-Structure" class="headerlink" title="Program Structure"></a>Program Structure</h3><p>class <strong>CLASSNAME</strong>{<br>    public static void main(String[] arguments){<br>        <strong>STATEMENTS</strong><br>    }<br>}</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>System.out.printIn(some String)<br>Example:</p><ul><li>System.output.printIn(“output”);</li><li>Console: output</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>boolean 相当于C&#x2F;C++中的bool<br>int 相当于C&#x2F;C++中的int<br>double 相当于C&#x2F;C++中的double<br>String 相当于C&#x2F;C++中的string<br><strong>注意：Java要求数据类型必须正确匹配</strong><br>如：String five &#x3D; 5; &#x2F;&#x2F; ERROR</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Form:<br>Type Name;</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用 &#x3D;  与C&#x2F;C++相同<br>Example:<br>String foo;<br>foo &#x3D; “IAP 6.092”;<br>double badPi &#x3D; 3.14;</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>与C&#x2F;C++完全一致<br>&#x3D; + - * &#x2F;(整数进行&#x2F;时同样是向下取整)<br><strong>注意： double b &#x3D; 5&#x2F;2; &#x2F;&#x2F; b &#x3D; 2.0</strong><br>优先级：括号 &gt; 乘除法 &gt; 加减法<br>也支持 +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; 等复合运算符</p><h3 id="字符串加法"><a href="#字符串加法" class="headerlink" title="字符串加法"></a>字符串加法</h3><p>String text &#x3D; “hello” + “world”;<br>text &#x3D; text + “number” + 5;<br>&#x2F;&#x2F; text &#x3D; “helloworldnumber5”;</p><h3 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h3><ul><li>强制类型转换 ： int a &#x3D; (int)18.7;</li><li>隐式类型转换 ：double a &#x3D; 2;&#x2F;&#x2F;2.0</li></ul><h3 id="Java的函数——Method"><a href="#Java的函数——Method" class="headerlink" title="Java的函数——Method"></a>Java的函数——Method</h3><p>Example:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NAME</span>()</span>&#123;<br>    STATEMENTS<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：NAME();</p><h4 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">NewLine</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newLine</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">threeLines</span>()</span>&#123;<br>        newLine();<br>        newLine();<br>        newLine();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] arguments</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;Line 1&quot;</span>);<br>        threeLines();<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;Line 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数参数Parameter"><a href="#函数参数Parameter" class="headerlink" title="函数参数Parameter"></a>函数参数Parameter</h4><p>Example:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-keyword">NAME</span>(<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    STATEMENTS</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>调用：<br>NAME(EXPRESSION);<br>Another Example:<br>多个参数</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-keyword">NAME</span>(<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>,<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    STATEMENTS</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Return-Values-返回值"><a href="#Return-Values-返回值" class="headerlink" title="Return Values 返回值"></a>Return Values 返回值</h4><p>Example：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TYPE <span class="hljs-title">NAME</span>()</span>&#123;<br>    STATEMENTS<br>    <span class="hljs-keyword">return</span> EXPRESSION;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IF-ELSE语句"><a href="#IF-ELSE语句" class="headerlink" title="IF ELSE语句"></a>IF ELSE语句</h3><p>Example:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(CONDITION)</span></span>&#123;<br>    STATEMENTS<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(CONDITION)&#123;<br>    STATEMENTS<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    STATEMENTS<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>x &gt; y  x &lt; y  x &gt;&#x3D; y x &lt;&#x3D; y  x&#x3D;&#x3D; y</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;&amp; ||</p>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maths-Analysis1</title>
    <link href="/2025/02/02/Maths-Analysis1/"/>
    <url>/2025/02/02/Maths-Analysis1/</url>
    
    <content type="html"><![CDATA[<h5 id="好消息：JaneZ开始学习数分了！-坏消息：JaneZ的数分要丸辣"><a href="#好消息：JaneZ开始学习数分了！-坏消息：JaneZ的数分要丸辣" class="headerlink" title="好消息：JaneZ开始学习数分了！ 坏消息：JaneZ的数分要丸辣"></a>好消息：JaneZ开始学习数分了！ 坏消息：JaneZ的数分要丸辣</h5><h2 id="Maths-Analysis-1-函数列与一致收敛性"><a href="#Maths-Analysis-1-函数列与一致收敛性" class="headerlink" title="Maths Analysis 1  函数列与一致收敛性"></a>Maths Analysis 1  函数列与一致收敛性</h2><h3 id="首先，给出函数列定义！"><a href="#首先，给出函数列定义！" class="headerlink" title="首先，给出函数列定义！"></a>首先，给出函数列定义！</h3><p><img src="/img/%E5%87%BD%E6%95%B0%E5%88%97%E5%AE%9A%E4%B9%89.png" alt="函数列定义"></p><h4 id="是不是很简单？让我们来看一个例子——经典-x-n"><a href="#是不是很简单？让我们来看一个例子——经典-x-n" class="headerlink" title="是不是很简单？让我们来看一个例子——经典 $x^n$"></a>是不是很简单？让我们来看一个例子——经典 $x^n$</h4><p><img src="/img/%E5%87%BD%E6%95%B0%E5%88%97%E4%BE%8B%E5%AD%90.png" alt="函数列例子"></p><h3 id="接着隆重推出：《一致收敛》"><a href="#接着隆重推出：《一致收敛》" class="headerlink" title="接着隆重推出：《一致收敛》"></a>接着隆重推出：《一致收敛》</h3><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%AE%9A%E4%B9%89.png" alt="一致收敛定义"></p><h4 id="看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白"><a href="#看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白" class="headerlink" title="看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白"></a>看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白</h4><h4 id="哦菜菜鼠鼠似乎明白了些什么"><a href="#哦菜菜鼠鼠似乎明白了些什么" class="headerlink" title="哦菜菜鼠鼠似乎明白了些什么"></a>哦菜菜鼠鼠似乎明白了些什么</h4><h3 id="函数列收敛的-epsilon-N语言中，N与-epsilon-和x的取值皆有关，而一致收敛中的N只和-epsilon-有关-（回忆一下连续与一致连续）"><a href="#函数列收敛的-epsilon-N语言中，N与-epsilon-和x的取值皆有关，而一致收敛中的N只和-epsilon-有关-（回忆一下连续与一致连续）" class="headerlink" title="函数列收敛的$\epsilon$-N语言中，N与$\epsilon$和x的取值皆有关，而一致收敛中的N只和$\epsilon$有关 （回忆一下连续与一致连续）"></a>函数列收敛的$\epsilon$-N语言中，N与$\epsilon$和x的取值皆有关，而一致收敛中的N只和$\epsilon$有关 （回忆一下连续与一致连续）</h3><h4 id="接下来从几何上看看一致收敛"><a href="#接下来从几何上看看一致收敛" class="headerlink" title="接下来从几何上看看一致收敛"></a>接下来从几何上看看一致收敛</h4><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" alt="一致收敛几何意义"></p><h3 id="将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上"><a href="#将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上" class="headerlink" title="将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上"></a>将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上</h3><p><img src="/img/%E6%9F%AF%E8%A5%BF%E6%94%B6%E6%95%9B%E5%87%86%E5%88%99.png" alt="柯西收敛准则"></p><h4 id="证明还是很简单的"><a href="#证明还是很简单的" class="headerlink" title="证明还是很简单的"></a>证明还是很简单的</h4><h3 id="接下来看一个和上确界相关的定理及推论吧"><a href="#接下来看一个和上确界相关的定理及推论吧" class="headerlink" title="接下来看一个和上确界相关的定理及推论吧"></a>接下来看一个和上确界相关的定理及推论吧</h3><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%AE%9A%E7%90%86%E5%8F%8A%E6%8E%A8%E8%AE%BA.png" alt="一致收敛定理及推论"></p><h4 id="And-An-Example"><a href="#And-An-Example" class="headerlink" title="And An Example~"></a>And An Example~</h4><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%AE%9A%E7%90%86%E4%BE%8B%E5%AD%90.png" alt="一致收敛定理例子"></p><h5 id="JaneZ要做回数分皇帝😎😎😎（口嗨中）"><a href="#JaneZ要做回数分皇帝😎😎😎（口嗨中）" class="headerlink" title="JaneZ要做回数分皇帝😎😎😎（口嗨中）"></a>JaneZ要做回数分皇帝😎😎😎（口嗨中）</h5>]]></content>
    
    
    <categories>
      
      <category>Maths Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure2</title>
    <link href="/2025/02/01/Data-Structure2/"/>
    <url>/2025/02/01/Data-Structure2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-JaneZ非常讨厌LinkList，but-厌即是恋（-过年精神状态真是越来越好了，喝点儿中药吧-）"><a href="#Before-JaneZ非常讨厌LinkList，but-厌即是恋（-过年精神状态真是越来越好了，喝点儿中药吧-）" class="headerlink" title="Before: JaneZ非常讨厌LinkList，but: 厌即是恋（ 过年精神状态真是越来越好了，喝点儿中药吧 ）"></a>Before: JaneZ非常讨厌LinkList，but: 厌即是恋（ 过年精神状态真是越来越好了，喝点儿中药吧 ）</h5><h2 id="Data-Structure-2-链表-LinkList"><a href="#Data-Structure-2-链表-LinkList" class="headerlink" title="Data Structure 2 链表 LinkList"></a>Data Structure 2 链表 LinkList</h2><h3 id="线性链表的链接存储"><a href="#线性链表的链接存储" class="headerlink" title="线性链表的链接存储"></a>线性链表的链接存储</h3><ul><li>链接存储通过让每个结点保存与它有关系的结点的地址来保存结点之间的关系</li><li>线性表的链接存储是指将每个数据元素存放在一个独立的数据存储单元（结点）中</li><li>链表不需要事先准备空间，一般采用动态存储的方法</li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ul><li>每个结点存储一个数据元素和一个后继指针<br><img src="/img/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="单链表"></li><li>为防止忘记处理特殊情况，可以引入一个不存放数据的特殊结点——头结点（一种优化）<br><img src="/img/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="带头结点单链表"></li></ul><h4 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sLinkList</span>: <span class="hljs-keyword">public</span> list &lt;elemType&gt;&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>        elemType data;<br>        node *next;<br><br>        <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType&amp; x , node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>            data = x;<br>            next = n;<br>        &#125;<br>        <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>node *head;<br><span class="hljs-type">int</span> currentLength;<br><span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sLinkList</span>();<br>    ~<span class="hljs-built_in">sLinkList</span>()&#123;<br>        <span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">delete</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单链表的运算实现"><a href="#单链表的运算实现" class="headerlink" title="单链表的运算实现"></a>单链表的运算实现</h4><ul><li>私有成员函数move的实现<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">node</span> *<span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">move</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>) <span class="hljs-symbol">const</span>&#123;<br>    node *p = head;<br>    <span class="hljs-keyword">while</span>( i -- &gt;= <span class="hljs-number">0</span>)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表构造函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">sLinkList</span>()</span>&#123;<br>    head = new node;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表清空函数<br><img src="/img/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B8%85%E7%A9%BA.png" alt="单链表清空操作"><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">clear</span>()</span>&#123;<br>    node *p = head-&gt;<span class="hljs-keyword">next</span>;<br>    node *<span class="hljs-keyword">q</span>;<br>    head -&gt; <span class="hljs-keyword">next</span> = nullptr;<br>    <span class="hljs-keyword">while</span>(p != nullptr)&#123;<br>        <span class="hljs-keyword">q</span> = p -&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = <span class="hljs-keyword">q</span>;<br>    &#125;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表插入删除函数<br><img src="/img/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.png" alt="单链表删除操作"><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">insert</span>(<span class="hljs-title">int</span> <span class="hljs-title">i</span> ,<span class="hljs-title">const</span> <span class="hljs-title">elemType</span> &amp;<span class="hljs-title">x</span>)</span>&#123;<br>    node *<span class="hljs-keyword">pos</span>;<br>    <span class="hljs-keyword">pos</span> = move(i - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span> = new node(<span class="hljs-keyword">x</span> ,<span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span>);<br>    ++ currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">remove</span>(<span class="hljs-title">int</span> <span class="hljs-title">i</span>)</span>&#123;<br>    node *<span class="hljs-keyword">pos</span>;<br>    node *delp;<br>    <span class="hljs-keyword">pos</span> = move(i - <span class="hljs-number">1</span>);<br>    delp = <span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span>;<br>    <span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span> = delp -&gt; <span class="hljs-keyword">next</span>;<br>    <span class="hljs-keyword">delete</span> delp;<br>    -- currentLength;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表search visit traverse函数的实现<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">search</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span> &amp;<span class="hljs-symbol">x</span>) <span class="hljs-symbol">const</span>&#123;<br>    node *p = head -&gt; next;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr &amp;&amp; p -&gt; data != x)&#123;<br>        p = p -&gt; next;<br>        ++ i;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">visit</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> move(i) -&gt; data;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">traverse</span>() <span class="hljs-title">const</span></span>&#123;<br>    node *p = head -&gt; <span class="hljs-keyword">next</span>;<br>    <span class="hljs-keyword">while</span>(p != nullptr)&#123;<br>        cout &lt;&lt; p -&gt; data &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p = p -&gt; <span class="hljs-keyword">next</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="JaneZ发烧了，各位注意身体啊"><a href="#JaneZ发烧了，各位注意身体啊" class="headerlink" title="JaneZ发烧了，各位注意身体啊!"></a>JaneZ发烧了，各位注意身体啊!</h5>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure1</title>
    <link href="/2025/01/29/Data-Structure1/"/>
    <url>/2025/01/29/Data-Structure1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS-启动！"><a href="#Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS-启动！" class="headerlink" title="Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS , 启动！"></a>Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS , 启动！</h5><h2 id="Data-Structure-1-线性表List"><a href="#Data-Structure-1-线性表List" class="headerlink" title="Data Structure 1 线性表List"></a>Data Structure 1 线性表List</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><ul><li>线性结构的定义：所有结点按一对一的邻接关系构成的整体就是线性结构</li><li>线性表是处理线性结构的数据结构</li><li>线性表中数据元素的个数称为线性表的长度</li></ul><h4 id="线性表的基本运算："><a href="#线性表的基本运算：" class="headerlink" title="线性表的基本运算："></a>线性表的基本运算：</h4><ul><li>创建空线性表 create</li><li>删除线性表中所有数据元素 clear</li><li>求长度 length</li><li>插入元素 insert</li><li>删除元素 remove</li><li>搜索元素 search</li><li>返回特定位置元素值 visit</li><li>按序访问每一数据元素 traverse</li></ul><h4 id="线性表的抽象类"><a href="#线性表的抽象类" class="headerlink" title="线性表的抽象类"></a>线性表的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span> ; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span> <span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp;x)</span><span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">list</span>()&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="线性表的顺序实现"><a href="#线性表的顺序实现" class="headerlink" title="线性表的顺序实现"></a>线性表的顺序实现</h3><ul><li>将线性表的数据元素存储在一块连续的空间里，用存储位置反映数据元素间的关系<br><img src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="顺序表存储结构"></li></ul><h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><ul><li>从线性表的抽象类list公有派生<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqList</span>: <span class="hljs-keyword">public</span> list &lt;elemType&gt;&#123;<br><br>    <span class="hljs-keyword">private</span>:<br><br>        elemType *data;<br>        <span class="hljs-type">int</span> currentLength;<br>        <span class="hljs-type">int</span> maxSize;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br><br>        <span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);<br>        ~<span class="hljs-built_in">seqList</span>();<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">const</span> elemType&amp; x)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="顺序表实现"><a href="#顺序表实现" class="headerlink" title="顺序表实现"></a>顺序表实现</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">seqList</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">initsize</span>)&#123;<br>    data = new elemType[initsize];<br>    maxsize = initsize;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">seqList</span>&lt;<span class="hljs-title">elemType</span>&gt;::~<span class="hljs-title">seqList</span>()</span>&#123;<br>    <span class="hljs-keyword">delete</span> []data;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">clear</span>()&#123;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br>(是个伪清除)<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">length</span>()&#123;<br>    <span class="hljs-keyword">return</span> currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">search</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span>&amp;<span class="hljs-symbol">x</span>)<span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; currentLength &amp;&amp; data[i] != x; i ++);<br>    <span class="hljs-keyword">if</span>(i == currentLength)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> i; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">visit</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>)<span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> data[i];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">traverse</span>()<span class="hljs-symbol">const</span>&#123;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; currentLength; i ++)&#123;<br>        cout &lt;&lt; data[i]&lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单独讨论插入删除函数"><a href="#单独讨论插入删除函数" class="headerlink" title="单独讨论插入删除函数"></a>单独讨论插入删除函数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">doubleSpace</span>()&#123;<br>    elemType *tmp = data;<br>    maxSize *= <span class="hljs-number">2</span>;<br>    data = new elemType[maxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; currentLength; i ++)&#123;<br>        data[i] = tmp[i];<br>    &#125;<br>    delete []tmp;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">elemType</span>&amp; <span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(currentLength == maxSize)&#123;<br>        <span class="hljs-built_in">double</span>Space();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = currentLength; j &gt; i ; j --)&#123;<br>        data[j] = data[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    data[i] = x;<br>    ++ currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i;j &lt; currentLength - <span class="hljs-number">1</span>; j ++)&#123;<br>        data[j] = data[j + <span class="hljs-number">1</span>];<br>    &#125;<br>    -- currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Before Everything</title>
    <link href="/2025/01/21/Before-Everything/"/>
    <url>/2025/01/21/Before-Everything/</url>
    
    <content type="html"><![CDATA[<h1 id="Before-Everything-前言"><a href="#Before-Everything-前言" class="headerlink" title="Before Everything 前言"></a>Before Everything 前言</h1><p>JaneZ, 2025.1.21,M Stand Coffee, Nanjing<br>Well, hello world ! This is the owner of this crazy blog ! My name is JaneZ , a student from Shanghai Jiaotong University . I major in <strong>Computer Science</strong> of the ACM Class. I ‘m an ENFPer or ENFJer , so I really want to know more people with the same interests.<br><strong>Why I start this blog ?</strong><br>Well , partly motivated by a high school classmate, who majors in <strong>Artificial Intelligence</strong> also in SJTU( thanks for the help). I think it’s mainly because that after a whole semester learning in the ACM class , I didn’t actually adapt to university life that well .<br>So I hope to be more proactive in my learning through this blog.<br>Let’s get back to Chinese. 原谅JaneZ烂烂的英语</p><p>我的博客（个人主页）采取的是hexo的fluid主题，主要分享我在日常学习中记录的笔记、学习心得以及一些漂亮的话。如果各位对于计算机科学、数学、物理学、人工智能等方面感兴趣，都可以常来玩儿，也欢迎与我私下进行交流（联系方式附在<a href="https://janez-uint.github.io/about/">About</a>页面中了）。希望能共同进步！<br>对了，如果有任何关于hexo博客的配置部署问题，都可向我咨询。自己踩过的坑，不希望再有人踩进去了。<br>Any way,let’s get started.<br>我们开始吧<br>Attach a picture of this wonderful coffee shop!<br><img src="/img/MStandCoffee.png" alt="M Stand Coffee"></p><p>Can’t live without coffee … ？<br>Upd: 有人去医院复查不出所料寄了，再见咖啡☕暑假手术室见了😢😢😢</p>]]></content>
    
    
    
    <tags>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/14/hello-world/"/>
    <url>/2025/01/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
