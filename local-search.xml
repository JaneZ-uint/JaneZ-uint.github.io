<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Proof of the Undecidabilty of FO</title>
    <link href="/2025/05/17/Mathematical-Logic11/"/>
    <url>/2025/05/17/Mathematical-Logic11/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA DS MST</title>
    <link href="/2025/05/11/AlgorithmOfDS4/"/>
    <url>/2025/05/11/AlgorithmOfDS4/</url>
    
    <content type="html"><![CDATA[<h1 id="lca-least-common-ancestors"><a class="markdownIt-Anchor" href="#lca-least-common-ancestors"></a> LCA ———— Least Common Ancestors</h1><hr /><h2 id="如何计算"><a class="markdownIt-Anchor" href="#如何计算"></a> 如何计算？</h2><ul><li>深度相同一起跳</li><li>深度不同，深度大的跳</li></ul><p>显然，一层一层跳复杂度将会来到O(N)</p><h2 id="空间换时间-一次多跨几步"><a class="markdownIt-Anchor" href="#空间换时间-一次多跨几步"></a> 空间换时间 一次多跨几步</h2><p>联系：<a href="https://janezair.site/2025/04/05/AlgorithmOfDS2/#sparse-table-st%E8%A1%A8">ST表</a><br />考虑保存<strong>2 的幂次级 祖先</strong></p><p>于是我们有了一种很棒的<strong>倍增</strong>做法：</p><ol><li>假设 y 比 x 深，则 y 需要向上跳 a = h(y) - h(x)</li><li>对 a 进行二进制拆分</li><li>令 f[x][i]为结点 x 的 2^i级祖先，则状态转移方程为：f[x][i] = f[f[x][i-1]][i-1]</li></ol><p>也就是说，我们可以进行一个ST表的预处理：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(int j <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;j &lt;= 20;j ++)&#123;</span><br>    for(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;i &lt;= n;i ++)&#123;</span><br>        f[i][j] <span class="hljs-operator">=</span> f[f[i][j-<span class="hljs-number">1</span>]][j-<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度是O(NlogN)的</p><h2 id="深度相同一起跳"><a class="markdownIt-Anchor" href="#深度相同一起跳"></a> 深度相同一起跳</h2><p>问题在于：深度差未知<br />不能跳过头，但也不想太保守（一点一点往上挪），争取跳出<strong>能跳的 最大的步子</strong></p><p>So:以 2 的幂次从大往小尝试</p><ul><li>每次跳都确保跳到的点不相同</li><li>步长递减到2^0 为止，返回最后点的父亲节点</li></ul><h2 id="lca-代码实现"><a class="markdownIt-Anchor" href="#lca-代码实现"></a> LCA 代码实现</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int lca(int x,int y)&#123;<br>    if(dp<span class="hljs-comment">[x]</span> &lt; dp<span class="hljs-comment">[y]</span>)&#123;<br>        swap(x,y);<br>    &#125;<br>    for(int j = 19;j &gt;= 0;j --)&#123;<br>        if(dp<span class="hljs-comment">[f<span class="hljs-comment">[x]</span><span class="hljs-comment">[i]</span>]</span> &gt;= dp<span class="hljs-comment">[y]</span>)&#123;<br>            x = f<span class="hljs-comment">[x]</span><span class="hljs-comment">[i]</span>;<br>        &#125;<br>    &#125;<br>    if(x == y)&#123;<br>        return x;<br>    &#125;<br>    for(int j = 19;j &gt;= 0;j --)&#123;<br>        if(dp<span class="hljs-comment">[f<span class="hljs-comment">[x]</span><span class="hljs-comment">[j]</span>]</span> != dp<span class="hljs-comment">[f<span class="hljs-comment">[y]</span><span class="hljs-comment">[j]</span>]</span>)&#123;<br>            x = f<span class="hljs-comment">[x]</span><span class="hljs-comment">[j]</span>;<br>            y = f<span class="hljs-comment">[y]</span><span class="hljs-comment">[j]</span>;<br>        &#125;<br>    &#125;<br>    return f<span class="hljs-comment">[x]</span><span class="hljs-comment">[0]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用树上差分"><a class="markdownIt-Anchor" href="#应用树上差分"></a> 应用：树上差分</h2><p>给定一棵树 n 个节点，有 m 次操作，每次操作给出 u，v 两个节点，将 u-v 路径上的所有点权值 +1。之后查询每个点的点权。</p><p>想法：联系<a href="https://janezair.site/2025/04/05/AlgorithmOfDS2/#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%92%8C%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">树状数组区间修改</a></p><p><strong>差分树上节点加 1 ，代表从根节点到该节点的路径上的节点都加 1</strong></p><h2 id="经典例子清理蜘蛛网"><a class="markdownIt-Anchor" href="#经典例子清理蜘蛛网"></a> 经典例子：清理蜘蛛网</h2><p>放个题：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2193">清理蜘蛛网 ACMOJ</a><br />想法一个是图的存储，我一开始试图用树存储，发现整个存储结构一片混乱。无奈最后投向邻接表（注意必须是邻接表而不是邻接矩阵，不然你将无法过编）<br />还有树上差分（边的差分），更新起点终点（++）和lca点（-= 2）<br />以及前缀和的计算，result[u] = diff[u] + sum(children diff[sn])<br />还有体现附加边的作用，<strong>骨架边断开的机会</strong>分类讨论。<br />总结：一道很难想也不太好写的题，主播写了至少1个多小时（还是在有思路的情况下）</p><p>贴个AC代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;cmath&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br>struct edge &#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>&#125;;<br>struct ver &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">value</span>;<br>    edge *head;<br>&#125;;<br>ver g[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> fa[<span class="hljs-number">100005</span>][<span class="hljs-number">21</span>];<br><span class="hljs-type">int</span> diff[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100005</span>];<br><span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;next = g[u].head;<br>    g[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> f,<span class="hljs-type">int</span> h) &#123;<br>    fa[sn][<span class="hljs-number">0</span>] = f;<br>    dp[sn] = h;<br>    edge *e = g[sn].head;<br>    <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(e-&gt;<span class="hljs-keyword">end</span> != f) &#123;<br>            dfs(e-&gt;<span class="hljs-keyword">end</span>,sn,h + <span class="hljs-number">1</span>);<br>        &#125;<br>        e = e-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> lca(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">if</span>(dp[x] &lt; dp[y]) &#123;<br>        swap(x,y);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">19</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(dp[fa[x][j]] &gt;= dp[y]) &#123;<br>            x = fa[x][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x == y) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">19</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(fa[x][j] != fa[y][j]) &#123;<br>            x = fa[x][j];<br>            y = fa[y][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-type">void</span> calculate(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> fa) &#123;<br>    edge *e = g[sn].head;<br>    <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(e-&gt;<span class="hljs-keyword">end</span> != fa) &#123;<br>            calculate(e-&gt;<span class="hljs-keyword">end</span>,sn);<br>            diff[sn] += diff[e-&gt;<span class="hljs-keyword">end</span>];<br>        &#125;<br>        e = e-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> u,v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        g[i].head = nullptr;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        addEdge(u,v);<br>        addEdge(v,u);<br>    &#125;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">20</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>            fa[i][j] = fa[fa[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">int</span> LCA = lca(a,b);<br>        diff[a] ++;<br>        diff[b] ++;<br>        diff[LCA] -= <span class="hljs-number">2</span>;<br>    &#125;<br>    calculate(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    long long <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(diff[i] == <span class="hljs-number">0</span>) &#123;<br>            total += m;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff[i] == <span class="hljs-number">1</span>) &#123;<br>            total ++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; total;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        edge *e = g[i].head;<br>        edge *tmp;<br>        <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>            tmp = e;<br>            e = e-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><hr /><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>并查集是一种用于管理元素所属集合的数据结构。实现为一个<strong>森林</strong>，其中<strong>每棵树表示一个集合</strong>，树中的节点表示对应集合中的元素。</p><h2 id="2种基本操作"><a class="markdownIt-Anchor" href="#2种基本操作"></a> 2种基本操作</h2><h3 id="union-合并"><a class="markdownIt-Anchor" href="#union-合并"></a> Union 合并</h3><p>合并两个元素所属集合（合并对应的树）</p><h3 id="find-查询"><a class="markdownIt-Anchor" href="#find-查询"></a> Find 查询</h3><p>用于判断 2 个元素是否属于一个集合</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p><strong>父亲存储法</strong>：只需要一个数组 f 存储每个节点的父亲即可。</p><p><strong>查询</strong>：只要沿着树找到a, b所在树的根节点fa, fb，若fa, fb相等则两个节点在同一个集合中</p><p><strong>合并</strong>：先沿着树找到a, b所在树的根节点fa, fb，再令f[fa] = fb, 将两树合并</p><h2 id="并查集优化"><a class="markdownIt-Anchor" href="#并查集优化"></a> 并查集优化</h2><h3 id="降低树高"><a class="markdownIt-Anchor" href="#降低树高"></a> 降低树高</h3><h3 id="查询中的路径压缩"><a class="markdownIt-Anchor" href="#查询中的路径压缩"></a> 查询中的路径压缩</h3><p>查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。<br /><strong>在从x到根结点的路径上的每一个结点都将自己的父结点改为根结点。</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gml">int find(<span class="hljs-variable language_">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(parent[<span class="hljs-variable language_">x</span>] != <span class="hljs-variable language_">x</span>)&#123;<br>        parent[<span class="hljs-variable language_">x</span>] = find(parent[<span class="hljs-variable language_">x</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[<span class="hljs-variable language_">x</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启发式合并"><a class="markdownIt-Anchor" href="#启发式合并"></a> 启发式合并</h3><p>我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> unite(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)&#123;<br>    <span class="hljs-keyword">int</span> rootX = <span class="hljs-keyword">find</span>(x);<br>    <span class="hljs-keyword">int</span> rootY = <span class="hljs-keyword">find</span>(y);<br><br>    <span class="hljs-keyword">if</span>(rootX == rootY)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">size</span>[rootX] &lt; <span class="hljs-keyword">size</span>[rootY])&#123;<br>        parent[rootX] = rootY;<br>        <span class="hljs-keyword">size</span>[rootY] += <span class="hljs-keyword">size</span>[rootX];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        parent[rootY] = rootX;<br>        <span class="hljs-keyword">size</span>[rootX] += <span class="hljs-keyword">size</span>[rootY];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="生成树"><a class="markdownIt-Anchor" href="#生成树"></a> 生成树</h1><p>连通图 G 的生成树（Spanning Tree）是包含G的所有节点的树。</p><p>在有权图中，**最小生成树（MST）**是指总权值最小的一棵生成树。</p><p><strong>切割性质</strong>：假设将图中的顶点划分为两个互不相交的集合，那么连接这两个集合的所有边中，权重最小的边一定属于某棵最小生成树。</p><h2 id="kruskal-算法求解mst-较为常用"><a class="markdownIt-Anchor" href="#kruskal-算法求解mst-较为常用"></a> Kruskal 算法——求解MST  （较为常用）</h2><p>Core:<strong>对边排序，每次取出权值最小的边尝试加入，如果不成环则加入，直到全图连通。</strong></p><h2 id="prim-算法求解mst"><a class="markdownIt-Anchor" href="#prim-算法求解mst"></a> Prim 算法——求解MST</h2><p><strong>从任意一个点开始，选距离集合最近的节点加入集合，直到全图连通</strong></p><h1 id="综合dsmst和lca"><a class="markdownIt-Anchor" href="#综合dsmst和lca"></a> 综合DS,MST和LCA</h1><p>老规矩先贴题：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1898">货车运输</a><br />此题lz开始的想法是Floyd暴力dp，显然会炸。后来打算暴搜，显然也会炸。无奈只得点开luogu题解，发现是蓝题🤡<br />个人觉得最妙的是想到使用最大生成树，把较小的边删掉，在得到的最大生成树上（Kruskal得树，邻接表dfs建树）进行LCA操作，得到LCA后相当于求解出了唯一的一条路径，在遍历这条路径求个最小值就好了<br />另外lz总觉得最后的遍历有点儿暴力，感觉可以多维护一些东西，让查询复杂度来到O(1)？没仔细想，以为会T，结果居然1Y飘过了🤣<br />贴个代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> parent[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> Size[<span class="hljs-number">10005</span>];<br>struct edge &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br><span class="hljs-type">void</span> merge(const edge *aBegin, const edge *aEnd, const edge *bBegin,<br>           const edge *bEnd, edge *c) &#123;<br>    <span class="hljs-keyword">while</span> (aBegin != aEnd &amp;&amp; bBegin != bEnd) &#123;<br>        <span class="hljs-keyword">if</span> (bBegin-&gt;weight &gt; aBegin-&gt;weight) &#123;<br>            *c = *bBegin;<br>            ++bBegin;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            *c = *aBegin;<br>            ++aBegin;<br>        &#125;<br>        ++c;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; aBegin != aEnd; ++aBegin, ++c) *c = *aBegin;<br>    <span class="hljs-keyword">for</span> (; bBegin != bEnd; ++bBegin, ++c) *c = *bBegin;<br>&#125;<br><span class="hljs-type">void</span> merge_sort(edge *a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>    <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>    merge_sort(a, l, mid), merge_sort(a, mid, r);<br>    edge* tmp = <span class="hljs-built_in">new</span> edge[r - l + <span class="hljs-number">1</span>];<br>    merge(a + l, a + mid, a + mid, a + r, tmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; r; ++i) a[i] = tmp[i - l];<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br><span class="hljs-type">int</span> find(<span class="hljs-type">int</span> u) &#123;<br>    <span class="hljs-keyword">if</span>(parent[u] != u) &#123;<br>        parent[u] = find(parent[u]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[u];<br>&#125;<br><span class="hljs-type">void</span> unite(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-type">int</span> rootX = find(x);<br>    <span class="hljs-type">int</span> rootY = find(y);<br>    <span class="hljs-keyword">if</span>(rootX != rootY) &#123;<br>        <span class="hljs-keyword">if</span>(Size[rootX] &gt; Size[rootY]) &#123;<br>            parent[rootY] = rootX;<br>            Size[rootX] += Size[rootY];<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            parent[rootX] = rootY;<br>            Size[rootY] += Size[rootX];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> u,v,w;<br>edge Graph[<span class="hljs-number">50005</span>];<br>edge MST[<span class="hljs-number">10005</span>];<br>struct adjEdge &#123;<br>    adjEdge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct adjVer &#123;<br>    adjEdge *head;<br>&#125;;<br>adjVer adjMST[<span class="hljs-number">10005</span>];//最大生成树邻接表<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w) &#123;<br>    adjEdge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> adjEdge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = w;<br>    <span class="hljs-keyword">current</span>-&gt;next = adjMST[u].head;<br>    adjMST[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> fa[<span class="hljs-number">10005</span>][<span class="hljs-number">21</span>];<br><span class="hljs-type">int</span> depth[<span class="hljs-number">10005</span>];<br><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> f,<span class="hljs-type">int</span> h) &#123;<br>    fa[sn][<span class="hljs-number">0</span>] = f;<br>    depth[sn] = h;<br>    adjEdge *<span class="hljs-keyword">current</span> = adjMST[sn].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span> != f) &#123;<br>            dfs(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>,sn,h + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> lca(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-keyword">if</span>(depth[u] &lt; depth[v]) &#123;<br>        swap(u,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">20</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(depth[fa[u][j]] &gt;= depth[v]) &#123;<br>            u = fa[u][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(u == v) &#123;<br>        <span class="hljs-keyword">return</span> u;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">20</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(fa[u][j] != fa[v][j]) &#123;<br>            u = fa[u][j];<br>            v = fa[v][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-type">int</span> findVal(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    adjEdge *<span class="hljs-keyword">current</span> = adjMST[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;end == v) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span>-&gt;weight;<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> getMin(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> lca) &#123;<br>    <span class="hljs-type">int</span> Min = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span>(u != lca) &#123;<br>        <span class="hljs-type">int</span> v = findVal(u,fa[u][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span>(v &lt; Min) &#123;<br>            Min = v;<br>        &#125;<br>        u = fa[u][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> Min;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        parent[i] = i;<br>        Size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        Graph[i].start = u;<br>        Graph[i].end = v;<br>        Graph[i].weight = w;<br>    &#125;<br>    merge_sort(Graph,<span class="hljs-number">1</span>,m + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        <span class="hljs-type">int</span> rst = find(Graph[i].<span class="hljs-keyword">start</span>);<br>        <span class="hljs-type">int</span> rnd = find(Graph[i].<span class="hljs-keyword">end</span>);<br>        <span class="hljs-keyword">if</span>(rst != rnd) &#123;<br>            unite(rst,rnd);<br>            MST[++cnt] = Graph[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= cnt;i ++) &#123;<br>        add_edge(MST[i].<span class="hljs-keyword">start</span>,MST[i].<span class="hljs-keyword">end</span>,MST[i].weight);<br>        add_edge(MST[i].<span class="hljs-keyword">end</span>,MST[i].<span class="hljs-keyword">start</span>,MST[i].weight);<br>    &#125;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">20</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>            fa[i][j] = fa[fa[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    cin &gt;&gt; q;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= q;i ++) &#123;<br>        cin &gt;&gt; <span class="hljs-keyword">start</span> &gt;&gt; <span class="hljs-keyword">end</span>;<br>        <span class="hljs-keyword">if</span>(find(<span class="hljs-keyword">start</span>) != find(<span class="hljs-keyword">end</span>)) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> LCA = lca(<span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>);<br>            cout &lt;&lt; min(getMin(<span class="hljs-keyword">start</span>,LCA),getMin(<span class="hljs-keyword">end</span>,LCA)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>LCA</tag>
      
      <tag>Disjoint Set</tag>
      
      <tag>MST</tag>
      
      <tag>Kruskal</tag>
      
      <tag>Prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic 10 Halting Problem</title>
    <link href="/2025/05/11/Mathematical-Logic10/"/>
    <url>/2025/05/11/Mathematical-Logic10/</url>
    
    <content type="html"><![CDATA[<h1>Mathematical Logic 10 Halting Problem</h1><hr><h2 id="R-computable">R-computable</h2><p>Let F: A* -&gt; B* (A,B are 2 alphabets)</p><p>(1)A program P computes F if for all w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A*, P: w-&gt;F(w)</p><p>(2)F is R-computable if there is a program which computes F.</p><hr><h2 id="Halting-Problem-for-the-register-machine">Halting Problem for the register machine</h2><hr><h2 id="Godel-numbering">Gödel numbering</h2><p>Def:<br>B:= A U {A,B,…,Z} U {0,1,…,9} U {=,+,-,|}.<br>Words in B* are ordered lexicographically(字典序).</p><p><strong>Encode</strong> each program as a word in B*<br>Example:<br>0LETR1 = R1 - a0|1PRINT|2HALT.</p><p>Assume that this word is the n-th word in the lexicographical ordering of B∗.Then we set:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">w_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">p</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0a_0...a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>(n times)</p><p>Π := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A }.</p><p>The mapping P-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is called <strong>Gödel numbering</strong>.<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is called the <strong>Gödel number</strong> of P.</p><p><strong>Π is R-decidable.</strong></p><h2 id="Π’halt-is-not-R-decidable">Π’halt is not R-decidable.</h2><p>Π’halt := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A and P:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>-&gt;halt}<br>PF:<br>Assume that P0 decides Π’halt<br>0 …<br>1 …<br>…<br>10 PRINT<br>…<br>k HALT</p><p>We can build a P1<br>0 …<br>1 …<br>…<br>10 IF R = □ THEN k ELSE k or k or k… or k<br>…<br>k IF R = □ THEN k ELSE k+1 or k+1 or k+1… or k+1<br>k+1 HALT</p><p>Clearly contradict!</p><h2 id="Πhalt-is-not-R-decidable">Πhalt is not R-decidable.</h2><p>Πhalt := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A and P: □ -&gt;halt}</p><p>PF:<br>Build P+:<br>P : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> -&gt; halt  -&gt; P+ : □ -&gt; halt</p><p>A further program T:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> -&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>P</mi><mo>+</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{P+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p>With P0 and T we design a program which <strong>decides Π’halt</strong>. On any w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A∗:</p><ul><li>the program first test whether w = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> for some P.If not, it rejects immediately.</li><li>Otherwise, it uses T to computes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>P</mi><mo>+</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{P+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>. Then the program calls P0 on input wP+.</li><li>It correctly decides whether P : wP -&gt; halt.</li></ul><hr><h2 id="The-undecidability-of-first-order-logic-see-u-next-time">The undecidability of first-order logic.(see u next time)</h2>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.006 Shortest Path Algorithm</title>
    <link href="/2025/05/09/Introduction-to-Algorithms4/"/>
    <url>/2025/05/09/Introduction-to-Algorithms4/</url>
    
    <content type="html"><![CDATA[<h1>MIT 6.006 4 Shortest Path Algorithm</h1><h2 id="Overview">Overview</h2><ul><li>Weighted Graph</li><li>General Approaches</li><li>Negative Edges</li><li>Optimal Substructure</li></ul><p>Mainly <strong>2 Algorithms</strong>：<br><strong>Dijkstra</strong> with O(V + E) for <strong>non-negative edge weights</strong><br><strong>Bellman Ford</strong> with O(EV) for <strong>general case</strong></p><h2 id="Weighted-Graph">Weighted Graph</h2><h3 id="Single-Source-Shortest-Paths">Single Source Shortest Paths</h3><p>Data Structure:<br>d[v] = value inside circles<br>= 0 (if v = s) or ∞ (otherwise)<br>= δ(s,v) (at the end)<br>with δ(s,v) &lt;= d[v] (all the times)</p><p>π[v] = predecessor on the best path to v</p><p><img src="/img/WGSP.png" alt="Example"></p><h2 id="Negative-Weight-Edges">Negative-Weight Edges</h2><p>You may get an endless loop like below:<br><img src="/img/NWG.png" alt="Example"></p><p>That’s a bad negative circle.</p><h2 id="General-Structure-Of-SP-Algorithm">General Structure Of SP Algorithm</h2><p><img src="/img/GCSP.png" alt="General Idea"></p><h2 id="Triangle-Inequality">Triangle Inequality</h2><p>Thm:<br>For all u,v,x <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> X, we have</p><p>δ(u,v) &lt;= δ(u,x) + δ(x,v)</p><p>You may use this idea in Floyd Algorithm.</p><h2 id="DAG-（Directed-Acyclic-Graph-有向无环图）">DAG （Directed Acyclic Graph 有向无环图）</h2><p>No cycles！</p><p>1.Topologically sort the DAG.<br>2.One pass over vertices in topologically sorted order relaxing each edge that<br>leaves each vertex.</p><p><img src="/img/DAG.png" alt="DAG Example"></p><p>using <strong>Dynamic Programming</strong> O(V + E)</p><h2 id="Dijkstra-Algorithm">Dijkstra Algorithm</h2><p><img src="/img/Dijkstra.png" alt="Dijkstra"></p><p>Core Idea:<br><strong>For each edge (u, v) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> E, assume w(u, v) ≥ 0, maintain a set S of vertices whose final shortest path weights have been determined. Repeatedly select u <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> V − S with minimum shortest path estimate, add u to S, relax all edges out of u.</strong></p><h3 id="Pseudo-code">Pseudo-code</h3><p><img src="/img/DijkstraCode.png" alt="Dijkstra Code"></p><h2 id="Dijkstra-Complexity-Analysis">Dijkstra Complexity Analysis</h2><p>V times : insert into pq<br>V times : extract min<br>E times : decrease key</p><h3 id="Array">Array</h3><p>V times : extract min<br>1 time  : decrease key</p><p>Total: O(V^2 + E)</p><h3 id="Binary-Min-Heap">Binary Min Heap</h3><p>lgV times: extract min<br>lgV times: decrease key</p><p>Total: O(VlgV + ElgV)</p><h3 id="Fibonacci-heap">Fibonacci heap</h3><p>lgV times: extract min<br>1 time  : decrease key</p><p>Total: O(VlogV + E)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Shortest Path</tag>
      
      <tag>Bellman Ford</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic9</title>
    <link href="/2025/05/06/Mathematical-Logic9/"/>
    <url>/2025/05/06/Mathematical-Logic9/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：终于和计算机相关了😭😭😭😭😭他真的，我哭死。好玩！但怀疑作业依然不会做。。。">Before：终于和计算机相关了😭😭😭😭😭他真的，我哭死。好玩！但怀疑作业依然不会做。。。</h4><h1>Mathematical Logic 9 Decidability and Enumerability</h1><h1>可判定性 和 可枚举性</h1><h2 id="Desicion-problems-判定问题">Desicion problems 判定问题</h2><p>判断给定输入是否满足特定性质</p><p>i.e<br>设 A* 是有限字母表上的字符串集合<br>input : w<br>满足某种性质 : w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*</p><p>判定问题的特征函数定义为：<br>f = 1 （w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W）<br>f = 0 （otherwise）</p><h2 id="Decidability-可判定性">Decidability 可判定性</h2><p>Def:<br>P 是对于性质W的<strong>一个判定程序（decision procedure for W）</strong>，如果：<br>对于每个输入w，P终会停机，且输出一些w’使得：</p><ul><li>如果 w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W，则w’ 为空串</li><li>否则，w’不为空串</li></ul><p>我们称 W 是可判定的，如果存在这样的一个P</p><h2 id="Enumerability-可枚举性">Enumerability 可枚举性</h2><p>Def:<br>设A 是一个字母表，且 W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*.我们称P 是 W 的一个枚举程序，如果：<br>（在没有任何输入的情况下）P输出了W 中的所有单词（以某种顺序且可能重复）</p><p>我们称 W 是可枚举的，如果存在这样的一个P</p><h2 id="Lemma-about-Enumerability">Lemma about Enumerability</h2><h3 id="Lemma-9">Lemma 9</h3><p>如果W存在这样的一个枚举程序，那么 W 就一定存在一个没有重复的枚举程序</p><h3 id="Lemma-10">Lemma 10</h3><p>如果A 是有限的，那么A* 是可枚举的。</p><h2 id="Decidability-VS-Enumerability">Decidability VS Enumerability</h2><h3 id="Thm-11">Thm 11</h3><p>所有可判定的集合都是可枚举的。</p><h3 id="Thm-12">Thm 12</h3><p>设W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*. W 是可判定的当且仅当 W 和 A*\ W 是可枚举的。</p><h2 id="Q4：Can-computers-find-proofs？">Q4：Can computers find proofs？</h2><p><img src="/img/Turing.png" alt="Alan Turing"></p><p><strong>Undecidability of FO</strong></p><p><strong>any computer program cannot decide whether an arbitrary input mathematical statement has a proof</strong></p><h2 id="Register-Machine">Register Machine</h2><p>基本模型：<br>有限个寄存器R0,…,Rm,每个都可以存储字母表A 上的字符串。</p><p>一个程序由有限条指令组成，每一条都被标记为L <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> N</p><h2 id="Instruction-Type">Instruction Type</h2><ul><li><p>L LET R_i = R_i + a_j<br>It is to add aj at the end of the word in Ri.</p></li><li><p>L LET R_i = R_i - a_j<br>If the word w in Ri ends with aj, then delete this aj; otherwise leave w unchanged.</p></li><li><p>L if Ri = - then L′ else L0 or L1 or · · · or Lr<br>It is to jump to a new location according to the ending letter of the word in Ri.</p></li><li><p>L PRINT<br>It is to output the word in R0.</p></li><li><p>L HALT<br>It is to halt the program.</p></li></ul><h2 id="Register-Program">Register Program</h2><p>A program P starts with w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A* if in the beginning of the execution of P we have R0 = w and all other Ri are empty.</p><h2 id="R-Decidability">R-Decidability</h2><p>W is <strong>register-decidable, or R-decidable</strong> for short, if there is a register program which decides W.</p><h2 id="R-Enumerability">R-Enumerability</h2><p>W is <strong>register-enumerable, or R-enumerable</strong> for short, if there is a register program which enumerates W.</p><h2 id="Proposition-15">Proposition 15</h2><p>设W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*. W 是R-decidable 当且仅当 W 和 A*\ W 是R-enumerable的。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 12 MST Dijkstra</title>
    <link href="/2025/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412/"/>
    <url>/2025/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：这恐怕是数据结构系列的最后一期了，这周四是最后一节翁阿姨的课，也是结束了。写此篇的时候正在回上海的高铁上（候补上的标杆车G597），听歌ing。感觉高铁上特别适合写博客（因为其他啥都做不了🫠）明天一天要速通数理逻辑，哎。。。会赢吗？会的会的。">Before：这恐怕是数据结构系列的最后一期了，这周四是最后一节翁阿姨的课，也是结束了。写此篇的时候正在回上海的高铁上（候补上的标杆车G597），听歌ing。感觉高铁上特别适合写博客（因为其他啥都做不了🫠）明天一天要速通数理逻辑，哎。。。会赢吗？会的会的。</h4><h1>数据结构 12 最小生成树</h1><h2 id="Review">Review</h2><p><strong>生成树是连通图的极小连通子图</strong>。包含图的所有 n 个结点，但只含图的 n-1 条边。在生成树中添加一条边之后，必定会形成回路或环。</p><p><strong>最小生成树</strong>：加权无向图的所有生成树中边的权值（代价）之和最小的生成树。</p><h2 id="Kruskal-算法">Kruskal 算法</h2><h3 id="基本思想-贪心">基本思想  贪心</h3><ul><li><p>初始时，设置生成树为（V，Φ），如果V有n个顶点，则初始的生成树为具有n个连通分量的树。</p></li><li><p>按权值的大小逐个考虑所有的边，如果该边的加入能连接两个连通分量，则加入。当生成树只有一个连通分量时，算法结束。</p></li><li><p>用一个优先级队列来选择代价最小的边。</p></li><li><p>用并查集来判断加入一条边后会不会形成回路：将一个连通分量表示为并查集中的一个子集；检查一条边加入后会不会形成回路可以通过对边的两个端点分别执行Find操作。如果两个Find的结果相同，则表示两个端点已连通，加入这条边会形成回路，否则将这条边加入生成树；添加边的操作就是一个Union操作，将两个端点所属的子集归并起来，表示其中的所有顶点都已连通。</p></li></ul><h3 id="实现">实现</h3><p>优先级队列中元素类型</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> beg,end;<br>    TypeOfEdge w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> edge &amp;rp) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w &lt; rp.w;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Kruskal算法实现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer,TypeOfEdge&gt;::<span class="hljs-built_in">kruskal</span>() <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-type">int</span> edgesAccepted = <span class="hljs-number">0</span>,u,v;<br>    edgeNode *p;<br>    edge e;<br>    <span class="hljs-function">DisjointSet <span class="hljs-title">ds</span><span class="hljs-params">(Vers)</span></span>; <span class="hljs-comment">//创建并查集</span><br>    priority_queue&lt;edge&gt; pq;<br><br>    <span class="hljs-comment">//生成优先级队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        p = verList[i].head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(i &lt; p-&gt;end)&#123;  <span class="hljs-comment">//保证每条边只被加入一次</span><br>                e.beg = i;<br>                e.end = p-&gt;end;<br>                e.w = p-&gt;weight;<br>                pq.<span class="hljs-built_in">enQueue</span>(e);<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(edgesAccepted &lt; Vers - <span class="hljs-number">1</span>)&#123;<br>        e = pq.<span class="hljs-built_in">deQueue</span>();<br>        u = ds.<span class="hljs-built_in">find</span>(e.beg);<br>        v = ds.<span class="hljs-built_in">find</span>(e.end);<br><br>        <span class="hljs-keyword">if</span>(u != v)&#123;<br>            edgesAccepted ++;<br>            ds.<span class="hljs-built_in">Union</span>(u,v);<br>            cout &lt;&lt; verList[e.beg].ver &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; verList[e.end].ver &lt;&lt; endl; <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><p>pq:时间复杂度为O(ElogE)<br>ds:最坏时间复杂度为O(ElogV)</p><p>一般来说V &lt; E，故时间复杂度为O(ElogE)</p><h2 id="Prim算法">Prim算法</h2><p>从顶点的角度出发。初始时，顶点集U为空，然后逐个加入顶点，直到包含所有顶点。<br>维护一个从V-U中的每个结点到U中结点的最短边集，记为S。</p><p>过程如下：</p><ul><li>首先选择一个顶点，加入顶点集</li><li>重复下列工作，直到U = V</li><li>从S中选择代价最小的边（u，v）</li><li>把（u，v）加入生成树的边集，v加入到U</li><li>更新S</li></ul><h3 id="存储结构">存储结构</h3><p>U集合的存储<br>一个布尔型一维数组flag，结点i在U中，flag[i]=true</p><p><strong>V-U中结点到U中结点的权值最小的边</strong><br>用两个一维数组lowCost和startNode<br>lowCost[i]表示结点 i 到 U 中的结点的所有边的最小权值<br>startNode[i]表示结点 i 到 U 中的最小边的终点</p><h3 id="具体实现">具体实现</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> TypeOfVer,<span class="hljs-keyword">class</span> TypeOfEdge&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer,TypeOfEdge&gt;::prim(TypeOfEdge noEdge)const&#123;<br>    <span class="hljs-type">bool</span> *flag = <span class="hljs-built_in">new</span> <span class="hljs-type">bool</span>[Vers];<br>    TypeOfEdge *lowCost = <span class="hljs-built_in">new</span> TypeOfEdge[Vers];<br>    <span class="hljs-type">int</span> *startNode = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[Vers];<br>    edgeNode *p;<br>    TypeOfEdge min;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>,i,j;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        flag[i] = <span class="hljs-keyword">false</span>;<br>        lowCost[i] = noEdge;<br>    &#125;<br><br>    start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; Vers;i ++)&#123;<br>        p = verList[<span class="hljs-keyword">start</span>].head;<br>        <span class="hljs-keyword">while</span>(p != nullptr)&#123;<br>            <span class="hljs-keyword">if</span>(!flag[p-&gt;<span class="hljs-keyword">end</span>] &amp;&amp; lowcost[p-&gt;<span class="hljs-keyword">end</span>] &gt; p-&gt;weight)&#123;<br>                lowcost[p-&gt;<span class="hljs-keyword">end</span>] = p-&gt;weight;<br>                startNode[p-&gt;<span class="hljs-keyword">end</span>] = <span class="hljs-keyword">start</span>;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        flag[<span class="hljs-keyword">start</span>] = <span class="hljs-keyword">true</span>;<br>        min = noEdge;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; Vers;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(lowCost[j] &lt; min &amp;&amp; !flag[j])&#123;<br>                min = lowCost[j];<br>                start = j;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; verList[startNode[<span class="hljs-keyword">start</span>]].ver &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; verList[<span class="hljs-keyword">start</span>].ver &lt;&lt; &quot;)\t&quot;;<br>        lowCost[<span class="hljs-keyword">start</span>] = noEdge;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> []flag;<br>    <span class="hljs-keyword">delete</span> []startNode;<br>    <span class="hljs-keyword">delete</span> []lowCost;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(V^2)</p><h2 id="单源最短路径问题">单源最短路径问题</h2><p>问题是什么？<br><strong>给出一个加权图和图上的一个节点s，找出s到图中每一节点的最短路径</strong></p><h2 id="非加权图的最短路径问题-Naive">非加权图的最短路径问题 Naive</h2><p>采用广度优先搜索，它按层处理一层的所有结点：离起始结点最近的结点最先处理，距离最远的最晚处理。<br>复杂度O(V + E)</p><h2 id="加权图最短路径问题-Dijkstra算法">加权图最短路径问题 Dijkstra算法</h2><h3 id="存储设计">存储设计</h3><ul><li>数组distance<br>记录从源点到达每个结点的最短距离</li><li>数组prev<br>记录要到达此结点，必须到达的前一结点。</li><li>顶点集known<br>已经找到了最短路径的顶点</li></ul><h3 id="过程">过程</h3><ul><li>开始时，顶点集合known只包含源点一个顶点。</li><li>反复执行以下循环，直至所有的顶点都在known中：<br>考察新加入顶点集known的结点的所有边，如果另一端点在V – known中，则检查这条路径是否比原来已知的路径要短。如果是，则更新源点到此结点的距离和路径。</li><li>从V – known中寻找一个路径最短的结点，从源点到这个结点已经不可能有更好的路径了，把它加入顶点集known。</li></ul><h3 id="See-u-in-MIT-6-006-Bye">See u in MIT 6.006 Bye!</h3><h2 id="I-just-write-these-words-I-said-goodbye-long-time-ago-but…-did-I-really-goodbye-I-think-so-Now">I just write these words.I said goodbye long time ago,but…,did I really goodbye?I think so.Now.</h2><p>Je me sens toujours trop parfait·e dans certains domaines, et tellement maladroit·e dans d’autres. Je n’ai plus envie de dire grand-chose, je trouve juste que j’étais bien naïf·ve autrefois.Ah… quelle journée intensément compliquée. J’ai fait quelque chose que je n’avais jamais eu le courage de faire, et le retour que j’en ai eu m’a plongé·e dans un profond désespoir.Pour toi, je ne suis même pas un choix temporaire, juste un·e passant·e dans ta jeunesse.Pourquoi tous ces souvenirs, goutte à goutte, finissent-ils par être oubliés ?Je n’aime pas ce chanteur, pas du tout — il me fait trop penser à toi.Aujourd’hui, il pleut à torrents à Shanghai, mais qui n’a pas aussi la tempête dans le cœur ?Parmi la foule, tu es toujours celui qui brille le plus, mais tu ne m’appartiendras jamais, tu ne pourras jamais m’appartenir.Tu es exactement comme je t’avais imaginé. Tu es vraiment une bonne personne.Mais moi… je ne t’aimerai plus jamais.<br>JaneZ 2025.5.8</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>MST</tag>
      
      <tag>Kruskal</tag>
      
      <tag>Prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 11 Graph Traversal</title>
    <link href="/2025/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411/"/>
    <url>/2025/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：好笑的是，这篇（还有上一篇）似乎上个星期就部署了，现在才开始写，事情也真的是太多了，一度以为上周要死去了😣Obviously，人还活着。期中没有溢出有一点遗憾，但也算满意了。and…放假了！！！第一天陪爸妈在上海玩儿，下午回南京，2号去演唱会，3号一个人去杭州（感觉年龄越大，越喜欢一个人旅行。以前总觉得和朋友家人一起才有意思，上大学后更喜欢一个人待着），4号5号就写写作业吧（主播不要忘了主播的Toy-12306和logic）😢😢😢已经11周了，期末周快来了（那很坏了）">Before：好笑的是，这篇（还有上一篇）似乎上个星期就部署了，现在才开始写，事情也真的是太多了，一度以为上周要死去了😣Obviously，人还活着。期中没有溢出有一点遗憾，但也算满意了。and…放假了！！！第一天陪爸妈在上海玩儿，下午回南京，2号去演唱会，3号一个人去杭州（感觉年龄越大，越喜欢一个人旅行。以前总觉得和朋友家人一起才有意思，上大学后更喜欢一个人待着），4号5号就写写作业吧（主播不要忘了主播的Toy-12306和logic）😢😢😢已经11周了，期末周快来了（那很坏了）</h4><h1>数据结构 11 Graph Traversal</h1><h2 id="Definition">Definition</h2><p>按照某种次序系统地访问图中的所有顶点，并且使得每个顶点只能被访问一次。</p><h2 id="深度优先搜索">深度优先搜索</h2><ul><li>选中第一个被访问的顶点，并访问</li><li>依次从顶点的未被访问过的第一个、第二个、第三个…… 邻接顶点出发，进行深度优先搜索</li><li>如果还有顶点未被访问，则选中一个起始顶点，重新开始上述过程</li><li>所有的顶点都被访问，则结束</li></ul><p>邻接表中公有dfs函数的实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">dfs</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-built_in">bool</span> *visited = new <span class="hljs-built_in">bool</span>[Vers];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        visited[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(visited[i])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        dfs(i,visited);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>邻接表中私有dfs函数的实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">dfs</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">start,<span class="hljs-symbol">bool</span></span> <span class="hljs-symbol">visited</span>[])<span class="hljs-symbol">const</span>&#123;<br>    edgeNode *p = verList[start].head;<br>    visited[start] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[p-&gt;end])&#123;<br>            dfs(p-&gt;end,visited);<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先搜索">广度优先搜索</h2><p>类似于树的层次遍历</p><p>过程：</p><ul><li>选中第一个被访问的顶点；</li><li>对顶点作已访问过的标志；</li><li>依次访问已访问顶点的未被访问过的第一个、第二个、第三个……第 m 个邻接顶点</li><li>如果还有顶点未被访问，则选中一个起始顶点，重复上述过程</li><li>所有的顶点都被访问到，则结束。</li></ul><p>需要一个队列记录哪些结点可以被访问。每次访问一个节点后，将它的后继入队。</p><p>邻接表中bfs的实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">bfs</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-built_in">bool</span> *visited = new <span class="hljs-built_in">bool</span>[Vers];<br>    <span class="hljs-built_in">int</span> currentNode;<br>    linkQueue&lt;<span class="hljs-built_in">int</span>&gt; q;<br>    edgeNode *p;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        visited[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;        <br>        q.enQueue(i);<br>        <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>            currentNode = q.deQueue();<br>            <span class="hljs-keyword">if</span>(visited[currentNode] == <span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            cout &lt;&lt; verList[currentNode].ver &lt;&lt; endl;<br>            visited[currentNode] = <span class="hljs-literal">true</span>;<br>            p = verList[currentNode].head;<br>            <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr)&#123;<br>                <span class="hljs-keyword">if</span>(visited[p-&gt;end] != <span class="hljs-literal">true</span>)&#123;<br>                    q.enQueue(p-&gt;end);<br>                &#125;<br>                p = p-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无向图的连通性">无向图的连通性</h2><p>在从任一个结点出发的bfs或dfs结束后，检查其他节点是不是都已被访问</p><h2 id="欧拉回路">欧拉回路</h2><h3 id="哥尼斯堡七桥问题">哥尼斯堡七桥问题</h3><p>如图：<br><img src="/img/%E4%B8%83%E6%A1%A5.png" alt="七桥问题"></p><p>能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径？</p><p>抽象一下：<br><img src="/img/%E4%B8%83%E6%A1%A5%E6%8A%BD%E8%B1%A1.png" alt="七桥问题抽象"></p><p>如果有奇数桥的地方不止两个，满足要求的路径是找不到的。如果只有两个地方有奇数桥，可以从这两个地方之一出发，经过所有的桥一次，再回到另一个地方。如果都是偶数桥，从任意地方出发都能回到原点。</p><p>欧拉的结论：</p><ul><li>如果有奇数桥的地方不止两个，满足要求的路径是找不到的。</li><li>如果只有两个地方有奇数桥，可以从这两个地方之一出发，经过所有的桥一次，再回到另一个地方。</li><li>如果都是偶数桥，从任意地方出发都能回到原点。</li></ul><h3 id="欧拉回路和欧拉路径">欧拉回路和欧拉路径</h3><ul><li>欧拉路径：图中的一条路径，使得该路径对图的每一条边正好经过一次</li><li>欧拉回路：起点和终点是相同的欧拉路径</li></ul><h3 id="找到欧拉回路的方法-———-路径拼接">找到欧拉回路的方法 ——— 路径拼接</h3><p>找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问。</p><p>首先，检查存在性：检查每个结点的度数是否为偶数</p><p>接着，执行一次深度优先的搜索。从起始结点开始，沿着这条路一直往下走，直到无路可走。而且在此过程中不允许回溯。</p><p>路径上是否有一个尚有未访问的边的顶点。如果有，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问。</p><h3 id="欧拉回路的实现">欧拉回路的实现</h3><ul><li>在邻接表类中增加一个公有成员函数EulerCircuit</li><li>欧拉回路是由一段一段的路径拼接起来的。为此，设计了一个私有的成员函数EulerCircuit来获得一段回路。</li><li>公有的函数调用私有的EulerCircuit函数获得一段段的路径，并将它们拼接起来，形成一条完整的欧拉回路。</li></ul><p>EulerNode 的定义</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">struct</span> <span class="hljs-type">EulerNode</span>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-type">NodeNum</span>;<br>    <span class="hljs-type">EulerNode</span> *next;<br>    <span class="hljs-type">EulerNode</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>):<span class="hljs-type">NodeNum</span>(<span class="hljs-keyword">val</span>),next(nullptr)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当一条边被访问以后，就将这条边删除<br>Clone函数创建一份邻接表的拷贝，以便在找完路径后能恢复这个图的邻接表</p><p>公有EulerCircuit函数实现</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs livescript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-literal">void</span> adjListGraph&lt;TypeOfVer,TypeOfEdge&gt;::EulerCircuit(TypeOfVer start)&#123;<br>    EulerNode *beg,*end,*p,*q,*tb,*te;<br>    int numOfDegree;<br>    edgeNode *r;<br>    verNode *tmp;<br><br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        numOfDegree = <span class="hljs-number">0</span>;<br>        r = verList[i].head;<br>        <span class="hljs-keyword">while</span>(r != nullptr)&#123;<br>            ++ numOfDegree;<br>            r = r-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(numOfDegree == <span class="hljs-number">0</span> || numOfDegree % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No EulerCircuit.&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    i = find(start);<br>    tmp = clone();<br><br>    EulerCircuit(i,beg,end);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        p = beg;<br>        <span class="hljs-keyword">while</span>(p-&gt;next != nullptr)&#123;<br>            <span class="hljs-keyword">if</span>(verList[p-&gt;next-&gt;NodeNum].head != nullptr)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;next == nullptr)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        q = p-&gt;next;<br>        EulerCircuit(q-&gt;NodeNum,tb,te);<br>        te-&gt;next = q-&gt;next;<br>        p-&gt;next = tb;<br>        <span class="hljs-keyword">delete</span> q;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> []verList;<br>    verList = tmp;<br><br>    <span class="hljs-keyword">while</span>(beg != nullptr)&#123;<br>        cout &lt;&lt; verList[beg-&gt;NodeNum].ver &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        p = beg;<br>        beg = beg -&gt; next;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>私有EulerCircuit函数实现</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> TypeOfVer,<span class="hljs-keyword">class</span> TypeOfEdge&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer,TypeOfEdge&gt;::EulerCircuit(<span class="hljs-type">int</span> <span class="hljs-keyword">start</span>,EulerNode *&amp;beg,EulerNode *&amp;<span class="hljs-keyword">end</span>)&#123;<br>    <span class="hljs-type">int</span> nextNode;<br><br>    beg = end = <span class="hljs-built_in">new</span> EulerNode(<span class="hljs-keyword">start</span>);<br>    <span class="hljs-keyword">while</span>(verList[<span class="hljs-keyword">start</span>].head != nullptr)&#123;<br>        nextNode = verList[<span class="hljs-keyword">start</span>].head-&gt;<span class="hljs-keyword">end</span>;<br>        remove(<span class="hljs-keyword">start</span>,nextNode);<br>        remove(nextNode,<span class="hljs-keyword">start</span>);<br>        start = nextNode;<br>        <span class="hljs-keyword">end</span>-&gt;next = <span class="hljs-built_in">new</span> EulerNode(<span class="hljs-keyword">start</span>);<br>        end = <span class="hljs-keyword">end</span>-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有向图的连通性">有向图的连通性</h2><p><strong>深度优先搜索可以测试是否强连通，并找出所有强连通分量</strong><br>找强连通分量的方法：</p><ul><li>从任意节点开始深度优先遍历G。对森林中的每棵树进行后序遍历，并按遍历的顺序给每个节点编号</li><li>将G的每条边逆向，形成Gr。从编号最大的节点开始深度优先遍历Gr。得到的深度优先遍历森林的每棵树就是G的强连通分量。</li></ul><h2 id="拓扑排序">拓扑排序</h2><p>存在于有向无环图中<br>拓扑序列是V中的一个顶点序列V1，V2，…，Vn<br><strong>满足条件：若在G中，从Vi到Vj有一条路径，则序列中Vi必须排在Vj的前面。</strong></p><p>Example：<br><img src="/img/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.png" alt="拓扑排序示例"></p><p><strong>第一个输出的结点（序列中的第一个元素）必须无前驱，即入度为0</strong>。无前驱的结点任何时候都可输出；普通结点，必须等到它的所有前驱输出之后才输出</p><p><strong>逻辑删除法</strong><br>当某个节点被输出后，就作为该节点被删除。所有以该节点作为前驱的所有节点的入度减1。</p><h3 id="拓扑排序算法总结">拓扑排序算法总结</h3><ul><li>计算每个结点的入度，保存在数组inDegree中；</li><li>检查inDegree中的每个元素，将入度为0的结点入队；</li><li>不断从队列中将入度为0的结点出队，输出此结点，并将该结点的后继结点的入度减1；如果某个邻接点的入度为0，则将其入队。</li></ul><h3 id="拓扑排序算法实现">拓扑排序算法实现</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">topSort</span>()&#123;<br>    linkQueue&lt;<span class="hljs-built_in">int</span>&gt; q;<br>    edgeNode *p;<br>    <span class="hljs-built_in">int</span> current;<br>    <span class="hljs-built_in">int</span> *inDegree = new <span class="hljs-built_in">int</span>[Vers];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        inDegree[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        p = verList[i].head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr)&#123;<br>            ++ inDegree[p-&gt;end];<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(inDegree[i] == <span class="hljs-number">0</span>)&#123;<br>            q.enQueue(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        current = q.deQueue();<br>        cout &lt;&lt; verList[current].ver &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        p = verList[current].head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr)&#123;<br>            <span class="hljs-keyword">if</span>(-- inDegree[p-&gt;end] == <span class="hljs-number">0</span>)&#123;<br>                q.enQueue(p-&gt;end);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关键路径">关键路径</h2><h3 id="AOV-网络-有向无环图">AOV 网络 有向无环图</h3><p>顶点表示活动，边表示活动的先后次序<br>主要应用：安排活动的顺序，即拓扑排序</p><h3 id="AOE网络-加权有向无环图">AOE网络 加权有向无环图</h3><ul><li>顶点表示事件，有向边的权值表示某个活动的持续时间，有向边的方向表示活动和事件的先后次序</li><li>进入顶点的所有活动都结束后，顶点表示的事件发生了，从该顶点出发的所有活动可以开始了</li></ul><p>用途：可用于描述整个工程的各个活动之间的关系，活动安排的先后次序<br><strong>完成整项工程至少需要多少时间：源点到收点的最长路径的长度，称为关键路径。</strong></p><h3 id="关键路径算法">关键路径算法</h3><p>找出每个顶点的最早发生时间和最迟发生时间</p><ul><li>最早发生时间：前面的活动都没有耽误时间，这个事件的发生时间</li><li>最迟发生时间：不影响整个项目按时完成的前提下，这个事件最晚可以什么时候发生</li></ul><p><strong>最早发生时间和最晚发生时间相同的顶点序列构成关键路径</strong></p><ul><li><p>最早发生时间：每个直接前驱的最早发生时间加上从该前驱到该顶点的活动时间的最大者</p></li><li><p>最迟发生时间：每个直接后继的最迟发生时间减去顶点到该直接后继的活动时间的最小者就是该顶点的最迟发生时间。</p></li><li><p><strong>找出拓扑序列</strong></p></li><li><p><strong>从头到尾遍历拓扑序列找出结点最早发生时间，从尾到头遍历拓扑序列找到最迟发生时间</strong></p></li><li><p>从头到尾遍历拓扑序列，找出最早发生时间和最迟发生时间的顶点，组成了关键路径。</p></li></ul><h3 id="关键路径算法实现">关键路径算法实现</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs prolog">template &lt;class <span class="hljs-symbol">TypeOfVer</span>,class <span class="hljs-symbol">TypeOfEdge</span>&gt;<br>void adjListGraph&lt;<span class="hljs-symbol">TypeOfVer</span>,<span class="hljs-symbol">TypeOfEdge</span>&gt;::criticalPath() const&#123;<br>    <span class="hljs-symbol">TypeOfEdge</span> *ee = new <span class="hljs-symbol">TypeOfEdge</span>[<span class="hljs-symbol">Vers</span>];<br>    <span class="hljs-symbol">TypeOfEdge</span> *le = new <span class="hljs-symbol">TypeOfEdge</span>[<span class="hljs-symbol">Vers</span>];<br>    int *top = new int[<span class="hljs-symbol">Vers</span>]; //存储拓扑排序后的序列<br>    int *inDegree = new int[<span class="hljs-symbol">Vers</span>];<br>    linkQueue&lt;int&gt; q;<br>    int i;<br>    edgeNode *p;<br>    for(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-symbol">Vers</span>;i ++)&#123;<br>        inDegree[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    for(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-symbol">Vers</span>;i ++)&#123;<br>        p = verList[i].head;<br>        while(p != nullptr)&#123;<br>            ++ inDegree[p-&gt;end];<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    for(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-symbol">Vers</span>;i ++)&#123;<br>        if(inDegree[i] == <span class="hljs-number">0</span>)&#123;<br>            q.enQueue(i);<br>        &#125;<br>    &#125;<br>    i = <span class="hljs-number">0</span>;<br>    while(!q.empty())&#123;<br>        top[i] = q.deQueue();<br>        p = verList[current].head;<br>        while(p != nullptr)&#123;<br>            if(-- inDegree[p-&gt;end] == <span class="hljs-number">0</span>)&#123;<br>                q.enQueue(p-&gt;end);<br>            &#125;<br>        &#125;<br>        i ++;<br>    &#125;<br><br>    for(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-symbol">Vers</span>;i ++)&#123;<br>        ee[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    for(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-symbol">Vers</span>;i ++)&#123;<br>        p = verList[top[i]].head;<br>        while(p != nullptr)&#123;<br>            if(ee[p-&gt;end] &lt; ee[top[i]] + p-&gt;weight)&#123;<br>                ee[p-&gt;end] = ee[top[i]] + p-&gt;weight;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br><br>    for(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-symbol">Vers</span>;i ++)&#123;<br>        le[i] = ee[top[<span class="hljs-symbol">Vers</span> - <span class="hljs-number">1</span>]];<br>    &#125;<br>    for(int i = <span class="hljs-symbol">Vers</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>        p = verList[top[i]].head;<br>        while(p != nullptr)&#123;<br>            if(le[top[i]] + p-&gt;weight &gt; le[p-&gt;end])&#123;<br>                le[top[i]] = le[p-&gt;end] - p-&gt;weight;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br><br>    for(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-symbol">Vers</span>;i ++)&#123;<br>        if(le[top[i]] == ee[top[i]])&#123;<br>            cout &lt;&lt; verList[top[i]].ver &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Topsort</tag>
      
      <tag>CriticalPath</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 10 Basic Graphics</title>
    <link href="/2025/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8410/"/>
    <url>/2025/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8410/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：Start-Of-Graphics-虽然并非想象中组合数学里的图论，但，但，但至少是图吧。当年学竞赛的时候总觉得组合题很fasinating，但也真的是不会做，甚至有时候答案都猜不出来…">Before：Start Of Graphics!虽然并非想象中组合数学里的图论，但，但，但至少是图吧。当年学竞赛的时候总觉得组合题很fasinating，但也真的是不会做，甚至有时候答案都猜不出来…</h4><h4 id="总觉得自己想额外做好多事，所以把各种ddl早早地清掉，但好像还是每天都很忙，还是没什么时间玩儿自己真正想玩儿的东西😇">总觉得自己想额外做好多事，所以把各种ddl早早地清掉，但好像还是每天都很忙，还是没什么时间玩儿自己真正想玩儿的东西😇</h4><h1>数据结构 10 图的基本概念</h1><h2 id="图的定义">图的定义</h2><p><strong>多对多的关系</strong></p><p>图可以用G=(V, E)表示</p><ul><li>V是顶点的集合，顶点代表数据元素，即V是数据元素集合</li><li>E是连接顶点的边的集合，边代表元素间的关系，即E是关系的集合</li></ul><p>分为：</p><ul><li>有向图</li><li>无向图</li><li>加权图：边被赋予一个权值，表示关系的程度</li><li>完全图：任意两个结点之间都有边的无向图称为完全图；每两个结点之间都有两条弧的有向图称为有向完全图。</li></ul><p><strong>基本术语</strong>：</p><ul><li>度：图中连接于某一结点的边的总数</li><li>入度：有向图中进入某一结点的边数，称为该结点的入度</li><li>出度：有向图中离开某一结点的边数，称为该结点的出度</li><li>子图：设有两个图G=（V，E）和G‘=（V’，E’），如果 V’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> V，E’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> E 则称G’是G的子图</li><li>路径：用一个结点序列w1,w2,……wN</li><li>简单路径：如果一条路径上的所有结点，除了起始结点和终止结点可能相同外，其余的结点都不相同，则称其为简单路径。</li><li>环：环是一条简单路径，其起始结点和终止结点相同，且路径长度至少为1。</li><li>非加权的路径长度：组成路径的边数，对于路径w1,w2,……wN ，非加权路径长度为N-1</li><li>加权路径长度：路径上所有边的权值之和</li><li>连通：顶点v至v’ 之间有路径存在</li><li>连通图：无向图 G 的任意两点之间都是连通的，则称 G 是连通图。</li><li>连通分量：非连通图中的极大连通子图</li><li>强连通图：有向图 G 的任意两点之间都是连通的，则称 G 是强连通图。</li><li>强连通分量：极大连通子图</li><li>弱连通图：如有向图G不是强连通的，但如果把它看成是无向图时是连通的，则称该图是弱连通的。</li><li>生成树：连通图的极小连通子图。包含图的所有 n 个结点，但只含图的 n-1 条边。在生成树中添加一条边之后，必定会形成回路或环。</li></ul><p>在图论中，树其实是连通、无环路的图</p><p>其他结构都可以看成是图的特例，一个特殊的有向图</p><ul><li>集合结构：边集为空</li><li>线性结构：有向无环图。除起始结点和终止结点外，每个结点的入度出度均为1。起始结点入度为0，终止结点出度为0</li><li>树状结构：有向无环图。除根结点外，每个结点入度为1，出度为0 ~ N。根结点入度为0</li></ul><h2 id="图的存储">图的存储</h2><h3 id="邻接矩阵">邻接矩阵</h3><ul><li>顶点集合：存储在一个数组中</li><li>边集合：用 n 行 n 列的布尔矩阵 A 表示。如果i 至 j 有一条有向边，A[i,j] = 1 ，如果 i 至 j 没有一条有向边，A[i,j] = 0。</li></ul><p>从定义可以看出，邻接矩阵的优缺点都很明显：</p><ul><li>优点：O(1)乱杀</li><li>缺点：对于稀疏图（也是大多数图），太占内存空间<br>于是我们想到——链表！！！</li></ul><h3 id="邻接表">邻接表</h3><ul><li>顶点集合：用数组或单链表的形式存放所有的结点值<br>如果结点数n固定，则采用数组形式，否则可采用单链表的形式</li><li>边集合：同一个结点出发的所有边组成一个单链表</li></ul><p>存储示意图：<br><img src="/img/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="邻接表存储"></p><h3 id="邻接表定义">邻接表定义</h3><p>横向的单链表和纵向的单链表</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">adjListGraph:<span class="hljs-symbol">public</span></span> <span class="hljs-symbol">graph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;&#123;<br><span class="hljs-keyword">public</span>:      <br>    adjListGraph(<span class="hljs-built_in">int</span> vSize, <span class="hljs-keyword">const</span> TypeOfVer d[]);<br>    <span class="hljs-built_in">void</span> insert(TypeOfVer x, TypeOfVer y, TypeOfEdge w);<br>    <span class="hljs-built_in">void</span> remove(TypeOfVer x, TypeOfVer y);<br>    <span class="hljs-built_in">bool</span> exist(TypeOfVer x, TypeOfVer y) <span class="hljs-keyword">const</span>;<br>    ~adjListGraph();<br><br><span class="hljs-keyword">private</span>:<br>    struct edgeNode&#123;  <span class="hljs-comment">//存储边的结点类型</span><br>        <span class="hljs-built_in">int</span> end; <span class="hljs-comment">//终点</span><br>        TypeOfEdge weight; <span class="hljs-comment">//权值</span><br>        edgeNode *next;<br>        edgeNode(<span class="hljs-built_in">int</span> e,TypeOfEdge w,edgeNode *n = <span class="hljs-literal">null</span>ptr):end(e),weight(w),next(n)&#123;&#125;<br>    &#125;;<br><br>    struct verNode&#123;  <span class="hljs-comment">//保存结点的数据类型</span><br>        TypeOfVer ver; <span class="hljs-comment">//顶点值</span><br>        edgeNode *head;  <span class="hljs-comment">//edgeNode数组</span><br>        verNode(edgeNode *h = <span class="hljs-literal">null</span>ptr):head(h)&#123;&#125;<br>    &#125;;<br><br>    verNode *verlist;<br><br>    <span class="hljs-built_in">int</span> find(TypeOfVer v) <span class="hljs-keyword">const</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>            <span class="hljs-keyword">if</span>(verlist[i] == v)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">adjListGraph</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">vSize,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">TypeOfVer</span> <span class="hljs-symbol">d</span>[])&#123;<br>    Vers = vSize;<br>    Edges = <span class="hljs-number">0</span>;<br>    verlist = new verNode[vSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        verlist[i].ver = d[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::~<span class="hljs-symbol">adjListGraph</span>()&#123;<br>    edgeNode *p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Vers;i ++)&#123;<br>        <span class="hljs-keyword">while</span>(verlist[i].head)&#123;<br>            p = verlist[i].head;<br>            verlist[i].head = verlist[i].head-&gt;next;<br>            delete p;<br>        &#125;<br>    &#125;<br>    delete []verlist;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表实现">邻接表实现</h3><p>insert操作</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">TypeOfVer</span> <span class="hljs-symbol">x,<span class="hljs-symbol">TypeOfVer</span></span> <span class="hljs-symbol">y,<span class="hljs-symbol">TypeOfEdge</span></span> <span class="hljs-symbol">e</span>)&#123;<br>    <span class="hljs-built_in">int</span> u = find(x);<br>    <span class="hljs-built_in">int</span> v = find(y);<br><br>    verlist[u].head = new verNode(v,w,verlist[u].head);<br>    ++ Edges;<br>&#125;<br></code></pre></td></tr></table></figure><p>remove操作</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">adjListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">TypeOfVer</span> <span class="hljs-symbol">x,<span class="hljs-symbol">TypeOfVer</span></span> <span class="hljs-symbol">y</span>)&#123;<br>    <span class="hljs-built_in">int</span> u = find(x);<br>    <span class="hljs-built_in">int</span> v = find(y);<br>    edgeNode *p = verList[u].head;<br>    edgeNode *q;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;end == v)&#123;<br>        verlist[u].head = p-&gt;next;<br>        delete p;<br>        -- Edges;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;next-&gt;end == v)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">null</span>ptr)&#123;<br>        q = p-&gt;next;<br>        p-&gt;next = q-&gt;next;<br>        delete q;<br>        -- Edges;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>exist操作</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">TypeOfVer, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">TypeOfEdge</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">djListGraph</span>&lt;<span class="hljs-symbol">TypeOfVer,<span class="hljs-symbol">TypeOfEdge</span></span>&gt;::<span class="hljs-symbol">exist</span>(<span class="hljs-symbol">TypeOfVer</span> <span class="hljs-symbol">x,<span class="hljs-symbol">TypeOfVer</span></span> <span class="hljs-symbol">y</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-built_in">int</span> u = find(x);<br>    <span class="hljs-built_in">int</span> v = find(y);<br>    edgeNode *p = verList[u].head;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;end == v)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表时间复杂度">邻接表时间复杂度</h3><p>图的线性算法，一般指的是O(|V| + |E|)</p><h3 id="其他存储方法">其他存储方法</h3><ul><li>逆邻接表  将进入同一结点的边组织成一个单链表</li><li>十字链表  既记录前驱又记录后继  每条边只存储一次</li><li>邻接多重表  解决无向图中边存储两次的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Graphics</tag>
      
      <tag>Adjacency List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Segment Tree</title>
    <link href="/2025/04/20/AlgorithmOfDS3/"/>
    <url>/2025/04/20/AlgorithmOfDS3/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：Long-time-no-see！最近强度激增，B-树de了一整天，还有MLE和TLE，感觉是某个地方写爆栈了😢数理逻辑作业还没写完，下周还要复习数分。">Before：Long time no see！最近强度激增，B+树de了一整天，还有MLE和TLE，感觉是某个地方写爆栈了😢数理逻辑作业还没写完，下周还要复习数分。</h4><h4 id="upd：昨天晚上过了，打算51把管理系统速通了，挑点bonus写一下（其实想全写但显然没空），弥补一下bookstore啥bonus都没写的遗憾。希望周五数分顺利！">upd：昨天晚上过了，打算51把管理系统速通了，挑点bonus写一下（其实想全写但显然没空），弥补一下bookstore啥bonus都没写的遗憾。希望周五数分顺利！</h4><h1>Algorithm Of Data Structure —— Segment Tree</h1><h2 id="Definition">Definition</h2><ul><li>二叉树</li><li>每一个叶子节点维护原序列的信息</li><li>每个中间结点维护一段区间信息</li><li>通过子节点的高效信息合并得到中间节点的区间信息</li></ul><p>An example of Segment Tree:<br><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91.png" alt="Simple Segment Tree"></p><h2 id="Basic-Rules">Basic Rules</h2><ul><li>Apparently,线段树是一棵完全二叉树，故树高 h = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span></span></span></span></li><li>结点总数约为 2n，故O(n) = 2n</li><li>每个结点代表一个区间[l,r]，并维护该区间的信息，如区间内的数字和、最大(小)值等。该区间信息由两个分别代表[l, mid],[mid+1, r]的子结点合并而来。</li></ul><h2 id="Storage">Storage</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span></span>&#123;<br>    struct TreeNode&#123;<br>        <span class="hljs-keyword">int</span> l,r; <span class="hljs-regexp">//</span>左右端点<br>        <span class="hljs-keyword">int</span> lson,rson; <span class="hljs-regexp">//</span>左右儿子编号<br>        <span class="hljs-keyword">int</span> data; <span class="hljs-regexp">//</span>关键数据<br>    &#125;nodes[maxN &lt;&lt; <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>问题来了，存树的数组应该开多大？<br>通过一些数学证明，我们可以得到，数组应该开成 <strong>4n</strong>。</p><h2 id="Build-Tree">Build Tree</h2><p><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%98%E5%82%A8.png" alt="Build Segment Tree"></p><p>Example：求区间最大值</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void push_up(int <span class="hljs-keyword">node</span><span class="hljs-title">)&#123;</span><br><span class="hljs-title">    auto</span> &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    cur</span>.data = max(nodes[cur.lson],nodes[cur.rson]);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void build(int <span class="hljs-keyword">node</span><span class="hljs-title">,int</span> l,int r)&#123;<br>    auto &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    cur</span>.l = l;<br>    cur.r = r;<br>    if(l == r)&#123;<br>        cur.data = data[l];<br>        return;<br>    &#125;<br>    auto mid = (l + r) / <span class="hljs-number">2</span>;<br>    cur.lson = <span class="hljs-number">2</span> * <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">    cur</span>.rson = <span class="hljs-number">2</span> * <span class="hljs-keyword">node</span> <span class="hljs-title">+ 1</span>;<br>    build(cur.lson,l,mid);<br>    build(cur.rson,mid + <span class="hljs-number">1</span>,r);<br>    push_up(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Query">Query</h2><p>A Good Picture!<br><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%9F%A5%E8%AF%A2.png" alt="Query"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> node,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123;<br>    auto &amp;cur = nodes[node];<br>    <span class="hljs-built_in">if</span>(l &lt;= cur.l &amp;&amp; cur.r &lt;= r)&#123;<br>        return cur.data;<br>    &#125;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (l + r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">if</span>(l &lt;= <span class="hljs-built_in">mid</span>)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,query(cur.lson,l,r));<br>    &#125;<br>    <span class="hljs-built_in">if</span>(r &gt; <span class="hljs-built_in">mid</span>)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,query(cur.rson,l,r));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Single-Point-Update">Single Point Update</h2><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs hsp">void update(<span class="hljs-keyword">int</span> node,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,<span class="hljs-keyword">int</span> val)&#123;<br>    auto &amp;cur = nodes[node]<span class="hljs-comment">;</span><br>    <span class="hljs-keyword">if</span>(cur.lson == cur.rson)&#123;<br>        cur.data = val<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">return</span><span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = (cur.l + cur.r)/<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span> &lt;= mid)&#123;<br>        update(cur.lson,<span class="hljs-keyword">pos</span>,val)<span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span> &gt; mid)&#123;<br>        update(cur.rson,<span class="hljs-keyword">pos</span>,val)<span class="hljs-comment">;</span><br>    &#125;<br>    push_up(node)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Range-Update">Range Update</h2><p>区间查询的核心思想：区间信息上放<br>复杂度：O(logN)</p><p>区间修改能不能也使用相同的思想？<br>若将区间 [l, r] 内元素都加上某个值:</p><ul><li>若维护最值，直接 cur.data+=val</li><li>若维护区间和，则 cur.data+=(r −l+1)∗ val <br>发现：有时我们会对整棵子树做同样的操作</li></ul><p>Solution: Lazy Tag!</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span></span>&#123;<br>    struct TreeNode&#123;<br>        <span class="hljs-keyword">int</span> l,r; <span class="hljs-regexp">//</span>左右端点<br>        <span class="hljs-keyword">int</span> lson,rson; <span class="hljs-regexp">//</span>左右儿子编号<br>        <span class="hljs-keyword">int</span> lazy_tag;<br>        <span class="hljs-keyword">int</span> data; <span class="hljs-regexp">//</span>关键数据<br>    &#125;nodes[maxN &lt;&lt; <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">void modify(<span class="hljs-built_in">int</span> node,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>    auto &amp;cur = nodes[node];<br>    <span class="hljs-keyword">if</span>(l &lt;= cur.l &amp;&amp; cur.r &lt;= r)&#123;<br>        cur.data += <span class="hljs-keyword">val</span>;<br>        cur.lazytag += <span class="hljs-keyword">val</span>;<br>        return;<br>    &#125;<br>    push_down(node);<br>    <span class="hljs-built_in">int</span> mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid)&#123;<br>        modify(cur.lson,l,r,<span class="hljs-keyword">val</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid)&#123;<br>        modify(cur.rson,l,r,<span class="hljs-keyword">val</span>);<br>    &#125;<br>    push_up(node);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void push_down(int <span class="hljs-keyword">node</span><span class="hljs-title">)&#123;</span><br><span class="hljs-title">    auto</span> &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    if</span>(cur.lazytag != <span class="hljs-number">0</span>)&#123;<br>        nodes[cur.lson].data += cur.lazytag;<br>        nodes[cur.rson].data += cur.lazytag;<br>        nodes[cur.lson].lazytag = cur.lazytag;<br>        nodes[cur.rson].lazytag = cur.lazytag;<br>        cur.lazytag = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Template-Problem">Template Problem</h2><p>已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上 x；</li><li>将某区间每一个数加上 x；</li><li>求出某区间每一个数的和。</li></ul><p>(add_tag,mul_tag)------(* k)-----&gt;(add_tag * k,mul_tag * k)<br>(add_tag,mul_tag)------(+ k)-----&gt;(add_tag + k,mul_tag)</p><p>AC代码捏</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;iostream&gt;<br>using namespace std;<br>long long int n,m,mod;<br>long long int num[<span class="hljs-number">100005</span>];<br>struct <span class="hljs-symbol">SegmentTree</span> &#123;<br>    long long int l,r;<br>    long long int lson,rson;<br>    long long int lazytag;<br>    long long int multiTag = <span class="hljs-number">1</span>;<br>    long long int data;<br>&#125;nodes[<span class="hljs-number">400005</span>];<br>void push_up(long long int node) &#123;<br>    auto &amp;cur = nodes[node];<br>    cur.data = nodes[cur.lson].data + nodes[cur.rson].data;<br>    cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>&#125;<br>void push_down(long long int node) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.multiTag != <span class="hljs-number">1</span>) &#123;<br>        nodes[cur.lson].multiTag *= cur.multiTag;<br>        nodes[cur.lson].multiTag = (nodes[cur.lson].multiTag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].multiTag *= cur.multiTag;<br>        nodes[cur.rson].multiTag = (nodes[cur.rson].multiTag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].lazytag *= cur.multiTag;<br>        nodes[cur.lson].lazytag = (nodes[cur.lson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].lazytag *= cur.multiTag;<br>        nodes[cur.rson].lazytag = (nodes[cur.rson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].data *= cur.multiTag;<br>        nodes[cur.lson].data = (nodes[cur.lson].data + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].data *= cur.multiTag;<br>        nodes[cur.rson].data = (nodes[cur.rson].data + mod)<span class="hljs-comment">%mod;</span><br>        cur.multiTag = <span class="hljs-number">1</span>;<br>    &#125;<br>    if(cur.lazytag != <span class="hljs-number">0</span>) &#123;<br>        nodes[cur.lson].lazytag += cur.lazytag;<br>        nodes[cur.lson].lazytag = (nodes[cur.lson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].lazytag += cur.lazytag;<br>        nodes[cur.rson].lazytag = (nodes[cur.rson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].data += (nodes[cur.lson].r - nodes[cur.lson].l + <span class="hljs-number">1</span>)*cur.lazytag;<br>        nodes[cur.lson].data = (nodes[cur.lson].data + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].data += (nodes[cur.rson].r - nodes[cur.rson].l + <span class="hljs-number">1</span>)*cur.lazytag;<br>        nodes[cur.rson].data = (nodes[cur.rson].data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>void buildTree(long long int node,long long int l,long long int r) &#123;<br>    auto &amp;cur = nodes[node];<br>    cur.multiTag = <span class="hljs-number">1</span>;<br>    cur.l = l;<br>    cur.r = r;<br>    if(l == r) &#123;<br>        cur.data = num[l];<br>        return;<br>    &#125;<br>    long long int mid = (l + r)/<span class="hljs-number">2</span>;<br>    cur.lson = <span class="hljs-number">2</span> * node;<br>    cur.rson = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>;<br>    buildTree(cur.lson,l,mid);<br>    buildTree(cur.rson,mid + <span class="hljs-number">1</span>,r);<br>    push_up(node);<br>&#125;<br>void update(long long int node,long long int l,long long int r,long long int val) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.l &gt;= l &amp;&amp; cur.r &lt;= r) &#123;<br>        cur.data += (cur.r - cur.l + <span class="hljs-number">1</span>)*val;<br>        cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag += val;<br>        cur.lazytag = (cur.lazytag + mod)<span class="hljs-comment">%mod;</span><br>        return;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    if(l &lt;= mid) &#123;<br>        update(cur.lson,l,r,val);<br>    &#125;<br>    if(r &gt; mid) &#123;<br>        update(cur.rson,l,r,val);<br>    &#125;<br>    push_up(node);<br>&#125;<br>void update2(long long int node,long long int l,long long int r,long long int val) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.l &gt;= l &amp;&amp; cur.r &lt;= r) &#123;<br>        cur.data *= val;<br>        cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag *= val;<br>        cur.lazytag = (cur.lazytag + mod)<span class="hljs-comment">%mod;</span><br>        cur.multiTag *= val;<br>        cur.multiTag = (cur.multiTag + mod)<span class="hljs-comment">%mod;</span><br>        return;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    if(l &lt;= mid) &#123;<br>        update2(cur.lson,l,r,val);<br>    &#125;<br>    if(r &gt; mid) &#123;<br>        update2(cur.rson,l,r,val);<br>    &#125;<br>    push_up(node);<br>&#125;<br>long long int query(long long int node,long long int l,long long int r) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(l &lt;= cur.l &amp;&amp; cur.r &lt;= r) &#123;<br>        return cur.data;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    long long int res = <span class="hljs-number">0</span>;<br>    if(l &lt;= mid) &#123;<br>        res += query(cur.lson,l,r);<br>    &#125;<br>    res = (res + mod)<span class="hljs-comment">%mod;</span><br>    if(r &gt; mid) &#123;<br>        res += query(cur.rson,l,r);<br>    &#125;<br>    res = (res + mod)<span class="hljs-comment">%mod;</span><br>    return res;<br>&#125;<br>int main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; num[i];<br>    &#125;<br>    buildTree(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    long long int x,y,k;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        int op;<br>        cin &gt;&gt; op;<br>        if(op == <span class="hljs-number">2</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>            update(<span class="hljs-number">1</span>,x,y,k);<br>        &#125;else if(op == <span class="hljs-number">3</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            cout &lt;&lt; query(<span class="hljs-number">1</span>,x,y) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;else if(op == <span class="hljs-number">1</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>            update2(<span class="hljs-number">1</span>,x,y,k);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特别值得注意的是，push_down时应该先更新multiTag，再更新addTag（先乘后加的原则）</p><h2 id="Classic-Problem">Classic Problem</h2><p><a href="http://poj.org/problem?id=3667">POJ 3667 - Hotel</a></p><p>现有一排房间</p><ul><li>询问：是否有连续x个空房间；如果有，就将最靠前的连续x个房间填满</li><li>修改：将任意一段房间清空(可能本来就是空的)</li></ul><p>每个结点维护子树区间内左端极长、右端极长和最长空房间（l_max,r_max,max）<br>Tag：full/null/empty</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Segment Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic 8 Completeness Proof (upding...)</title>
    <link href="/2025/04/19/Mathematical-Logic8/"/>
    <url>/2025/04/19/Mathematical-Logic8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 9 Disjoint Set</title>
    <link href="/2025/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%849/"/>
    <url>/2025/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%849/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：第九周了，学期已经过半，好快啊🫠🫠今天考完了物理期中，挺有难度的，但能做的基本上都做了，该写的也都写上去了（最后一题相对论算的有点草率，没完全写清过程，估计会掉点分）2个挺难的题正确性未知，但感觉应该还有不少分？希望物理能给个3-7，呜呜呜。这周好累啊，事情变的好多，直到现在还欠了一屁股债。本人正在疯狂工作ing😣">Before：第九周了，学期已经过半，好快啊🫠🫠今天考完了物理期中，挺有难度的，但能做的基本上都做了，该写的也都写上去了（最后一题相对论算的有点草率，没完全写清过程，估计会掉点分）2个挺难的题正确性未知，但感觉应该还有不少分？希望物理能给个3.7，呜呜呜。这周好累啊，事情变的好多，直到现在还欠了一屁股债。本人正在疯狂工作ing😣</h4><h1>数据结构 9 外排序 不相交集</h1><h2 id="外排序">外排序</h2><p>在外存上进行排序的最常用的方法是利用<strong>归并排序</strong>，因为归并排序只需要访问被归并序列中的第一个元素，这非常适合于顺序文件。</p><p>分为2个阶段：<strong>预处理阶段和归并阶段</strong></p><p>预处理阶段：根据内存的大小将一个有 n 个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序的小文件——有序片段。（<strong>读入内存后排序</strong>）</p><h3 id="置换选择">置换选择</h3><p>在外排序中，已排序片段越多，归并次数也越多，<strong>每次归并都必须对所有数据读写一遍</strong>，因此归并时间也越长。</p><p><strong>置换选择可以在只能容纳p个记录的内存中生成平均长度为2p的初始已排序片段</strong><br>其过程如下：</p><ul><li>初始时，将M个元素读入内存，用一个buildHeap建立一个优先级队列。</li><li>执行一次deQueue，把最小的元素写入输出文件。</li><li>从输入文件读入下一个元素。如果它比刚才写出去的元素大，则把它加入到优先级队列；否则，它不可能进入当前的已排序片段。因为优先级队列比以前少了一个元素，该元素就被放于优先级队列的空余位置，</li><li>继续这个过程，直到优先级队列的大小为0，此时该已排序片段结束。通过一个buildHeap操作重新构建一个优先级队列，开始了一个新的已排序片段，此时用了所有存放在空余位置中的元素。</li></ul><h2 id="等价关系">等价关系</h2><p>定义在集合上的一种关系，满足自反性、对称性、传递性</p><h3 id="等价关系中的基本操作：">等价关系中的基本操作：</h3><ul><li>判断两个元素之间是否有关系</li><li>在两个元素间添加关系</li></ul><h3 id="等价类">等价类</h3><p>互相之间有关系的元素形成的的一个子集<br>等价类形成了整个集合S的一种分割</p><h3 id="操作的实现">操作的实现</h3><ul><li>判i、j之间是否有关系：<br>判是否在一个等价类中</li><li>添加关系：<br>归并两个等价类</li></ul><h2 id="不相交集——并查集">不相交集——并查集</h2><h3 id="不相交集定义">不相交集定义</h3><p>处理等价关系的数据结构</p><h3 id="基本操作：">基本操作：</h3><ul><li>find：找出特定元素属于哪个等价类</li><li>union：用于添加关系。如果要把序偶(a, b)加到关系表中，则与a相关的元素都与b相关，与b相关的元素也都与a相关。即a的等价类与b的等价类合并为一个等价类。</li></ul><h3 id="特点">特点</h3><ul><li>并不关心元素具体的值，只关心他们的一个标识。因此可简单将这些元素顺序编号为0 – N-1</li><li>在查找操作时，并不关心等价类的名字，只需要知道当a和b在一个等价类中时，find的结果是相同的</li></ul><h2 id="不相交集的实现">不相交集的实现</h2><h3 id="不相交集的存储实现">不相交集的存储实现</h3><p>方法一：线性表存（一眼O(N)，一边儿去）<br><strong>方法二：用树保存集合</strong><br>每个等价类表示为一棵树，等价类的名字为根结点的名字。<br>保证union是O(1)，而find可以达到O(logN)</p><p>数组s[i]表示值为<strong>i 的父节点</strong></p><h3 id="基本操作实现">基本操作实现</h3><ul><li>union操作：归并两棵树，将一棵树的根作为另一棵树的孩子。这个操作很明显是常量时间。</li><li>find(x)操作：从x开始向根回溯。完成该操作的时间正比于从x到根的路径上的结点数。最坏情况可能是O(N)，一般情况是O(logN)</li></ul><p>哈哈哈，又是动态查找表的前言捏（可爱捏bushi）哈哈哈哈哈，所以是降低树高呗。</p><p>Two Ways！</p><h3 id="union操作">union操作</h3><p><strong>归并两棵树时，避免树的增高</strong><br>可以按<strong>规模</strong>，也可以按<strong>高度</strong>并</p><p>Tips：根的数组项包含一个负数的树规模</p><h3 id="find操作：顺便降低树的高度">find操作：顺便降低树的高度</h3><p>不相交集中，每棵子树的最理想的状态是一棵二层的数，只有根结点和它的儿子。这时，find操作的效率最高。<br>改进的union算法可以降低树的高度，提高find的效率。但当被归并的两棵树规模相同或高度相同时，树高还是会增加。</p><p>另外一种效率的改进方法是通过find操作，这种方法称为<strong>路径压缩</strong>。</p><p>当对find（x）采用路径压缩方法的话，那么在从x到根结点的路径上的每一个结点都将自己的父结点改为根结点。</p><h2 id="不相交集的应用">不相交集的应用</h2><h3 id="生成迷宫算法">生成迷宫算法</h3><ul><li>开始时，每个单元是一个等价类。</li><li>选择相邻两个单元，判别是否在一个等价类。如果不是，敲开两个单元之间的墙，使之连通。归并两个等价类。</li><li>重复上述过程，直到入口和出口在一个等价类中。</li></ul><h3 id="最近公共祖先-LCA-Lowest-Common-Ancestor">最近公共祖先 LCA Lowest Common Ancestor</h3><p>Description：给定一棵树和一个树中的结点对，找出这对结点的最近的共同祖先</p><p>将每一棵子树看成是一个等价类，子树的根是等价类的标志。<br>按后序遍历这棵树，在后序遍历的过程中计算每个结点的等价类，每次生成一个新的等价类后，检查结点对中的两个结点是否在一个等价类中。如果在，这个等价类的标志就是他们的共同祖先。</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>LCA</tag>
      
      <tag>Disjoint Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modern Cpp</title>
    <link href="/2025/04/14/Modern-Cpp/"/>
    <url>/2025/04/14/Modern-Cpp/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：上机课偶遇modern-cpp，拼劲全力无法战胜">Before：上机课偶遇modern cpp，拼劲全力无法战胜</h4><h1>Modern Cpp</h1><h2 id="Overview！">Overview！</h2><p>关于C++的刻板印象是什么？😋<br>笔者在学习了Java（以及相当烂的py）后，深深地感受到了C++语法规则以及一些奇奇怪怪的规定的复杂😇😇。总结一下C++：</p><ul><li>Old, out-dated, less-frequently used</li><li>Unsafe （特别对，救命啊）</li><li>Hard to use</li><li>Various Complication Issues</li></ul><p>Anyway,we still need to learn <strong>Modern Cpp</strong>.<br>We will cover:</p><ul><li>std::move and value types</li><li>Type inference and std::forward</li><li>auto inference</li><li>Syntax sugar</li><li>Smart pointers</li><li>Safety</li></ul><h2 id="Value-Types">Value Types</h2><h3 id="左值-右值">左值 右值</h3><ul><li>左值表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。可以用&amp;</li><li>右值则相反，是一个临时对象，不可以用&amp;</li></ul><p>我们知道有2种赋值方式：拷贝赋值和移动赋值。对于a = xxx:</p><ul><li>拷贝赋值函数：xxx为左值</li><li>移动赋值函数：xxx为右值</li></ul><h3 id="Move-for-lvalue？std-move">Move for lvalue？std::move!</h3><p>一个Common sense是移动move比拷贝要快，如果我们想<strong>移动一个左值呢</strong>？</p><p><strong>我们可以用std::move</strong> for this.<br>std::move可以让编译器认为某个左值是一个右值，进行了<strong>所有权的转移</strong>，使用了std::move后的对象不可再使用。</p><p><code>const</code>变量不可以使用移动语义。<br><strong>Notice：以下地方不可用std::move</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">void Print(const std::string &amp;s);<br>std::string <span class="hljs-built_in">Concat</span>(const std::string &amp;p, std::string q) &#123;<br>    ∕∕ Move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> const <span class="hljs-selector-tag">var</span><br>    std::string tmp = std::<span class="hljs-built_in">move</span>(p);<br><br>    ∕∕ Move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> rvalue<br>    std::string tmp2 = std::<span class="hljs-built_in">move</span>(p + q);<br>    std::string ret = p + q;<br><br>    ∕∕ Move <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span> const value reference<br>    Print(std::<span class="hljs-built_in">move</span>(p + q));<br><br>    ∕∕ Move the return value or <span class="hljs-selector-tag">use</span> after move<br>    return std::<span class="hljs-built_in">move</span>(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>std::move的实现并不同于想象中的复杂类型转换，实际上它只用了<code>static_cast</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">∕∕ A sample implementation of std::move<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="hljs-function">type&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">move</span><span class="hljs-params">(_Tp&amp;&amp; <span class="hljs-type">__t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="hljs-type">__t</span>); &#125;<br></code></pre></td></tr></table></figure><h2 id="Universal-Reference-通用引用">Universal Reference 通用引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;param)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>如果传递的参数是左值（lvalue），则 T 会被推断为该类型的引用。如果传递的参数是右值（rvalue），则 T 会被推断为该类型的值类型。</strong><br>所以如果param是左值，T的类型会是int &amp;，那么param的类型会是int&amp; &amp;&amp;，C++会将其折叠为int&amp;。（<strong>引用折叠</strong>）</p><p>如果param是右值，T的类型会是int。那么param的类型会是int&amp;&amp;。<br>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;param)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_lvalue_reference_v&lt;T&gt;)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Left value passed. Type of param is &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Right value passed. Type of param is &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">func</span>(a);  <span class="hljs-comment">// 左值传递</span><br><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(b));  <span class="hljs-comment">// 右值传递</span><br><br>    <span class="hljs-type">int</span> &amp;c = a;<br>    <span class="hljs-built_in">func</span>(c);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-forward-完美转发">std::forward 完美转发</h2><p>笔者在<a href="https://stackoverflow.com/questions/8526598/how-does-stdforward-work-especially-when-passing-lvalue-rvalue-references">stackoverflow</a>上找了一些观点<br><strong>std::forward is really just syntactic sugar over static_cast&lt;T&amp;&amp;&gt;</strong>.Nicol Bolas CommentedDec 15, 2011 at 21:19</p><p><strong>The concepts that seems to be lacking is that type (for instance int) is not the same thing as “value category” (an int can be sometimes a lvalue if you use a variable int a, sometimes rvalue if you return it from a function int fun()). When you look at a parameter thing&amp;&amp; x its type is an rvalue reference, however, the variable named x also has a value category: it’s an lvalue. std::forward&lt;&gt; will make sure to convert the “value category” x to match its type. It makes sure a thing&amp; x is passed as a value category lvalue, and thing&amp;&amp; x passed as an rvalue.</strong> arkan CommentedOct 1, 2022 at 14:19</p><p>std::forward 的作用是根据模板参数的类型，将参数转发为左值或右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp; t)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-comment">//移除T的引用类型</span><br></code></pre></td></tr></table></figure><p>Attach a test:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-type">void</span> process(<span class="hljs-type">int</span>&amp; x) &#123;<br>    std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-type">void</span> process(<span class="hljs-type">int</span>&amp;&amp; x) &#123;<br>    std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;typename T&gt;<br><span class="hljs-type">void</span> <span class="hljs-keyword">wrapper</span>(T&amp;&amp; arg) &#123;<br>    process(std::forward&lt;T&gt;(arg));<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">wrapper</span>(a); // 输出 &quot;lvalue&quot;<br>    <span class="hljs-keyword">wrapper</span>(<span class="hljs-number">20</span>); // 输出 &quot;rvalue&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Auto-Reference-自动类型推断">Auto Reference 自动类型推断</h2><ul><li>auto可推断变量类型</li><li>auto&amp; 可推断引用类型</li><li>const auto&amp; 可推断常量引用</li></ul><p>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个包含整数的向量</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 auto&amp; 遍历向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : vec) &#123;<br>        <span class="hljs-comment">// 直接修改容器中的元素</span><br>        elem *= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出修改后的向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : vec) &#123;<br>        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="Important-Part-Smart-Pointers-智能指针">Important Part: Smart Pointers!智能指针</h2><h3 id="unique-ptr">unique_ptr</h3><p>一个Move Only的智能指针，只可以拥有一个拥有者。<br>Attach an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass created with name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destroyed with name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>&#125;;<br><br><span class="hljs-comment">// 函数接受一个 unique_ptr 并打印内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintUniquePtr</span><span class="hljs-params">(std::unique_ptr&lt;MyClass&gt; ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>        ptr-&gt;<span class="hljs-built_in">Print</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;unique_ptr is null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数返回一个 unique_ptr</span><br><span class="hljs-function">std::unique_ptr&lt;MyClass&gt; <span class="hljs-title">CreateUniquePtr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 unique_ptr</span><br>    std::unique_ptr&lt;MyClass&gt; myPtr = <span class="hljs-built_in">CreateUniquePtr</span>(<span class="hljs-string">&quot;Kimi&quot;</span>);<br><br>    <span class="hljs-comment">// 使用 unique_ptr</span><br>    myPtr-&gt;<span class="hljs-built_in">Print</span>();<br><br>    <span class="hljs-comment">// 将 unique_ptr 传递给另一个函数</span><br>    <span class="hljs-built_in">PrintUniquePtr</span>(std::<span class="hljs-built_in">move</span>(myPtr));<br><br>    <span class="hljs-comment">// myPtr 已经被移动，现在是空的</span><br>    <span class="hljs-keyword">if</span> (!myPtr) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;myPtr is now null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建另一个 unique_ptr</span><br>    std::unique_ptr&lt;MyClass&gt; anotherPtr = <span class="hljs-built_in">CreateUniquePtr</span>(<span class="hljs-string">&quot;Moonshot AI&quot;</span>);<br><br>    <span class="hljs-comment">// 使用 unique_ptr 的 reset 方法</span><br>    anotherPtr-&gt;<span class="hljs-built_in">Print</span>();<br>    anotherPtr.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 手动释放资源</span><br>    <span class="hljs-keyword">if</span> (!anotherPtr) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;anotherPtr is now null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MyClass created <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Kimi<br><span class="hljs-type">Name</span>: Kimi<br><span class="hljs-type">Name</span>: Kimi<br>MyClass destroyed <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Kimi<br>myPtr <span class="hljs-keyword">is</span> now <span class="hljs-keyword">null</span><br>MyClass created <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Moonshot AI<br><span class="hljs-type">Name</span>: Moonshot AI<br>MyClass destroyed <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Moonshot AI<br>anotherPtr <span class="hljs-keyword">is</span> now <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr">shared_ptr</h3><p>基本特性：</p><ul><li>可以有多个所有者，是可拷贝的，但需要注意循环引用问题。</li><li>只有当所有拥有者都释放它时才会销毁（通过引用计数实现）。</li></ul><p><code>shared_ptr</code>的特殊用途<br>解决类之间的循环引用：<br>如果两个类相互包含对方的对象，会导致编译错误，因为C++需要在编译时知道类的大小。<br>使用shared_ptr可以解决这个问题，因为shared_ptr<T>只需要类的声明而不需要定义就可以使用。</p><p>Attach an example:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    // 其他方法和成员<br>private:<br>    std::shared_ptr&lt;B&gt; b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    // 其他方法和成员<br>private:<br>    std::shared_ptr&lt;A&gt; a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="weak-ptr">weak_ptr</h3><p>在使用智能指针shared_ptr的时候，可能会存在循环引用的问题，例如智能指针a指向智能指针b，智能指针b指向智能指针a。此时两个智能指针的引用计数都不为1，此时存在内存泄露，两个指针指向的内存不会被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;Node&gt; next;<br><br>    <span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node created\n&quot;</span>; &#125;<br><br>    ~<span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_bug_for_shared_ptr</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Node&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>    std::shared_ptr&lt;Node&gt; ptr2 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>    ptr1-&gt;next = ptr2;<br>    ptr2-&gt;next = ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_bug_for_shared_ptr</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br></code></pre></td></tr></table></figure><p><code>weak_ptr</code> 是 C++11 引入的一种智能指针，用于解决 <code>shared_ptr</code> 的循环引用问题。它允许一个对象安全地引用另一个对象，但不会增加引用计数。<br>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;B&gt; b_ptr;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::weak_ptr&lt;A&gt; a_ptr; <span class="hljs-comment">// 使用 weak_ptr 避免循环引用</span><br>    ~<span class="hljs-built_in">B</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建两个对象，避免循环引用</span><br>    &#123;<br>        std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>        std::shared_ptr&lt;B&gt; b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br><br>        <span class="hljs-comment">// A 持有 B 的 shared_ptr</span><br>        a-&gt;b_ptr = b;<br><br>        <span class="hljs-comment">// B 持有 A 的 weak_ptr</span><br>        b-&gt;a_ptr = a;<br><br>        <span class="hljs-comment">// 当作用域结束时，a 和 b 会被正确销毁</span><br>    &#125; <span class="hljs-comment">// 这里不会导致内存泄漏</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> destroyed<br><span class="hljs-selector-tag">B</span> destroyed<br></code></pre></td></tr></table></figure><h2 id="std-any">std::any</h2><p>功能：<br>允许在C++中以类似弱类型语言的方式使用变量。<br>可以存储任何类型的数据，并在需要时进行类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::any x = <span class="hljs-number">114514</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 2</span><br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br>    &#125;<br>    x = <span class="hljs-string">&quot;qwerty&quot;</span>; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 5</span><br>        std::cout &lt;&lt; (*ptr) + <span class="hljs-number">114514</span> &lt;&lt; std::endl; <span class="hljs-comment">// 6</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">114514<br><br></code></pre></td></tr></table></figure><p><code>auto ptr = std::any_cast&lt;int&gt;(&amp;x)</code>会判断ptr是否可以转化为一个int*类型的指针，如果可以就做取地址，如果不可以就变成<code>nullptr</code></p><h2 id="std-optional-and-std-variant">std::optional and std::variant</h2><h3 id="std-optional">std::optional</h3><ul><li>可以存储类型T的值或者什么也不存储（类似于指针，但更安全）。</li><li>用于表示可选值，避免使用裸指针带来的空指针问题。</li></ul><p>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-type">bool</span> returnValue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (returnValue) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 返回空</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 42</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No value&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 42</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No value&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Value:</span> <span class="hljs-number">42</span><br><span class="hljs-literal">No</span> <span class="hljs-string">value</span><br></code></pre></td></tr></table></figure><h3 id="std-variant">std::variant</h3><ul><li>可以存储多种类型的数据（类似于union，但使用起来更方便）。</li><li>用于存储不同类型的数据，并且可以在运行时安全地访问和转换。</li></ul><p>Attach an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 定义一个 std::variant，可以存储 int 或 std::string</span><br><span class="hljs-keyword">using</span> MyVariant = std::variant&lt;<span class="hljs-type">int</span>, std::string&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVariant</span><span class="hljs-params">(<span class="hljs-type">const</span> MyVariant&amp; v)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::visit 访问 std::variant</span><br>    std::<span class="hljs-built_in">visit</span>([](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;, v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 std::variant，初始值为 int</span><br>    MyVariant v1 = <span class="hljs-number">42</span>;<br>    <span class="hljs-built_in">printVariant</span>(v1); <span class="hljs-comment">// 输出: Value: 42</span><br><br>    <span class="hljs-comment">// 修改 std::variant 的值为 std::string</span><br>    v1 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    <span class="hljs-built_in">printVariant</span>(v1); <span class="hljs-comment">// 输出: Value: Hello, World!</span><br><br>    <span class="hljs-comment">// 创建一个 std::variant，初始值为 std::string</span><br>    MyVariant v2 = <span class="hljs-string">&quot;Another string&quot;</span>;<br>    <span class="hljs-built_in">printVariant</span>(v2); <span class="hljs-comment">// 输出: Value: Another string</span><br><br>    <span class="hljs-comment">// 修改 std::variant 的值为 int</span><br>    v2 = <span class="hljs-number">123</span>;<br>    <span class="hljs-built_in">printVariant</span>(v2); <span class="hljs-comment">// 输出: Value: 123</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><ul><li><a href="https://xiyuanyang-code.github.io/posts/Modern-C/">YXY 的Modern Cpp 学习笔记</a></li><li>Kimi AI（发现了kimi的好）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Modern Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic 7 Completeness 1</title>
    <link href="/2025/04/12/Mathematical-Logic7/"/>
    <url>/2025/04/12/Mathematical-Logic7/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：久违的数理逻辑课！上了7节课终于觉得有点入门了，还是挺有意思的。周四下午闪击南京，周五下午又闪击回来。虽然只有1天，但很开心在这短短的20个小时内帮助了不少人（都是无意间）。我要永远做个善良的人！">Before：久违的数理逻辑课！上了7节课终于觉得有点入门了，还是挺有意思的。周四下午闪击南京，周五下午又闪击回来。虽然只有1天，但很开心在这短短的20个小时内帮助了不少人（都是无意间）。我要永远做个善良的人！</h4><h1>Mathematical Logic 7 Completeness 1</h1><p>我们继续完备性的证明！<br>我们知道，要证明一阶逻辑的完备性，我们只需要证明：</p><p>Given a consisitent <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span>,it suffices to construct a term model <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{I}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> = (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">T</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup><mo separator="true">,</mo><msup><mrow><mi>β</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{T}^{\Phi},\mathfrak{\beta}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">T</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class=""><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>) such that:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{I}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> \iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⊢</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>.</p><p>昨晚室友问我为了体现完备性，就是要证明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> 难道不是在说对于任何一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> 上的模型，都能使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>为真吗？但是这里不是只找了一个模型吗？我想这应该是由于<strong>Henkin’s Term Model</strong>的特殊性，但这个留到后几节课再讨论了。</p><h2 id="Henkin’s-Term-Model-Recall-模型回顾">Henkin’s Term Model Recall 模型回顾</h2><p>首先引入等价类的概念：<br>Let $ t_1,t_2 $ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>.Then $ t_1 $ ~ $ t_2 $ if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⊢</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1\equiv t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≡</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>.</p><p>For every t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> we define:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>t</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.81508em;"></span><span class="strut bottom" style="height:0.81508em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> := {t’ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |t’ ~ t}</p><p><strong>Definition</strong><br>The term structure for (\Phi), denoted by (\mathfrak{I}^{\Phi}), is defined as follows.</p><ol><li><p><strong>Universe</strong>:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mrow><mi mathvariant="normal">Φ</mi></mrow></msup><mo>:</mo><mo>=</mo><mo>{</mo><mover accent="true"><mrow><mi>t</mi></mrow><mo stretchy="true">‾</mo></mover><mo>∣</mo><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup><mo>}</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">T^{\Phi} := \{\overline{t} \mid t \in T^S\}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">{</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mrel">∣</span><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Relation symbols</strong>:<br>For every \(n\)-ary relation symbol \(R \in S\), and \(\overline{t_1}, \ldots, \overline{t_n} \in T^{\Phi}\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mover accent="true"><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo><mo>∈</mo><msup><mi>R</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mspace width="1em"></mspace><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi></mtext><mspace width="1em"></mspace><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>R</mi><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(\overline{t_1}, \ldots, \overline{t_n}) \in R^{\mathfrak{I}^{\Phi}} \quad \text{if} \quad \Phi \vdash R t_1 \ldots t_n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:1.2087649999999999em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mspace quad"></span><span class="text mord textstyle uncramped"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span></span><span class="mord mspace quad"></span><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Function symbols</strong>:<br>For every \(n\)-ary function symbol \(f \in S\), and \(\overline{t_1}, \ldots, \overline{t_n} \in T^{\Phi}\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mo>(</mo><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mover accent="true"><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo><mo>:</mo><mo>=</mo><mi>f</mi><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo>⋯</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f^{\mathfrak{I}^{\Phi}} (\overline{t_1}, \ldots, \overline{t_n}) := f \overline{t_1} \cdots t_n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:1.2087649999999999em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">:</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="minner">⋯</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Constants</strong>:<br>For every constant \(c \in S\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mo>:</mo><mo>=</mo><mover accent="true"><mrow><mi>c</mi></mrow><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">c^{\mathfrak{I}^{\Phi}} := \overline{c}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:0.9587649999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">:</span><span class="mrel">=</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">c</span></span></span><span style="top:-0.5505599999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li></ol><p>For every variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,we let:<br>\mathfrak{\beta}^{\Phi}\(v_i\) := <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{v_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.63056em;"></span><span class="strut bottom" style="height:0.78056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.5505599999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span></p><h2 id="对于原子公式成立-atomic-varphi">对于原子公式成立 atomic <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span></h2><p><strong>Lemma 5</strong></p><p>(i) For any \( t \in T^S \),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>(</mo><mi>t</mi><mo>)</mo><mo>=</mo><mover accent="true"><mrow><mi>t</mi></mrow><mo>¯</mo></mover><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi(t) = \bar{t}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.18407999999999997em;margin-left:0.16668em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p><p>(ii) For every atomic \(\varphi\),<br>\mathfrak{I}^\Phi \models \varphi \iff \Phi \vdash \varphi.</p><p>(i)的证明，我们<strong>对项t进行归纳</strong>：</p><ul><li>t = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is a variable</li><li>t = c is a constant</li><li>t = f<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_1...t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li></ul><p>根据定义可证</p><p>(ii)的证明，对2个原子公式进行分类讨论：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><msub><mi>t</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models t_1 \equiv t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≡</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>R</mi><msub><mi>t</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models Rt_1...t_n    </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br>利用(i)中所证，可证</p><h2 id="Consistent-Negation-Complete-Contains-Witness">Consistent,Negation Complete,Contains Witness</h2><h3 id="Lemma-8">Lemma 8</h3><p>先看一个引理：</p><h1>Lemma 8</h1><p>Let (\varphi) be an (S)-formula and (x_1, \ldots, x_n) pairwise distinct variables. Then</p><h3 id="i">(i)</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi mathvariant="normal">∃</mi><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><mi mathvariant="normal">∃</mi><msub><mi>x</mi><mi>n</mi></msub><mi>φ</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \exists x_1 \ldots \exists x_n \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathrm">∃</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord mathrm">∃</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">φ</span></span></span></span><br><strong>if and only if</strong> there are (S)-terms (t_1, \ldots, t_n) such that<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>φ</mi><mfrac><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \varphi \frac{t_1 \ldots t_n}{x_1 \ldots x_n}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8455559999999999em;"></span><span class="strut bottom" style="height:1.295556em;vertical-align:-0.44999999999999996em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.4149999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mathrm">.</span></span></span></span></p><h3 id="ii">(ii)</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi mathvariant="normal">∀</mi><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><mi mathvariant="normal">∀</mi><msub><mi>x</mi><mi>n</mi></msub><mi>φ</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \forall x_1 \ldots \forall x_n \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathrm">∀</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord mathrm">∀</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">φ</span></span></span></span><br><strong>if and only if</strong> for all (S)-terms (t_1, \ldots, t_n) we have<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>φ</mi><mfrac><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \varphi \frac{t_1 \ldots t_n}{x_1 \ldots x_n}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8455559999999999em;"></span><span class="strut bottom" style="height:1.295556em;vertical-align:-0.44999999999999996em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.4149999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mathrm">.</span></span></span></span></p><p>由替换引理等可证</p><h3 id="Consistent">Consistent</h3><p><strong>Definition</strong><br><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is consistent if there is no <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> such that both <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> ⊢ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> ⊢ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>. Otherwise,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is inconsistent.</strong></p><h3 id="Negation-Complete">Negation Complete</h3><p><strong>Definition</strong><br>A set (\Phi) is <em>negation complete</em> if for every (S)-formula (\varphi):<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi><mtext><mtext> </mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mtext> </mtext></mtext><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">¬</mi><mi>φ</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi \text{ or } \Phi \vdash \neg \varphi.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mspace"> </span></span><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">¬</span><span class="mord mathit">φ</span><span class="mord mathrm">.</span></span></span></span></p><p>通俗的说，就是如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> 证不出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>，那就一定能证出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span>；证不出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span>，那就一定能证出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span></p><h3 id="Contains-Witness">Contains Witness</h3><h1>Definition</h1><p>🔍 A set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <strong>contains witnesses</strong> if for every <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>∈</mo><msup><mi>L</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">\varphi \in L^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> and every variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>, there exists a term <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">t \in T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> such that:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mrow><mo fence="true">(</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mi>φ</mi><mo>→</mo><mi>φ</mi><mfrac><mrow><mi>t</mi></mrow><mrow><mi>x</mi></mrow></mfrac><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \left( \exists x \varphi \to \varphi \frac{t}{x} \right).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathrm">∃</span><span class="mord mathit">x</span><span class="mord mathit">φ</span><span class="mrel">→</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord mathrm">.</span></span></span></span></p><h2 id="Henkin’s-Theorem-Proof">Henkin’s Theorem Proof</h2><p>First,还是先来证明一个引理：</p><h3 id="Lemma-9">Lemma 9</h3><p>Assume that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is <strong>consistent</strong>, <strong>negation complete</strong>, and <strong>contains witnesses</strong>. Then for all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>-formulas <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span></span></span></span>:</p><p>(i)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span></span></span></span> if and only if \Phi \not\vdash \neg \varphi.</p><p>(ii)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mo>(</mo><mi>φ</mi><mo>∨</mo><mi>ψ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Phi \vdash (\varphi \vee \psi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mopen">(</span><span class="mord mathit">φ</span><span class="mbin">∨</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mclose">)</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span></span></span></span>.</p><p>(iii)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \exists x \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">∃</span><span class="mord mathit">x</span><span class="mord mathit">φ</span></span></span></span> if and only if there is a term <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">t \in T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi><mfrac><mrow><mi>t</mi></mrow><mrow><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi \frac{t}{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>.</p><p>(i)向右通过consistent定义说明，向左通过negation complete定义说明<br>(ii)向左利用V-intro by succedent证明，向右证明如下：<br>Assume that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span><br><strong>Proof Steps:</strong><br><img src="/img/Lemma9.png" alt="Lemma 9(ii)Proof"></p><p>(iii)向右可通过Modus ponens证明，向左可通过\exist-intro in succedent证明</p><h3 id="Henkin’s-Theorem">Henkin’s Theorem</h3><p>由引理证明起来还是比较显然的：<br><img src="/img/Henkin.png" alt="Henkin's Theorem Proof"></p><p>注意，这里对公式的归纳是对公式的<strong>connective rank</strong>归纳，保证要证的公式都更长：<br><strong>Rank Definition:</strong><br>rk(\varphi) := \begin{cases} 0 & \text{if } \varphi \text{ is atomic,} \1 + rk(\psi) & \text{if } \varphi = \neg\psi, \1 + rk(\psi_1) + rk(\psi_2) & \text{if } \varphi = (\psi_1 \lor \psi_2), \1 + rk(\psi) & \text{if } \varphi = \exists x \psi. \end{cases}</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 8 Sorting</title>
    <link href="/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%848/"/>
    <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%848/</url>
    
    <content type="html"><![CDATA[<h4 id="Before-第10章排序并未提前进行学习，所以会结合翁阿姨上课的笔记和课后学习，内容比较完善">Before:第10章排序并未提前进行学习，所以会结合翁阿姨上课的笔记和课后学习，内容比较完善</h4><h1>数据结构 8 排序</h1><p><strong>所谓排序就是把集合中的数据元素按照它们的关键字的非递减或非递增序排成一个序列。</strong></p><h2 id="插入排序">插入排序</h2><p>首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的n-1个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的。</p><p>插入排序又分为：</p><h3 id="直接插入排序">直接插入排序</h3><p>暴力插入，复杂度O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</p><h3 id="折半插入排序">折半插入排序</h3><p>利用二分查找法，快速地找到a[j]的插入位置，但这只会减少比较次数，并不会改变元素的移动，所以复杂度还是O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</p><h3 id="希尔排序-缩小增量排序法">希尔排序 缩小增量排序法</h3><p>1.将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）；<br>2.对这些子序列进行插入排序；<br>3.减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 1。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> KEY,<span class="hljs-keyword">class</span> OTHER&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(SET&lt;KEY,OTHER&gt;a[],<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-type">int</span> step;<br>    <span class="hljs-type">int</span> i,j;<br>    SET&lt;KEY,OTHER&gt; tmp;<br>    <span class="hljs-keyword">for</span>(step = size/<span class="hljs-number">2</span>;step &gt; <span class="hljs-number">0</span>;step /= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">//希尔增量</span><br>        <span class="hljs-keyword">for</span>(i = step;i &lt; size;i ++)&#123;<br>            tmp = a[i];<br>            <span class="hljs-keyword">for</span>(j = i - step;a[j].KEY &gt; tmp.KEY;j -= step)&#123;<br>                a[j + step] = a[j];<br>            &#125;<br>            a[j + step] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序">选择排序</h2><p>首先，从n个元素中选出关键字最小的元素。再从剩下的(n-1)个元素中选出关键字最小的元素，依次类推，每次从剩下的元素序列中挑出关键字最小的元素，直至序列中最后只剩下一个元素为止。</p><h3 id="直接选择排序">直接选择排序</h3><p>暴力，复杂度O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)(<strong>不能存在最好最坏情况，必须全做</strong>)</p><h3 id="堆排序-HeapSort！">堆排序 <strong>HeapSort！</strong></h3><p>建堆复杂度：O(N) （we’ve already proved this in <strong>priority_queue</strong>）<br>出队操作：O(logN)<br>总时间复杂度：n次出队O(nlogn)</p><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序（数据本就比较有序）">冒泡排序（数据本就比较有序）</h3><p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡。</p><h3 id="快速排序（数据比较杂乱）">快速排序（数据比较杂乱）</h3><p>在待排序的序列中选择一个数据元素，以该元素为标准，将所有数据元素分为两组，第一组的元素均小于或等于标准元素，第二组的数据元素均大于标准元素。第一组的元素放在数组的前面部分，第二组的数据元素放在数组的后面部分，标准元素放在中间。这个位置就是标准元素的最终位置。这称为一趟划分。然后对分成的两组数据重复上述过程，直到所有的元素都在适当的位置为止。</p><p>我觉得我们有必要回忆一下快排是怎么写的😅</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">divide</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt; <span class="hljs-symbol">a</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">low,<span class="hljs-symbol">int</span></span> <span class="hljs-symbol">high</span>)&#123;<br>    SET&lt;KEY,OTHER&gt; tmp = a[low];<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; a[high].KEY &gt;= tmp.KEY)&#123;<br>            high --;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>            a[low] = a[high];<br>            ++ low;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; a[low].KEY &lt;= tmp.KEY)&#123;<br>            low ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>            a[high] = a[low];<br>            high --;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(low != high);<br>    a[low] = tmp;<br>    <span class="hljs-keyword">return</span> low;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">quick_sort</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt; <span class="hljs-symbol">a</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">low,<span class="hljs-symbol">int</span></span> <span class="hljs-symbol">high</span>)&#123;<br>    <span class="hljs-built_in">int</span> mid;<br>    <span class="hljs-keyword">if</span>(low &gt;= high)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    mid = divide(a,low,high);<br>    quick_sort(a,low,mid - <span class="hljs-number">1</span>);<br>    quick_sort(a,mid + <span class="hljs-number">1</span>,high);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">quicksort</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt; <span class="hljs-symbol">a</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size</span>)&#123;<br>    quick_sort(a,<span class="hljs-number">0</span>,size - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>快速排序的性能分析</strong>：（递归函数时间性能分析）<br>T(N) = T(i) + T(N - i - 1) + c(N)<br>T(0) = T(1) = 1</p><p><strong>快排的最坏情况</strong>：选择的元素最大or最小<br>T(N) = T(N - 1) +  c(N)<br>T(N - 1) = T(N - 2) + c(N - 1)<br>…<br>T(2) = T(1) + c(2)</p><p>T(N) = T(1) + c(2 + 3 + … + N) = O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</p><p><strong>快排的最好情况</strong>：分成等长的2段<br>T(N) = 2T(N/2) + cN<br>将等式两边同时除N，可得：<br>T(N)/N = T(N/2)/(N/2) + c<br>T(N/2)/(N/2) = T(N/4)/(N/4) + c<br>…<br>T(2)/2 = T(1)/1 + c</p><p>即：T(N) = cnlogn + n = O(nlogn)</p><p><strong>平均情况分析</strong>：<br>T(N) = 2(T(0) + … + T(N - 1))/N + cN<br>经过数列计算可得：T(N) = O(nlogn)</p><h2 id="归并排序">归并排序</h2><p>很熟悉了，直接贴板子</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void merge(const int <span class="hljs-number">*aBe</span>gin, const int <span class="hljs-number">*aE</span>nd, const int <span class="hljs-number">*bBe</span>gin,<br>           const int <span class="hljs-number">*bE</span>nd, int <span class="hljs-number">*c</span>) &#123;<br>  <span class="hljs-keyword">while</span> (aBegin != aEnd &amp;&amp; bBegin != bEnd) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">*bBe</span>gin &lt; <span class="hljs-number">*aBe</span>gin) &#123;<br>      <span class="hljs-number">*c</span> = <span class="hljs-number">*bBe</span>gin;<br>      ++bBegin;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-number">*c</span> = <span class="hljs-number">*aBe</span>gin;<br>      ++aBegin;<br>    &#125;<br>    ++c;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (; aBegin != aEnd; ++aBegin, ++c) <span class="hljs-number">*c</span> = <span class="hljs-number">*aBe</span>gin;<br>  <span class="hljs-keyword">for</span> (; bBegin != bEnd; ++bBegin, ++c) <span class="hljs-number">*c</span> = <span class="hljs-number">*bBe</span>gin;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 分解</span><br>  <span class="hljs-type">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">merge_sort</span>(a, l, mid), <span class="hljs-built_in">merge_sort</span>(a, mid, r);<br>  <span class="hljs-comment">// 合并</span><br>  <span class="hljs-type">int</span> tmp[<span class="hljs-number">1024</span>] = &#123;&#125;;  <span class="hljs-comment">// 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用</span><br>                       <span class="hljs-comment">// vector；先将合并的结果放在 tmp 里，再返回到数组 a</span><br>  <span class="hljs-built_in">merge</span>(a + l, a + mid, a + mid, a + r, tmp + l);  <span class="hljs-comment">// pointer-style merge</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; r; ++i) a[i] = tmp[i];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序">基数排序</h2><p>感觉基数排序很有意思：以排序十进制非负整数为例，可设置10个口袋：</p><ul><li>首先将元素按个位数分别放入十个口袋，然后将每个口袋中的元素倒出来</li><li>按元素的十位数分别放入十个口袋。然后把它们倒出来</li><li>再按百位数分配</li><li>到最后一次倒出来时，元素就已经排好了序</li></ul><p>Example:<br><img src="/img/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="基数排序例子"></p><p>我们可以用单链表来实现：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">template<span class="hljs-tag">&lt;class OTHER&gt;</span><br>struct <span class="hljs-keyword">node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">    SET</span><span class="hljs-tag">&lt;int,OTHER&gt;</span> data;<br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*next</span>;<br>    <span class="hljs-keyword">node</span><span class="hljs-title">()&#123;</span><br><span class="hljs-title">        next</span> = nullptr;<br>    &#125;<br>    <span class="hljs-keyword">node</span><span class="hljs-title">(SET</span><span class="hljs-tag">&lt;int,OTHER&gt;</span> d):data(d)&#123;<br>        next = nullptr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OTHER</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">bucketSort</span>(<span class="hljs-title">node</span>&lt;<span class="hljs-title">OTHER</span>&gt;* &amp;<span class="hljs-title">p</span>)</span>&#123;<br>    node&lt;OTHER&gt; *bucket[<span class="hljs-number">10</span>];<br>    node&lt;OTHER&gt; *<span class="hljs-keyword">last</span>[<span class="hljs-number">10</span>];<br>    node&lt;OTHER&gt; *tail;<br>    node&lt;OTHER&gt; *tmp = p;<br>    <span class="hljs-keyword">int</span> maxNum = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(tmp != nullptr)&#123;<br>        <span class="hljs-keyword">if</span>(tmp -&gt; data.key &gt; maxNum)&#123;<br>            maxNum = tmp -&gt; data.key;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(maxNum &gt; <span class="hljs-number">0</span>)&#123;<br>        maxNum /= <span class="hljs-number">10</span>;<br>        ++ len;<br>    &#125;<br>    <span class="hljs-keyword">int</span> base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= len;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= <span class="hljs-number">9</span>;j ++)&#123;<br>            bucket[j] = nullptr;<br>            <span class="hljs-keyword">last</span>[j] = nullptr;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p != nullptr)&#123;<br>            <span class="hljs-keyword">int</span> k = (p -&gt; data.key / base) % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(bucket[k] != nullptr)&#123;<br>                <span class="hljs-keyword">last</span>[k] -&gt; <span class="hljs-keyword">next</span> = p;<br>                <span class="hljs-keyword">last</span>[k] = <span class="hljs-keyword">last</span>[k] -&gt; <span class="hljs-keyword">next</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                bucket[k] = p;<br>                <span class="hljs-keyword">last</span>[k] = p;<br>            &#125;<br>        &#125;<br>        p = nullptr;<span class="hljs-regexp">//</span>置空链表头<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= <span class="hljs-number">9</span>;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(bucket[j] != nullptr)&#123;<br>                <span class="hljs-keyword">if</span>(p == nullptr)&#123;<br>                    p = bucket[j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    tail -&gt; <span class="hljs-keyword">next</span> = <span class="hljs-keyword">last</span>[j];<br>                &#125;<br>                tail = <span class="hljs-keyword">last</span>[j];<br>            &#125;<br>        &#125;<br>        base *= <span class="hljs-number">10</span>;<br>        tail -&gt; <span class="hljs-keyword">next</span> = nullptr;<span class="hljs-regexp">//</span>！！别忘了置空！！<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusion">Conclusion</h2><p>感觉JaneZ现在是排序大师了bushi😄😄😄</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Time and Space Complexity</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust RefCell机制</title>
    <link href="/2025/04/07/Rust-RefCell%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/07/Rust-RefCell%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：为什么要出一期挺莫名其妙的东西？起因还是机考，连续2次机考工程题一分没拿了（太菜了bushi），感觉对C-的各种机制很不熟悉，而Rust又是重要的一门现代编程语言。援引StanfordCS110L前言的一段话：">Before：为什么要出一期挺莫名其妙的东西？起因还是机考，连续2次机考工程题一分没拿了（太菜了bushi），感觉对C++的各种机制很不熟悉，而Rust又是重要的一门现代编程语言。援引<a href="https://reberhardt.com/cs110l/spring-2020/">StanfordCS110L</a>前言的一段话：</h4><h5 id="如果你学过-C-并接触过一些系统编程的话，应该对-C-的内存泄漏以及指针的危险有所耳闻，但-C-的底层特性以及高效仍然让它在系统级编程中无法被例如-Java-等自带垃圾收集机制的高级语言所替代。而-Rust-的目标则是希望在-C-的高效基础上，弥补其安全不足的缺点。因此-Rust-在设计之初，就有带有很多系统编程的观点。学习-Rust，也能让你之后能用-C-语言编写出更安全更优雅的系统级代码（例如操作系统等）。"><em>如果你学过 C 并接触过一些系统编程的话，应该对 C 的内存泄漏以及指针的危险有所耳闻，但 C 的底层特性以及高效仍然让它在系统级编程中无法被例如 Java 等自带垃圾收集机制的高级语言所替代。而 Rust 的目标则是希望在 C 的高效基础上，弥补其安全不足的缺点。因此 Rust 在设计之初，就有带有很多系统编程的观点。学习 Rust，也能让你之后能用 C 语言编写出更安全更优雅的系统级代码（例如操作系统等）。</em></h5><h1>Rust Learning _RefCell机制</h1><h2 id="Rust的所有权机制">Rust的所有权机制</h2><p>Rust的所有权机制要求每个值都有<strong>唯一的所有者</strong>（通常是变量），并且在同一时间内只能有一个所有者。所有权的转移可以通过赋值、函数参数传递或返回值来实现。相当于 C++ 中的移动语义（std::move()）</p><p>在一个值的所有者变量的作用域之外（例如在另外一个函数中）对该值的访问必须通过借用（相当于 C++ 中指向变量的指针）来实现。Rust 中的借用分为两种：</p><ul class="lvl-0"><li class="lvl-2"><p>不可变借用（Immutable Borrow）：相当于 C++ 中的 const T*，允许读取但不允许修改</p></li><li class="lvl-2"><p>可变借用（Mutable Borrow）：相当于 C++ 中的 T*，允许读取和修改</p></li></ul><p>Rust 对变量的借用有着严格的限制：</p><ul class="lvl-0"><li class="lvl-2"><p>在同一时间内，只能有<strong>一个可变借用，或者多个不可变借用</strong></p></li><li class="lvl-2"><p><strong>不能同时存在可变借用和不可变借用</strong></p></li><li class="lvl-2"><p>所有借用都必须在拥有变量的生命周期内有效，对以上规则的违反会导致编译错误。</p></li></ul><p>Rust 的借用机制对编译器优化非常有帮助。由于不可变借用不能与可变借用共存，**被不可变借用指向的值只需要从堆内存中获取一次，之后可以安全地存储在寄存器或栈上缓存中。*<em>相比之下，C++ 中也进行类似的优化，但其他函数修改 const</em> 指针指向的值是未定义行为，可能导致不安全的代码。</p><p>Rust 的编译器可以在编译时就能“静态”地检查所有权和借用关系，在运行时无需额外检查。然而，<strong>对于堆上对象，在编译期检查所有权和借用关系是非常困难的</strong>。因此，Rust 提供了 RefCell<T> 类型来在运行时检查所有权和借用关系。它有如下方法：</p><ul class="lvl-0"><li class="lvl-2"><p>borrow() 与 try_borrow()：获取一个不可变借用，返回 Ref<T> 类型。如果当前存在可变借用则失败。borrow() 会 panic，相当于 C++ 中的 abort，而 try_borrow() 返回一个 Result&lt;Ref<T>, BorrowError&gt;，相当于 C++ 中的 std::optional&lt;Ref<T>&gt;</p></li><li class="lvl-2"><p>borrow_mut() 与 try_borrow_mut()：获取一个可变借用，返回 RefMut<T> 类型。如果当前存在任何借用则会失败</p></li><li class="lvl-2"><p>返回的 Ref<T> 和 RefMut<T> 包装器实现了解引用操作符，可以像使用普通引用一样使用</p></li><li class="lvl-2"><p>当 Ref<T> 和 RefMut<T> 的生命周期结束时，会自动减少或重置借用计数</p></li><li class="lvl-2"><p>当 RefCell<T> 的生命周期结束时，若仍有借用存在，则会 panic</p></li></ul><h2 id="C-中的std-optional">C++中的std::optional</h2><p>编程中，我们经常会需要表示或处理一个“可能为空”的变量，可能是一个为包含任何元素的容器，可能是一个类型的指针没有指向任何有效的对象实例，再或者是一个对象没有被赋予有效的值。</p><p>C++17中的std::optional<T>为解决这类问题提供了简单的解决方案。optional<T>可以看作是T类型变脸与一个布尔值的打包。其中的布尔值用来表示T是否为“空”。<br>std::optional<T>可以：<strong>包含一个类型为T的值或者不包含任何值(处于&quot;空&quot;状态)</strong><br>不包含任何值显示表示为：std::nullopt</p><p>Advantage: 明确表示值可能存在或不存在；强制使用者考虑值缺失的情况；通常比使用指针或额外标志更高效</p><h2 id="C-中的const-成员函数">C++中的const 成员函数</h2><p><strong>在C++中，只有被声明为const的成员函数才能被一个const类对象调用。</strong><br>const 成员函数<strong>不能修改类的普通成员变量</strong><br>如果想修改，需加上mutable关键字，允许 const 成员函数修改内部计数器（确实这个关键字常见于计数器）</p><h2 id="剩余代码的实现">剩余代码的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCellError</span> : <span class="hljs-keyword">public</span> std::runtime_error &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCellError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : std::runtime_error(message) &#123;</span>&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RefCellError</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<span class="hljs-comment">// Abstract class as base class</span><br><br><span class="hljs-comment">//invalidly call an immutable borrow</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><span class="hljs-comment">//invalidly call a mutable borrow</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowMutError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowMutError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><span class="hljs-comment">//still has refs when destructed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructionError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DestructionError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCell</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>    <span class="hljs-comment">// TODO(student)</span><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_num;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_mut_num;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Forward declarations</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span>;<br><br>    <span class="hljs-comment">// Constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; initial_value)</span>:value(initial_value),borrow_mut_num(<span class="hljs-number">0</span>),borrow_num(<span class="hljs-number">0</span>) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(T &amp;&amp; initial_value)</span>:value(std::move(initial_value)),borrow_mut_num(<span class="hljs-number">0</span>),borrow_num(<span class="hljs-number">0</span>) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// Disable copying and moving for simplicity</span><br>    <span class="hljs-built_in">RefCell</span>(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">RefCell</span>(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// Borrow methods</span><br>    <span class="hljs-function">Ref <span class="hljs-title">borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        ++ borrow_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;Ref&gt; <span class="hljs-title">try_borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        ++ borrow_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">RefMut <span class="hljs-title">borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        ++ borrow_mut_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;RefMut&gt; <span class="hljs-title">try_borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        ++ borrow_mut_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Inner classes for borrows</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-type">const</span> RefCell* refcell;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Ref</span>(<span class="hljs-type">const</span> RefCell &amp;c):<span class="hljs-built_in">refcell</span>(&amp;c),<span class="hljs-built_in">valid</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br><br>        ~<span class="hljs-built_in">Ref</span>() &#123;<br>            <span class="hljs-keyword">if</span>(valid ) &#123;<br>                -- refcell-&gt;borrow_num;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-comment">// Allow copying</span><br>        <span class="hljs-built_in">Ref</span>(<span class="hljs-type">const</span> Ref&amp; other):<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            <span class="hljs-keyword">if</span>(valid)&#123;<br>                ++ refcell-&gt;borrow_num;<br>            &#125;<br>        &#125;<br>        Ref&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Ref&amp; other) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span>(valid) &#123;<br>                    -- refcell-&gt;borrow_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = other.valid;<br>                <span class="hljs-keyword">if</span>(valid)&#123;<br>                    ++ refcell-&gt;borrow_num;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Allow moving</span><br>        <span class="hljs-built_in">Ref</span>(Ref&amp;&amp; other) <span class="hljs-keyword">noexcept</span>:<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            <span class="hljs-comment">//TODO</span><br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Ref&amp; <span class="hljs-keyword">operator</span>=(Ref&amp;&amp; other) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    --refcell-&gt;borrow_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = <span class="hljs-literal">true</span>;<br>                other.valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//other = nullptr;</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// TODO(student)</span><br>        RefCell* refcell;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">RefMut</span>(RefCell &amp;c):<span class="hljs-built_in">refcell</span>(&amp;c),<span class="hljs-built_in">valid</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br><br>        ~<span class="hljs-built_in">RefMut</span>() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(valid ) &#123;<br>                -- refcell-&gt;borrow_mut_num;<br>            &#125;<br>        &#125;<br><br>        T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_mut_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> refcell-&gt;value;<br>        &#125;<br><br>        T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_mut_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-comment">// Disable copying to ensure correct borrow rules</span><br>        <span class="hljs-built_in">RefMut</span>(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br><br>        <span class="hljs-comment">// Allow moving</span><br>        <span class="hljs-built_in">RefMut</span>(RefMut&amp;&amp; other) <span class="hljs-keyword">noexcept</span>:<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid)  &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(RefMut&amp;&amp; other) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    --refcell-&gt;borrow_mut_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = other.valid;<br>                other.valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//other = nullptr;</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor</span><br>    ~<span class="hljs-built_in">RefCell</span>() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num &gt; <span class="hljs-number">0</span> || borrow_num &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DestructionError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        borrow_mut_num = <span class="hljs-number">0</span>;<br>        borrow_num = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2641">stargazer 的 RefCell</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/hhdshg/article/details/103433781">C++17之std::optional全方位详解</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Rust</tag>
      
      <tag>Const</tag>
      
      <tag>Memory Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构7</title>
    <link href="/2025/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%847/"/>
    <url>/2025/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%847/</url>
    
    <content type="html"><![CDATA[<h1>数据结构 7 伸展树 哈希表</h1><h2 id="平衡树的缺陷">平衡树的缺陷</h2><p>插入删除代价大，易出错没有利用 90 - 10 规则：百分之90的访问都是针对百分之10的数据</p><h2 id="伸展树的概念">伸展树的概念</h2><p>基本思想：让10%经常访问的数据靠近根结点基本方法：在每个结点被访问后，通过一些旋转（单）使它向根移动</p><p>但是很不幸，基本方法很容易导致树退化成单链表，这是因为单链表并不保证树高度的降低，但双旋转可以。于是我们分下面3种情况访问：</p><ul class="lvl-0"><li class="lvl-2"><p>zig 父结点为根结点：向根做一次单旋转</p></li><li class="lvl-2"><p>zig-zag X在祖父结点内侧：LR or RL</p></li><li class="lvl-2"><p>zig-zig X在祖父结点外侧：LL or RR</p></li></ul><h2 id="哈希表">哈希表</h2><p>直接根据所求结点的关键字值 KEY 找到这个结点。</p><h3 id="直接地址法">直接地址法</h3><h3 id="除留余数法">除留余数法</h3><p>H(key) = key MOD p(p 是数组大小)<br>p最好为质数，函数值分布更均匀</p><h3 id="数字分析法">数字分析法</h3><p>取数字分布均匀的位作为地址的组成部分</p><h3 id="平方取中法">平方取中法</h3><p>将关键字平方后，取其结果的中间各位作为散列函数值</p><h3 id="折叠法">折叠法</h3><p>选取一个长度后，将关键字按此长度分组相加</p><h2 id="哈希冲突问题">哈希冲突问题</h2><h3 id="闭散列表">闭散列表</h3><ul class="lvl-0"><li class="lvl-2"><p>线性探测法（哈希后暴力遍历直至空）Simple<br>我们还需要一个函数指针，把小数转化为整数还需额外增设一个信息，以判断是否是《曾经有过但现在已经被删除了》一段时间后，所有数组元素都变为active or deleted，所有操作的时间性能都是O(N)的（可以进行一个整理，把该删的删了，另外，最好保证表长是素数）</p></li><li class="lvl-2"><p>二次探测法当发生冲突时，下一个探测单元是：k+1,k+4,k+9…<br>Conclusion:如果表长为素数，且表至少有一半是空的，则新元素一定可以被插入<br><strong>负载因子</strong>要小于0.5</p></li><li class="lvl-2"><p>再次散列法地址为 Hi = H0 + i * Hash(x)</p></li></ul><h3 id="开散列表">开散列表</h3><p>相当于是Linked Hash Map</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Hash Table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Of DS——Fenwick Tree &amp; Sparse Table</title>
    <link href="/2025/04/05/AlgorithmOfDS2/"/>
    <url>/2025/04/05/AlgorithmOfDS2/</url>
    
    <content type="html"><![CDATA[<h4 id="before20250329must-be-one-of-the-best-days-in-2025i-cant-tell-you-why-and-i-beg-you-dont-ask-me-whyi-just-hope-to-be-like-her-and-continue-chasing-after-my-dreamjust-like-her-and-themwhatever-it-takesi-just-cant-help-being-excited-about-this-wonderful-meeting-in-xuhuishanghai-hope-everything-will-be-alright"><a class="markdownIt-Anchor" href="#before20250329must-be-one-of-the-best-days-in-2025i-cant-tell-you-why-and-i-beg-you-dont-ask-me-whyi-just-hope-to-be-like-her-and-continue-chasing-after-my-dreamjust-like-her-and-themwhatever-it-takesi-just-cant-help-being-excited-about-this-wonderful-meeting-in-xuhuishanghai-hope-everything-will-be-alright"></a> Before：2025.03.29，must be one of the best days in 2025.I can’t tell you why and I beg you don’t ask me why.I just hope to be like her and continue chasing after my dream,just like her and them.Whatever it takes.I just can’t help being excited about this wonderful meeting in Xuhui,Shanghai. Hope everything will be alright.</h4><p><img src="/img/xuhui.jpg" alt="2025.03.29晚-徐家汇-上海" /></p><h1 id="algorithm-of-ds-2-fenwick-tree-and-sparse-table"><a class="markdownIt-Anchor" href="#algorithm-of-ds-2-fenwick-tree-and-sparse-table"></a> Algorithm of DS 2 Fenwick Tree and Sparse Table</h1><h1 id="fenwick-tree-树状数组"><a class="markdownIt-Anchor" href="#fenwick-tree-树状数组"></a> Fenwick Tree 树状数组</h1><p>一点点feeling：1~base在算法题里还是很香的😢</p><h2 id="单点修改与区间查询"><a class="markdownIt-Anchor" href="#单点修改与区间查询"></a> 单点修改与区间查询</h2><p>对于序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,...,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>我们要支持一下操作：<br />（1）单点修改其中某个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />（2）查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>A problem we first met in the <strong>Chunking</strong> with a time complexity of O(n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>).（上机课上助教反复说过，可以用《线段树和树状数组解决》）所以要介绍的就是《<strong>树状数组</strong>》来解决这个经典问题。</p><p>如下图所示，就展示了一个树状数组求解前缀和的很好的例子：<br /><img src="/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" alt="树状数组" /></p><p>首先我们介绍树状数组中的<strong>预处理函数</strong>——lowbit函数！</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<span class="hljs-comment">//有时可能需要开成long long int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不难知道，这其实是x二进制表示下从右往左第一个出现1的位置。<br />每一个树状数组c[x]管辖的范围其实是：[x - lowbit(x) + 1,x]<br />为求得前缀和，每次回退lowbit(x)，得到新的x（新的起点）。如此往复，直到x = 0，代码实现如下：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml">int query(int <span class="hljs-variable language_">x</span>)&#123;<br>    int ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">x</span> &gt; <span class="hljs-number">0</span>)&#123;<br>        ans += c[<span class="hljs-variable language_">x</span>];<br>        <span class="hljs-variable language_">x</span> -= lowbit(<span class="hljs-variable language_">x</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我需要得到区间[x,y]之间的和，则：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">return <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>而对于更新操作，我们需要对第x位后包括x的所有树状数组的和进行加w的操作，相当于是一个逆过程：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-type">void</span> update(int <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span>int w)&#123;<br>    while(<span class="hljs-keyword">x</span> &lt;<span class="hljs-operator">=</span> n)&#123;<br>        <span class="hljs-keyword">c</span>[<span class="hljs-keyword">x</span>] +<span class="hljs-operator">=</span> w<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">x</span> +<span class="hljs-operator">=</span> lowbit(<span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间修改和单点查询"><a class="markdownIt-Anchor" href="#区间修改和单点查询"></a> 区间修改和单点查询</h2><p>似乎略有变化，实则并无变化，只是我们维护的树状数组c[x]是对于差分数组的。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">d<span class="hljs-comment">[i]</span> = a<span class="hljs-comment">[i]</span> - a<span class="hljs-comment">[i-1]</span>;<br></code></pre></td></tr></table></figure><p>查询操作很简单，就是对差分数组求一个前缀和，函数实现一模一样。<br />如果要对某一区间[x,y]内的所有数进行一个 + w的操作，观察到，当i <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> [x + 1,y]时，d[i]不会发生变化，我们只需要修改首尾两处的d[i]即可，进行操作:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">update</span>(x,w);<br><span class="hljs-built_in">update</span>(y + <span class="hljs-number">1</span>,-w);<br></code></pre></td></tr></table></figure><h2 id="区间修改与区间查询"><a class="markdownIt-Anchor" href="#区间修改与区间查询"></a> 区间修改与区间查询</h2><p>又有了一些小变化，不妨列出来看一看：<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} \Sigma_{j = 1}^{i} d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span><br />= k * d[1] + (k - 1) * d[2] + … + 1 * d[k]<br />= (k + 1) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>i</mi><mo>∗</mo><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} i * d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></p><p>可见事实上我们只需要再多维护一个id[i]的树状数组就可以了(in fact 是这次小作业的某一题)，召唤术：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2665">区间修改与查找</a><br />hint：校外用户对不住了，ACMOJ只对sjtu内部开放😢😢</p><h2 id="二维树状数组"><a class="markdownIt-Anchor" href="#二维树状数组"></a> 二维树状数组</h2><p>Show me the Problem!<br />给定一个二维数组A，要求实现以下操作：<br />（1）单点修改A[x][y]<br />（2）单点查询A[x][y]<br />（3）子矩阵和查询：(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为左上角，(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为右下角<br />（4）子矩阵修改：(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为左上角，(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为右下角，所有元素加w</p><p>类似地建立树状数组c[x][y]表示以(x - lowbit(x) + 1,y - lowbit(y) + 1)为左上角，(x,y)为右下角的子矩阵的信息。<br />对于单点修改，思路大致不变，核心在于先固定一个然后修改另一个，使用循环嵌套：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x;i &lt;= n;i += <span class="hljs-built_in">lowbit</span>(i))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &lt;= m;j += <span class="hljs-built_in">lowbit</span>(j))&#123;<br>            c[i][j] += w;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于子矩阵的查询，想法和一维也是一致的（若左上角为(1,1)）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x;i &gt; <span class="hljs-number">0</span>;i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &gt; <span class="hljs-number">0</span>;j -= <span class="hljs-built_in">lowbit</span>(j))&#123;<br>            ans += c[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>而如果是任意的子矩阵，可以通过容斥原理来解决：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">return <span class="hljs-built_in">query</span>(x2,y2) - <span class="hljs-built_in">query</span>(x1,y2) - <span class="hljs-built_in">query</span>(x2,y1) + <span class="hljs-built_in">query</span>(x1,y1);<br></code></pre></td></tr></table></figure><p>What about <strong>区间修改和单点查询</strong>?<br />Redefine 差分数组：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">d[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span>] = a[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span>] - a[<span class="hljs-variable language_">x</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">y</span>] - a[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span> - <span class="hljs-number">1</span>] + a[<span class="hljs-variable language_">x</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">y</span> - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>对差分数组构建一个树状数组，单点查询就被转变为了区间前缀和。</p><p>而对于区间修改，通过观察+想象（或者逻辑推演）可知：只需要对4个角进行修改，具体表现为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">update</span>(x1,y1,w);<br><span class="hljs-built_in">update</span>(x1,y2 + <span class="hljs-number">1</span>,-w);<br><span class="hljs-built_in">update</span>(x2,y1 + <span class="hljs-number">1</span>,-w);<br><span class="hljs-built_in">update</span>(x2 + <span class="hljs-number">1</span>,y2 + <span class="hljs-number">1</span>,w);<br></code></pre></td></tr></table></figure><h2 id="another-经典应用树状数组求解逆序对数"><a class="markdownIt-Anchor" href="#another-经典应用树状数组求解逆序对数"></a> Another 经典应用——树状数组求解逆序对数</h2><p>核心在于:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> ans =  <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>    ans += query(maxN) - query(<span class="hljs-built_in">num</span>[i]);<br>    update(<span class="hljs-built_in">num</span>[i],<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果num[i]范围过大，可以采用离散化的方式防止RE😢😰<br />下面附上离散化的代码（de死我了，遇到了各种离谱的bug）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span> &#123;<br>    <span class="hljs-type">int</span> Data;<br>    <span class="hljs-type">int</span> pos;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">const</span> number*abegin,<span class="hljs-type">const</span> number*aend,<span class="hljs-type">const</span> number*bbegin,<span class="hljs-type">const</span> number*bend,number*c)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (abegin != aend &amp;&amp; bbegin != bend) &#123;<br>        <span class="hljs-keyword">if</span>(abegin-&gt;Data &lt; bbegin-&gt;Data) &#123;<br>            *c = *abegin;<br>            abegin ++;<br>            c ++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            *c = *bbegin;<br>            bbegin ++;<br>            c ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(abegin != aend) &#123;<br>        *c = *abegin;<br>        abegin ++;<br>        c ++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(bbegin != bend) &#123;<br>        *c = *bbegin;<br>        bbegin ++;<br>        c ++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(number *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(r - l &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(a,mid,r);<br>    <span class="hljs-keyword">auto</span> *tmp = <span class="hljs-keyword">new</span> number[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">merge</span>(a + l,a + mid,a + mid,a + r,tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; r;i ++) &#123;<br>        a[i] = tmp[i - l];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br><span class="hljs-type">int</span> c[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> tem[<span class="hljs-number">500005</span>];<br>number a[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> w)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(x &lt;= n) &#123;<br>        c[x] += w;<br>        x += <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) &#123;<br>        ans += c[x];<br>        x -= <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> pairNum = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; a[i].Data;<br>        a[i].pos = i;<br>    &#125;<br>    <span class="hljs-built_in">merge_sort</span>(a,<span class="hljs-number">1</span>,n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> id = <span class="hljs-number">1</span>;<br>    tem[a[<span class="hljs-number">1</span>].pos] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(a[i].Data == a[i - <span class="hljs-number">1</span>].Data) &#123;<br>            tem[a[i].pos] = id;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            tem[a[i].pos] = ++ id;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        pairNum += <span class="hljs-built_in">query</span>(id) - <span class="hljs-built_in">query</span>(tem[i]);<br>        <span class="hljs-built_in">update</span>(tem[i],<span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; pairNum;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sparse-table-st表"><a class="markdownIt-Anchor" href="#sparse-table-st表"></a> Sparse Table ST表</h1><p>ST 表（Sparse Table，稀疏表）是用于解决<strong>可重复贡献问题</strong>的数据结构。</p><h2 id="rmq问题"><a class="markdownIt-Anchor" href="#rmq问题"></a> RMQ问题</h2><p>Problem First😢😢😢：<br />给定n个数，m次询问，对于每个询问，回答区间[l,r]中的最大值。</p><p>我们发现区间最大值是一个具有「可重复贡献」性质的问题。即使用来求解的预处理区间有重叠部分，只要这些区间的并是所求的区间，最终计算出的答案就是正确的。我们能使用至多两个预处理过的区间来覆盖询问区间，也就是说询问时的时间复杂度可以被降至O(1)，在处理有大量询问的题目时十分有效。</p><p>令f(i,j)表示区间[i,i + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span> - 1]区间上的最大值。对于每个询问，我们把它分为[l,l + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span> - 1]和[r - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span> + 1,r]，其中s = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">log_2{r - l + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span>。</p><p>鉴于log操作计算量较大（double），我们考虑用一个函数手写一下：（和OiWiki上的想法不太一样，但感觉能用）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        x /= <span class="hljs-number">2</span>;<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是预处理：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>    cin &gt;&gt; f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是倍增处理了：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">for(int i = <span class="hljs-number">1</span><span class="hljs-comment">;i &lt;= 21;i ++)&#123; //如果数据是1e6级的，那么21就查不多了，甚至不用调用函数再算一下</span><br>    for(int <span class="hljs-keyword">j </span>= <span class="hljs-number">1</span><span class="hljs-comment">;i + (1 &lt;&lt; j) - 1 &lt;= n;j ++)&#123;</span><br>        f[i][<span class="hljs-keyword">j] </span>= std::max(f[i][<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>],f[i + (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>))][<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当查询时，就更简单了：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int s = log(r - l + 1);<br>cout &lt;&lt; std::max(f<span class="hljs-comment">[i]</span><span class="hljs-comment">[s]</span>,f<span class="hljs-comment">[r - (1 &lt;&lt; s) + 1]</span><span class="hljs-comment">[s]</span>);<br></code></pre></td></tr></table></figure><h2 id="超级经典问题与众不同"><a class="markdownIt-Anchor" href="#超级经典问题与众不同"></a> 超级经典问题——与众不同！</h2><p>指路：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2183">与众不同</a><br />思路：记f(i)表示以第i个位置为结尾的最长完美序列的左端点位置，容易发现f(i)是不降的对于一个[l,r]的询问，我们将区间中的点分成左右两部分，左边的点满足f(i)&lt;L,右边的点满足f(i)≥L, 对于左边的点我们可以直接算出答案，对于右边的点我们可以用st表区间询问求得答案。</p><p>上代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> LastExist[<span class="hljs-number">2000005</span>];<br><span class="hljs-type">int</span> position[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">200005</span>][<span class="hljs-number">20</span>];//ST表<br><span class="hljs-type">int</span> LOG(<span class="hljs-type">int</span> x) &#123;<br>    <span class="hljs-type">int</span> i = - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(x) &#123;<br>        x /= <span class="hljs-number">2</span>;<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    std::ios::sync_with_stdio(<span class="hljs-keyword">false</span>);<br>    cin.tie(<span class="hljs-number">0</span>); <br>    cout.tie(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        x += <span class="hljs-number">1000001</span>;<br>        position[i] = max(position[i - <span class="hljs-number">1</span>],LastExist[x] + <span class="hljs-number">1</span>);<br>        LastExist[x] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> l,r;<br>    //ST表初始化<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = i - position[i] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">21</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k + (<span class="hljs-number">1</span> &lt;&lt;j) - <span class="hljs-number">1</span> &lt;= n ;k ++) &#123;<br>            f[k][j] = max(f[k][j - <span class="hljs-number">1</span>],f[k + (<span class="hljs-number">1</span>&lt;&lt;(j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i ++) &#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l ++;<br>        r ++;<br>        <span class="hljs-type">int</span> maxLength = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> newstart = - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = l;j &lt;= r;j ++) &#123;<br>            <span class="hljs-keyword">if</span>(position[j] &lt; l) &#123;<br>                maxLength = j - l + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                newstart = j;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(newstart ==  - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; maxLength &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> s = LOG(r - newstart + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> another = max(f[newstart][s],f[r - (<span class="hljs-number">1</span> &lt;&lt; s) + <span class="hljs-number">1</span>][s]);<br>        <span class="hljs-keyword">if</span>(another &gt; maxLength) &#123;<br>            maxLength = another;<br>        &#125;<br>        cout &lt;&lt; maxLength &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://oi-wiki.org/ds/fenwick/">树状数组</a></li><li><a href="https://oi-wiki.org/ds/sparse-table/">ST表</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Fenwick Tree</tag>
      
      <tag>Sparse Table</tag>
      
      <tag>RMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure 19 B Tree &amp; B+ Tree</title>
    <link href="/2025/04/03/Data-Structure19/"/>
    <url>/2025/04/03/Data-Structure19/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Long-Time-No-See-Guys-I’ve-been-busy-struggling-with-my-Maths-Analysis-Physics-and-Mathematical-Logic-learning-also-busy-building-connections-with-others-But-I-realize-that-I-have-to-keep-learning-my-data-structure-in-order-to-start-B-Plus-Tree-as-soon-as-possible">Before：Long Time No See Guys!~ I’ve been busy struggling with my Maths Analysis,Physics and Mathematical Logic learning,also busy building connections with others.But I realize that I have to keep learning my data structure in order to start B Plus Tree as soon as possible.</h5><p>记得她泪水涟涟</p><h1>Data Structure 19 外部查找与排序</h1><h2 id="主存储器与外存储器">主存储器与外存储器</h2><p>主存储器与外存储器是计算机的两类不同存储物质。主存储器也称<strong>内存</strong>，用于存储正在运行的的程序代码及运行数据。外存储器用于存储长期保存的信息，常用的外存储器有<strong>磁盘、磁带、光盘、U盘</strong>。</p><p>相比于内存，外存储器有价格低廉、存储址大和永久保存等优点。但也有<strong>访问速度慢</strong>的缺点。在考虑处理外存储器上数据的算法时应该重点考虑<strong>如何减少访问次数</strong>。</p><p>磁盘是一种可以直接存取的外存设备，它不仅可以顺序存取，也可以直接存取。它的存取速度比磁带快得多。磁盘表面上有很多同心圆的轨道，称为<strong>磁道</strong>，信息被存储在磁道上。所有磁盘上的同一位置的磁道称为一个<strong>柱面</strong>。每条磁道又被分成若干段，每一段称为一个扇区。一个扇区相当于磁带上的一个数据块，也称为<strong>磁盘块</strong>，是一次<strong>磁盘读写的单位</strong>。</p><p><img src="/img/%E7%A3%81%E7%9B%98.png" alt="磁盘结构"></p><p>一次磁盘访问所需的时间相当于执行几百万条甚至几千万条指令所需的时间😰。由于磁盘和磁带的访问特性，在设计基于外存的箕法时，宁愿做很多的计算来避免一次外存访问。在包含外存操作的情况下，外存访问的次数决定了操作的运行时间。外存访问次数要能减半，运行时间也就减半了。</p><h2 id="B树">B树</h2><h3 id="B树的定义">B树的定义</h3><p>提高外存储器中查找表的查找效率，最直接的方法就是<strong>减少磁盘访问的次数</strong>。在查找树中，访问的次数与查找树的高度成正比。在外存储器中，每次访问对应了一次磁盘访问。<br>因此，要减少磁盘访问次数，必须<strong>降低查找树的高度</strong>。解决方案也很简单：只需要增加树的分支。一棵M叉查找树的高度约为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>M</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_M N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span></p><p>在M叉查找树中，我们同样需要保存M - 1个键来判断到哪个分支继续操作。同时，为了保证最坏情况下依然具有高效性，我们需要一些措施来保证M叉查找树的平衡。</p><p>1970 年，R.Bayer 和 E.Macreight 提出了 B 树的概念。B 树是一棵平衡的 m 叉的查找树，主要被用作为<strong>大型文件的索引</strong>。B 树的定义如下：<br>一棵M阶B树或者为空，或者满足以下条件：</p><ul><li>根结点要么是叶子，要么至少有2个儿子，至多有M个儿子</li><li>除根结点和叶结点之外，每个结点的的儿子个数s满足[ m/2 ]<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mi>s</mi><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq s\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.63597em;"></span><span class="strut bottom" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mrel">≤</span><span class="mord mathit">s</span><span class="mrel">≤</span></span></span></span>m</li><li>有s个儿子的非叶结点具有n = s - 1个关键字，故s = n + 1.<br>这些结点的数据信息为：(n,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">K_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">K_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,…,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">K_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)<br>其中：<br>n：关键字个数<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>：结点的关键字<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>：B树中小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">K_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的结点地址<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>：关键字值等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">K_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的数据记录在硬盘中的地址<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">A_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>：B树中大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">K_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">K_{j + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的结点的地址<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>：B树中大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">K_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的结点的地址</li><li>所有的叶子结点都出现在同一层上（深度相同），并且不带信息（可以认为是查找失败的结点）</li></ul><p>一次磁盘读写可以读入<strong>磁盘上的一个块</strong>。因此，在B树的设计中可以将<strong>一个磁盘块作为一个B树的结点</strong>，根据<strong>磁盘块的大小、关键字的长度以及磁盘块地址的长度</strong>决定 B 树的阶数。</p><h3 id="B树的查找">B树的查找</h3><p>和BST的查找操作类似，只是抛弃了更多的branch</p><h3 id="B树的插入">B树的插入</h3><p>插入操作以查找操作为基础。<br>首先在m阶B树上进行查找操作，确定新插入的关键字key在最底层的非叶结点的插入位置。若被插入结点的关键字个数小于m-1，则插入操作结束；若该结点原有的关键字个数已经等于m-1，必须分裂成2个结点。</p><p>设在插入关键字key之前，结点（设其原地址为p）原来为：<br>(m - 1,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">K_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">K_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,…,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">K_{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</p><p>则在插入一个新关键字key后变为：<br>(m,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">K_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">K_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,…,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">K_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">m</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">m</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">A_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">m</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</p><p>由于结点的关键字数量个数已经超过了最大值m-1，所以必须进行分裂。这样，就必须创建一个新的结点，设该结点地址为q，它将包括第ceil(m/2) + 1个关键字到第m个关键字和相应的指针信息，这些信息可以从地址为p的结点中复制过来。这样的结点形式为：<br>(m - ceil(m/2),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ceil(m/2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">K_{ceil(m/2) + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{ceil(m/2) + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),…,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mrow><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</p><p>同样原结点也需要进行更新，第ceil(m/2) + 1个关键字到第m个关键字和相应的指针信息需要被删除，得到的新的结点p为：<br>(ceil(m/2) - 1,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">K_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">K_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,…,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">K_{ceil(m/2) - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{ceil(m/2)  - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ceil(m/2) - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</p><p>关键字(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">K_{ceil(m/2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">R_{ceil(m/2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)插入父结点的位置中。</p><p>新关键字的插入将导致父结点的关键字个数增加一个。如果父结点的关键字个数本来就为最大值 m-1 ，那么又会导致新一轮的结点分裂，这样有可能分裂一直进行到根结点为止。在根结点这一层上，<strong>可能创建一个新的根结点，导致 B 树长高一层</strong>。</p><h3 id="B树的删除">B树的删除</h3><p>删除操作同样类似于BST的删除操作，同样采用了“替身”的方法以保证树的完整性。</p><p>删除时，从根结点开始查找与给定关键字值 key 相等的关键字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。关键字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 可能出现在第一层到最底层之间的任何一个结点上，我们分以下几种情况讨论：<br>（1）如果关键字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>在最底层，可直接删除，转（3）<br>（2）否则，先找替身。用它的右子树的最左面的结点的关键字值（即处于最底部层上的最小关键字值代替），然后删除最底层上的该关键字。<br>（3）从最底层开始进行删除相关关键字的操作，有以下几种情况：</p><ul><li>若删除关键字之后，结点的关键字的个数仍处于 ceil(m/2)-1 和 m-1 之间，仍满足 B 树的结点的定义，删除结束。</li><li>若结点的关键字的个数原为ceil(m/2) - 1 ，若再删除一个关键字，将不符合 B 树定义。如果该结点的左或右兄弟结点的关键字的个数大于ceil(m/2) - 1 ，则借一个关键字过来。<strong>如果是借左兄弟结点的最大关键字，则必须将该关键字上移到父结点的相应位置，而将父结点中大于该关键字且最接近该关键字的那个关键字（连同左兄弟结点的最右方的指针 An）下移到被删关键字所在结点的最左面，删除操作结束。若借右兄弟结点的最小关键字，操作类似。</strong></li><li>该结点的左或右兄弟结点的关键字的个数都为ceil(m/2)-1，那么将无结点可借。这时只能执行合并结点的操作。<strong>将该结点同左兄弟（无左兄弟时，与右兄弟）合并</strong>。由于两个结点合并后，父结点中相应的关键字将不再保留，因为它原来的左右儿子已经不存在，因此，<strong>把父结点中该关键字也并入合并后的结点</strong>。这样，父结点的关键字个数便减少了一个。如果父结点的关键字个数不满足定义，则必须继续调整，最坏情况下可能达到根结点，使B树减少一层。</li></ul><h2 id="B-树">B+树</h2><h3 id="B-树的定义">B+树的定义</h3><p>B树能快速支持查找某个记录，但如果要对整个文件中的记录按关键字的递增顺序进行访问，则时间是灾难性的。既能支持每个记录的随机访问也能支持对整个文件按关键字次序访问的文件称为<strong>索引顺序文件</strong>。这个索引结构称为<strong>B+树</strong>，<strong>这是目前文件系统和数据库系统中应用广泛的索引结构</strong>。</p><p>文件可以看成一个驻留在外存储器上的数组 。要保待数组中元素的有序性，在插入或删除时将引起大量的数据记录的移动。而文件中的数据量是非常大的，这个移动将是灾难性的。</p><p>B+树采用了允许每一块不放满数据的策略，使得插入和删除时只影响记录所在的数据块，而不会影响其他数据块。</p><p>鉴于B+树既要考虑到索引的组织，又要考虑到记录本身的存放，M 阶的B+树被定义为具有以下性质的 M 叉树：</p><ul><li>根要么是叶子，要么有2到M个孩子</li><li>除根之外的结点都有不少于ceil(M/2)且不多于M个孩子</li><li>有k个孩子的结点保存了k-1个键来引导查找，键i代表子树i+1中键的最小值</li><li>叶结点中的孩子指针指向存储记录的数据块的地址。换句话说，对于索引B+树，它们是叶结点。但对于数据块来说，它们又是数据块的父结点。数据块才是真正的叶结点。而在B树中，叶结点的孩子指针都是空指针。</li><li>每个数据块至少有ceil(L/2)个记录，至多有L个记录。</li></ul><p><img src="/img/BPTexample.png" alt="BPT example"></p><p>为了提高磁盘访问的效率，每个结点的大小也是一个磁盘块，这样一次磁盘读写正好读写一个完整的结点。</p><h3 id="B-树的查找">B+树的查找</h3><p>类似BPT、B Tree等，不赘述了</p><h3 id="B-树的插入">B+树的插入</h3><p>B+树的插入过程也与二叉查找树类似。先从根结点开始查找插入的位置，把它插入相应的数据块中。但问题是存储记录的数据块中记录数是有限的，当插入遇到数据块已满时，必须有特殊的处理。</p><p>特殊处理与B树的处理类似（相当类似）</p><h3 id="B-树的删除">B+树的删除</h3><p>删除时，首先要找到存储被删记录的结点，然后再在结点中删除它。但问题在于如果此时结点中的记录数量只满足要求的最小值，再删除一个记录就不再满足要求了。此时如果邻居结点的记录数不是最少，就借一个过来领养，如果邻居结点的记录数也是最少，就把两个结点合并成一个满的结点。很不幸的是这种情况出现时，父亲就失去了一个孩子，而如果此时父亲的孩子数也少于最小值了，就使用同样的策略了，一直向根进行过滤。而这时根可能只有一个孩子了。如果真的是这样，就把根给删除了，让它的孩子作为新的根。这也是唯一能使 B＋树变矮的情况。</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Disk</tag>
      
      <tag>B Tree</tag>
      
      <tag>B Plus Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic6</title>
    <link href="/2025/03/28/Mathematical-Logic6/"/>
    <url>/2025/03/28/Mathematical-Logic6/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：稍有强度的一周，主要表现在…超级大的数学物理数理逻辑强度，但感觉经过3、4天的摸爬滚打，基本上还是搞明白了😇还有平安度过的XZJT（感觉还是挺成功的？maybe）继续加油！">Before：稍有强度的一周，主要表现在…超级大的数学物理数理逻辑强度，但感觉经过3、4天的摸爬滚打，基本上还是搞明白了😇还有平安度过的XZJT（感觉还是挺成功的？maybe）继续加油！</h5><h5 id="ps：昨天小姐姐double-happy了🥰🥰">ps：昨天小姐姐double happy了🥰🥰</h5><h1>Mathematical Logic 6</h1><h2 id="Call-back-Introduction-to-Sequent-Calculus">Call back: Introduction to Sequent Calculus</h2><p><strong>10 Basic Rules</strong></p><ol><li class="lvl-3"><p>Antecedent</p></li><li class="lvl-3"><p>Assumption</p></li><li class="lvl-3"><p>Case Analysis</p></li><li class="lvl-3"><p>Contradiction</p></li><li class="lvl-3"><p>V-introduction in antecedent</p></li><li class="lvl-3"><p>V-introduction in succedent</p></li><li class="lvl-3"><p>∃ -introduction in succedent</p></li><li class="lvl-3"><p>∃ -introduction in antecedent</p></li><li class="lvl-3"><p>Equality</p></li><li class="lvl-4"><p>Substitution</p></li></ol><p>Every Basic Rules is correct.(can be proved)</p><p><strong>Derived Rules 1</strong></p><ol><li class="lvl-3"><p>Excluded middle</p></li><li class="lvl-3"><p>Modified Contradiction</p></li><li class="lvl-3"><p>Chain Deduction</p></li></ol><p><strong>Derived Rules 2</strong><br>Modus Ponens<br>$\Gamma \vdash \varphi \rightarrow \psi $<br>$\Gamma \vdash \varphi$<br>—————————<br>$\Gamma \vdash \psi$<br><strong>Derived Rules 3</strong><br>1.Symmetry of $\equiv$<br>$\Gamma \vdash t_1 \equiv t_2$<br>—————————<br>$\Gamma \vdash t_2 \equiv t_1$</p><p>2.Transitivity of $\equiv$<br>$\Gamma \vdash t_1 \equiv t_2$<br>$\Gamma \vdash t_2 \equiv t_3$<br>—————————<br>$\Gamma \vdash t_1 \equiv t_3$</p><p>3.For n-ary relation symbol R $\in$ S<br>can be proved by using Substitution Lemma<br>$\Gamma \vdash R t_1 \ldots t_n  $<br>$\Gamma \vdash t_1 \equiv t’_1 $<br>$\Gamma \vdash t_2 \equiv t’_2 $<br>$\cdots \cdots$<br>$\Gamma \vdash t_n \equiv t’_n $<br>—————————<br>$\Gamma \vdash R t’_1 \ldots t’_n$</p><p>4.For n-ary function symbol R $\in$ S<br>can also be proved by using Substitution Lemma<br>$\Gamma \vdash t_1 \equiv t’_1 $<br>$\Gamma \vdash t_2 \equiv t’_2 $<br>$\cdots \cdots$<br>$\Gamma \vdash t_n \equiv t’_n $<br>—————————<br>$\Gamma \vdash f t_1 \ldots t_n \equiv f t’_1 \ldots t’_n$</p><p><strong>Soundness</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Defintion</p></li><li class="lvl-2"><p>Lemma 1</p></li><li class="lvl-2"><p>Theorem 2(<strong>Soundness</strong>)<br>If $\Phi \vdash \varphi$,then $\Phi \vDash \varphi$</p></li></ul><p>Opposite is <strong>Completeness</strong> and we will prove it in later lessons.</p><h2 id="Consistency">Consistency</h2><p><strong>Defintion</strong><br><strong>$\Phi$ is consistent if there is no $\varphi$ such that both $\Phi$ ⊢ $\varphi$ and $\Phi$ ⊢ $\neg$$\varphi$. Otherwise,$\Phi$ is inconsistent.</strong></p><p><strong>Lemma3</strong>: $\Phi$ is inconsistent if and only if $\Phi \vdash \varphi$ for any formulas $\varphi$.<br>This can be proved by using <strong>Modified Contradiction</strong>.</p><p><strong>Lemma 4</strong>: $\Phi$ is consistent if and only if there is a $\varphi$ such that $\Phi \not\models \varphi$.<br>This can be proved by using <strong>Modified Contradiction</strong>.</p><p><strong>Lemma 5</strong>: $\Phi$ is consistent if and only if every finite $\Phi_0 \subset \Phi$</p><p><strong>Lemma 6</strong>: Every satisfiable $\Phi$ is consistent.<br>(Prove from the negative perspective using soundness and build a model)</p><p><strong>Lemma 7</strong>:<br>(1) $\Phi \vdash \varphi$ if and only if $\Phi \cup \neg\varphi$ is inconsistent.</p><p>Easy to prove.</p><p>(2) $\Phi \vdash \neg\varphi$ if and only if $\Phi \cup \varphi$ is inconsistent.</p><p>(3)If cons($\Phi$),then either cons($\Phi \cup \varphi$) or cons($\Phi \cup \neg\varphi$).</p><h2 id="So-the-end-of-Sequent-Calculus">So the end of Sequent Calculus.</h2><h2 id="Start-of-Question-2-What-makes-a-proof-correct">Start of Question 2: What makes a proof correct?</h2><p>能证的都是对的（soundness），对的都是能证的（Completeness完备性）。</p><p><strong>Theorem 8</strong><br>If $\Phi \models \varphi$,$\Phi \vdash \varphi$</p><p><strong>Theorem 9</strong><br>cons($\Phi$) implies that $\Phi$ is satisfiable.</p><h2 id="Term-Model（version-1）">Term Model（version 1）</h2><p>Define the term model $\mathcal{I}^\Phi(t)$ so that for every t $\in T^S$.<br>$\mathcal{I}^\Phi(t) = t$<br>把语法对象作为语义的universe<br>That is, the interpretation of an S-term $t$ is the syntax object $t \in T^S$ itself.</p><p><strong>Universe</strong>：A = $T^S$<br><strong>n-ary function symbol</strong>：<br>$f^A(t_1, \ldots, t_n) := f t_1 \ldots t_n.$</p><p><strong>n-ary relation symbol</strong>：<br>$R^A = {(t_1, \ldots, t_n) | \Phi \vdash R t_1 \ldots t_n}.$</p><p>$c^A := c$ and $\beta(v_i) := v_i$ for every variable $v_i$</p><p>But：we will meet a problem.<br>Let S = {f} where f is a function symbol and $\Phi:={fv_0 \equiv fv_1}$</p><ul class="lvl-0"><li class="lvl-2"><p>$\mathcal{I}^\Phi(fv_0) = fv_0 \neq fv_1 = \mathcal{I}^\Phi(fv_1)$(2 strings are not the same)</p></li><li class="lvl-2"><p>$\mathcal{I}^\Phi \models \Phi$ implies that $\mathcal{I}^\Phi(fv_0) = \mathcal{I}^\Phi(fv_1)$</p></li></ul><p><strong>Contradict!<strong>😢😰😢😰<br>To Overcome The Issue!<br>在项的集合上定义一个</strong>等价关系</strong>，define an equivalence relation ~ on $T^S$</p><p><strong>Let $t_1$, $t_2$ $\in T^S$.Then $t_1$ ~ $t_2$ if $\Phi \vdash t_1 \equiv t_2$.</strong><br>(Easy to prove equivalence relation)</p><p>Introduce the <strong>Equivalence Class of t</strong>.<br>For every $t \in T^S$ we define:<br>$\overline{t} := {t’ \in T^S \mid t’ \sim t}$</p><p>Through <strong>Derived Rules 3</strong>,we can prove that:</p><ul class="lvl-0"><li class="lvl-2"><p>For every $n$-ary function symbol $f \in S$ and terms $t_1 \sim t_1’, \ldots, t_n \sim t_n’$, we have<br>$f t_1 \cdots t_n \sim f t_1’ \cdots t_n’.$</p></li><li class="lvl-2"><p>For every $n$-ary relation symbol $R \in S$ and terms $t_1 \sim t_1’, \ldots, t_n \sim t_n’$, we have<br>$\Phi \vdash R t_1 \cdots t_n \iff \Phi \vdash R t_1’ \cdots t_n’.$</p></li></ul><p>So we will introduce…</p><h2 id="Term-Model（version-2）">Term Model（version 2）!!!</h2><p>The term structure for $\Phi$, denoted by $\mathfrak{T}^{\Phi}$, is defined as follows.</p><p>(i) The universe is ${T}^{\Phi} := {\overline{t} \mid t \in T^S}$.</p><p>(ii) For every $n$-ary relation symbol $R \in S$, and $\overline{t}_1, \ldots, \overline{t}_n \in T^{\Phi}$</p><p>$(\overline{t}_1, \ldots, \overline{t}_n)$ $\in {R}<sup>\mathfrak{T}</sup>{\Phi}  \text{if}  \Phi \vdash R t_1 \ldots t_n.$</p><p>(iii) For every $n$-ary function symbol $f \in S$, and $\overline{t}_1, \ldots, \overline{t}_n \in T^{\Phi}$</p><p>${f}<sup>\mathfrak{T}</sup>{\Phi}$ $(\overline{t}_1, \ldots, \overline{t}_n)$ := $\overline{f t_1 \ldots t_n}.$</p><p>(iv) For every constant $c \in S$<br>${c}<sup>\mathfrak{T}</sup>{\Phi}$ := $\overline{c}.$</p><p>And we still need an assignment:<br>$\mathfrak{\beta}^{\Phi}(v_i):= \overline{v_i}$</p><p>So we have the <strong>Heenkin’s term model</strong>:<br>$\mathfrak{I}<sup>{\Phi}$:=($\mathfrak{T}</sup>{\Phi},\mathfrak{\beta}^{\Phi}$)</p><p><strong>Lemma 11</strong>:<br>(1)For any $t$ $\in T^S$:<br>$\mathfrak{I}^{\Phi}(t) = \overline{t}$</p><p>(2)For every atomic $\varphi$<br>$\mathfrak{I}^{\Phi} \models \varphi \iff \Phi \vdash \varphi$</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构6</title>
    <link href="/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"/>
    <url>/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/</url>
    
    <content type="html"><![CDATA[<h1>数据结构6 集合 动态查找表</h1><h2 id="查找操作">查找操作</h2><p>静态查找表 &amp; 动态查找表</p><ul class="lvl-0"><li class="lvl-2">静态查找表：元素个数不变，元素值不变一般使用C++ 的原始数组</li><li class="lvl-2">动态查找表：允许插入删除的查找表不能用线性表存储，会造成大量数据的移动</li></ul><h2 id="无序表-有序表的查找">无序表&amp;有序表的查找</h2><p>无序表查找的复杂度是O(n)的。有序表查找可以采用顺序查找、二分查找、插值查找、分块查找。</p><h3 id="顺序查找">顺序查找</h3><p>与无序表查找唯一的不同在于若元素不存在无需查到表头</p><h3 id="二分查找">二分查找</h3><p>时间复杂度是O(log N)</p><h3 id="插值查找">插值查找</h3><p>适用于数据分布比较均匀的情况，但缺点是计算量较大</p><h3 id="分块查找">分块查找</h3><p>块内的数据元素可以是有序存储，也可以是无序的，但块之间必须是有序的。</p><h2 id="二叉查找树-BST">二叉查找树 BST</h2><p>左子树元素都小于根结点，右子树元素都大于根结点</p><p>数据成员：一个指向根结点的指针公有成员函数：find，insert，remove，构造函数，析构函数私有成员函数：find，insert，remove（递归函数的实现）</p><p>insert、remove函数采取<strong>引用传递</strong>，直接修改原树的结构</p><p>删除操作分几种情况讨论：</p><ol><li class="lvl-3"><p>删除叶结点：直接删除</p></li><li class="lvl-3"><p>删除只有一个儿子的结点</p></li><li class="lvl-3"><p>删除有2个儿子的结点：选取替身结点（这样可以尽可能的不让树变高）我们选取左子树的最大值或右子树的最小值</p></li></ol><p>性能上，在最坏的情况下，BST 会退化成一个单链表，时间复杂度是O(N)<br>可以证明，平均情况下，时间复杂度是O(logN)</p><p><strong>平均性能</strong><br>n个结点二叉查找树可能有n种形态，如果这些形态出现的概率相等。得到：<br>P(n) = 1.38logN</p><h2 id="平衡二叉树（平衡树）">平衡二叉树（平衡树）</h2><p>满足一定条件的二叉查找树，保证树的高度是O(logN)<br>常用的平衡树：AVL 红黑树 AA树</p><h2 id="AVL树">AVL树</h2><p>平衡因子：结点的平衡度是左右子树的高度差平衡因子为+1，-1，0</p><h3 id="AVL插入操作">AVL插入操作</h3><p>自插入结点开始，向根回溯。如果没有破坏平衡，则只修改平衡因子。但如果平衡被破坏，我们需要调整平衡。</p><p>通过<strong>旋转</strong>：LL LR RL RR</p><h3 id="AVL删除操作">AVL删除操作</h3><p>检查失衡：（假设都在左子树删除）分以下几种初始状态进行讨论：</p><ul class="lvl-0"><li class="lvl-2"><p>T是平衡的没有失衡，高度没变，不需要向上继续调整</p></li><li class="lvl-2"><p>T左高右低没有失去平衡，但整棵树变矮了，所以需要向上调整</p></li><li class="lvl-2"><p>T左低右高失去平衡（1）T右子树平衡，RR旋转，不需向上调整（2）T右子树左高右低，RL旋转，需要向上调整（3）T右子树左低右高，RR旋转，需要向上调整</p></li></ul><p>remove函数设计为bool类型，若返回值为true，表示这棵树没有变矮，无需进一步向上调整。但如果返回值为false，则需要向上调整，调用adjust函数。</p><h2 id="红黑树">红黑树</h2><h3 id="红黑树的插入">红黑树的插入</h3><p>方法：通过旋转和重新着色调整过程可能回溯到根结点（反正根结点一定是黑色的）</p><p>当出现了连续红色节点时，我们需要进行<br><strong>平衡调整</strong>：如果你的叔叔是红色的，那么进行一次重新着色，然后矛盾上交，继续向上回溯。</p><p>如果你的叔叔是黑色的，那么进行LL or RR or LR or RL旋转，可以维护根结点的黑色，同时不会再出现连续红色节点。（认为空结点是黑结点）</p><p>综上可见，红黑树的插入操作并不复杂。</p><p>与其他各种树一样，红黑树的插入同样也是递归函数，借助于私有成员函数来实现。</p><h3 id="红黑树的删除">红黑树的删除</h3><p>被删结点的情况：</p><ul class="lvl-0"><li class="lvl-2"><p>红色叶结点：直接删除</p></li><li class="lvl-2"><p>只有一个儿子的叶结点：肯定是黑结点，儿子是红结点，修改儿子为黑节点</p></li><li class="lvl-2"><p>黑色叶结点：导致该路径上少了一个黑结点，需要调整</p></li></ul><p>调整的思想是让兄弟的某个红孩子转移到这条路径上，并改为黑结点（借一个）</p><p>鉴于笔者并没有听懂翁阿姨课上的各种《红孩子》《黑孩子》《脱贫》，于是在课上打开了OIWIKI，发现出人意料地清晰，于是附上链接：<br><a href="https://oi-wiki.org/ds/rbtree/#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">OIWIKI红黑树删除操作</a></p><p>删除操作：<br>case0：只有一个结点<br>case1：删除结点既有左又有右结点，找到直接前驱或直接后继进行替换。<br>case2：删除结点只有一个叶结点，则该结点一定为黑色，其孩子一定为红色，则将其删除，用子结点替换，并将该结点染成黑色。<br>case3：删除结点为红色叶结点，直接删除。<br>**case4：**删除结点为黑色叶结点，需要进行调整（唯一一个需要调整的情况）</p><p>删除调整操作：（情况太多不做罗列的，对着图写就好呜呜呜）</p><h2 id="AA树">AA树</h2><p>定义：左孩子不能为红色的红黑树用结点层次表示平衡信息，水平链表示法：将指向红结点的链画成水平的，可以看出所有叶子结点的高度都是相同的。</p><p>不可以出现<strong>水平左链</strong>和<strong>连续水平右链</strong>！！！</p><h3 id="AA树插入操作">AA树插入操作</h3><ul class="lvl-0"><li class="lvl-2"><p>水平左链的解决：对结点执行一个LL旋转但是这可能会产生连续水平右链，需要继续调整</p></li><li class="lvl-2"><p>连续水平右链的解决：对结点执行一个RR旋转但是会导致层次的增长，需要继续调整</p></li></ul><p>AA树插入的调整可能会一直回溯到根结点（提高了一个层次）</p><h3 id="AA树的删除操作">AA树的删除操作</h3><p>最终总能归结到删除第一层的结点</p><p>被删结点情况：</p><ul class="lvl-0"><li class="lvl-2"><p>被删结点是红结点：直接删除</p></li><li class="lvl-2"><p>被删结点有一个红结点的儿子：将此红结点替换为被删结点</p></li><li class="lvl-2"><p>被删结点是黑结点：会影响平衡，需进行调整</p></li></ul><p><strong>删除调整</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>被删结点是黑色的右孩子（最简单情况）：删除后产生水平左链，进行LL旋转，后向上调整</p></li><li class="lvl-2"><p>被删结点是黑色的右孩子（最复杂情况）：删除后父节点LL，根右孩子LL，对根执行RR，无需向上调整</p></li><li class="lvl-2"><p>若被删结点是黑色的左孩子（更加复杂）：删除后根结点右儿子LL，对根右儿子的右儿子LL，对根RR，对根右儿子RR</p></li></ul><p>综上分析，我们只需要在BST的删除操作上增加如下调整即可实现AA树的删除：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl">LL(t);<br><span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> right != nullptr)&#123;<br>    LL(<span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> right);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> != nullptr &amp;&amp; t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> right != nullptr)&#123;<br>    LL(<span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> right);<br>&#125;<br>RR(t);<br><span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> right != nullptr)&#123;<br>    RR(<span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exam Conclusion</title>
    <link href="/2025/03/24/A-Conclusion-of-Exam-1-2/"/>
    <url>/2025/03/24/A-Conclusion-of-Exam-1-2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：This-is-my-conclusion-of-the-Exams-I-will-upd-it-any-time-to-improve-myself">Before：This is my conclusion of the Exams.I will upd it any time to improve myself.</h5><h1>Score &amp; Rank</h1><p>Exam 1 : 130/300  4/39<br>Exam 2 : 30/300  26/39<br>Exam 3 ：100/300 17/39</p><p>You will see that I didn’t do a good job in Exam 2.I believe that at least I should get 130/300 with a rank of 9/39 in Exam 2,but something terrible happens.<br>I will explain it later.</p><h1>Complication of Exam 1</h1><p>Problem 1 is a model exercise of the <strong>Chunking Idea</strong>.<br><img src="/img/OJ2619.png" alt="OJ2619"></p><p>Problem 2 is quite easy.</p><p>Problem 3 talks about a new way of Matrix Compression called <a href="http://CSR.It">CSR.It</a>’s also quite easy if you understand the meaning of the method.</p><h1>Complication of Exam 2</h1><p>Problem 1 ：D*mn!I really hate it!Quite easy one——Postorder Traversal of Binary Tree.<br>但是问题出在这里，在模拟栈的时候，我选择构建一个Node类型的数组，理论上在栈的模拟递归中我们一般对指针进行操作，而不信邪的JaneZ坚定地认为直接放Node也没啥问题。<br>But:我们知道树的析构是很讲究的，先析构左树，再析构右树，最后删自己，但是如果一旦将Node作为数组对象时，在函数生命周期结束时，我需要按照数组的下标顺序一个一个析构对应的Node，这就会使得原本的析构顺序完全乱了套，出现了大规模的<strong>Invalid Read</strong>（这很坏了）。但数组里如果存的时Node指针,就不会出现这个问题，你是没办法delete 一个没有动态分配的指针的，对吧。所以以RE收场了一道签到题，非常不甘心🥱</p><p>Problem 2 ：很难的算法题，主要是从平均值联想不到<strong>二分答案</strong>，想到了在使用单调队列就比较自然了。</p><p>Problem 3 ：更像是一道阅读材料的题目，回忆了shared_ptr 和weak_ptr:</p><ul class="lvl-0"><li class="lvl-2"><p>shared_ptr 允许多个所有者共享实际对象，通过引用计数管理内存</p></li><li class="lvl-2"><p>weak_ptr 不增加强引用计数，用于解决循环引用问题</p></li></ul><h1>Complication of Exam 3</h1><p>Problem 1 ：超级恶心的二维树状数组区间查询区间修改板子题（是的又是板子题）没啥好说的，写了个暴力拿了50分</p><p>Problem 2 ：ST表+位运算，真的小丑，ST表倒是写出来了但是卡在了不知道一个异或的性质，导致预处理炸到了O($N^2$)<br>在这里回忆一下位运算：</p><ul class="lvl-0"><li class="lvl-2"><p>&amp; 与 只有两个对应位都为1时才为1</p></li><li class="lvl-2"><p>| 或 只要两个对应位中有一个1时就为1</p></li><li class="lvl-2"><p>^ 异或 只有两个对应位不同时才为1<br>异或有个性质，2次异或同一个数结果不变，也就是说：a<sup>b</sup>b = a<br>即：若a ^ b = x，那么有x^b = a（破防了就是这个不知道不然早AC了，还是基础太不扎实了）</p></li></ul><p>Problem 3 ：下午+晚上做了详细的分析，详见<a href="https://janez-uint.github.io/2025/04/07/Rust-RefCell%E6%9C%BA%E5%88%B6/">Rust RefCell机制</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure18</title>
    <link href="/2025/03/23/Data-Structure18/"/>
    <url>/2025/03/23/Data-Structure18/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：最近在看电影😋打算慢慢把一些经典的但是一直没抽空看的好片子看一遍。刚看完了Avatar，怎么说呢，票房不能说明一切吧（感觉全球票房前10可能只有Titanic和Avenger4确实高质量，个人观点勿喷）今天开始看了一部14年的经典奥斯卡获奖电影——《布达佩斯大饭店》，一直有朋友推荐我看，才看了一点，美学上极致的对称是我非常欣赏的，色调也很喜欢。">Before：最近在看电影😋打算慢慢把一些经典的但是一直没抽空看的好片子看一遍。刚看完了Avatar，怎么说呢，票房不能说明一切吧（感觉全球票房前10可能只有Titanic和Avenger4确实高质量，个人观点勿喷）今天开始看了一部14年的经典奥斯卡获奖电影——《布达佩斯大饭店》，一直有朋友推荐我看，才看了一点，美学上极致的对称是我非常欣赏的，色调也很喜欢。</h5><h1>Data Structure 18 伸展树 散列表</h1><h2 id="伸展树的定义">伸展树的定义</h2><p>伸展树也是一种<strong>二叉查找树</strong>。它支持二叉查找树的所有操作，但不需要维护平衡信息。因此，它不保证O(log N)的最坏情况下的时间性能。但从均摊的意义上看，它的时间性能还是对数的。</p><p>虽然平衡树对每个操作都提供了对数的最坏情况的运行时间的保证，但它们有一些限制。<br>(1)AVL的子树高度，红黑树的结点颜色，AA树的结点层次<br>(2)为保持平衡，插入删除操作非常复杂（11111😢😢😢）</p><p>其实可以有一个合理的折中：对单个访问的 O(N) 的时间是可接受的，只要不是经常发生。实际上，如果对于任何 M 个连续操作能够保证在最坏情况下的总时间为O(Mlog N)，那么均匀地分摊到序列中的每个操作的话，每个操作的时间是 O(log N) 的。这个运行时间被称为均摊的，即某些操作花的时间可能比对数要长，但能保证在序列中出现在它前面的某些执行时间较短的操作会给予补偿。</p><p>首先，在实际应用中，通常90％的访问都是针对 10％的数据。这个规则被称为90-10规则。通常只要保证这10％的数据能够快速访问。但平衡查找树没有利用这条规则的优势，它对所有的数据一视同仁。</p><p>Recall：BST的查找代价正比于深度，那么如果让一个经常被访问的数据元素靠近树根，将会节省以后查找这个元素的时间。将频繁访问的数据元素朝着根移动的最容易的方法，是连续地与它的父结点旋转，将该数据元素移得更接近根，该过程被称为<strong>向根旋转</strong>。但不幸的是，如果数据不满足90-10原则，而是雨露均沾，访问将会变得非常糟糕。</p><p>Recall Again：单旋转并不一定能使树的高度降低，但双旋转一定可以，所以我们考虑用双旋转，让元素不断靠近根，且整棵树的高度也在不断降低，我们将引入双旋转后的调整操作称作<strong>伸展操作</strong>。</p><h2 id="伸展操作的实现">伸展操作的实现</h2><p>如果 X 是所要旋转的访问路径上的非根结点，根据 X 在树上的位置可以分成下列几种情况：（1）X的父结点是根结点（2）X是祖父结点的内部结点（3）X是祖父结点的外部结点让我们进行一个<strong>Case Analysis</strong></p><h3 id="情况一：X的父结点是根结点-——-zig情况">情况一：X的父结点是根结点 —— zig情况</h3><p>解决方案：一个单旋转如果是根结点的左孩子，进行一个LL，如果是根结点的右孩子，进行一个RR。</p><h3 id="情况二：X是祖父结点的内部结点-——-zig-zag情况">情况二：X是祖父结点的内部结点 —— zig-zag情况</h3><p>解决方案：一个双旋转 LR or RL（与AVL中完全相同）<br>Result：高度降低！Win!</p><h3 id="情况三：X是祖父结点的外部结点-——-zig-zig情况">情况三：X是祖父结点的外部结点 —— zig-zig情况</h3><p>解决方案：设X的父结点为P，祖父结点为G，现在P和G之间进行一次旋转，然后在X和P之间进行一次旋转。<br>Result：高度降低！Win!</p><h2 id="伸展树总结">伸展树总结</h2><p>对伸展树的分析很困难，因为树的结构经常变化，但伸展树的编程要比 AVL 树和红黑树简单得多，几乎和 AA 树一样简单。（是的确实简单，但也和AA树一样无法证明为何需要这么做，就很神秘了）如果访问的模式是非随机的，伸展树似乎更好。非随机访问包括那些遵循 90-10 规则的情况以及一些特殊的情况，如顺序访问，双向访问和在某些事件模拟中的优先级队列等经典的具有明确的访问模式的访问。当访问序列是随机的且均匀分布时，伸展树没有其他的平衡树好。</p><h2 id="散列表定义">散列表定义</h2><p>在BST中，查找一个元素需要一系列的比较，查找的效率取决千查找过程中的比较次数。散列表提供了一种完全不同的存储和查找方法：通过将关键字值直接映射到表中的某个位置，将该关键字对应的数据元素存储在这个位置中。查找时，可以直接根据被查找的关键字值找到存储该数据元素的地址，从而获得这个数据元素。真的可以O(1)嘛？</p><p>尽管关键字的变化范围很大，例如可能达到 40 亿，但一个集合中并不一定有那么多的数据元素。如果为这个集合准备了一个 40 亿个元素的数组，数组中的很多单元都将为空，这样会造成大址的空间浪费。散列表的思想是用一个比集合规模略大的数组来存储这个集合，将数据元素关键字映射到这个数组的下标。这个映射称为<strong>散列函数</strong>。</p><p>散列函数的应用带来了一个复杂的问题：因为散列函数的定义域的范围比值域大，两个或更多的不同数据元素可能被映射到同一个位置，这种情况称为 <strong>冲突或碰撞</strong>。这种情况是不可避免的。因此，实现散列表的两个最基本的问题是，如何设计散列函数，以及如何解决碰撞。</p><h2 id="散列函数">散列函数</h2><ol><li class="lvl-3"><p>直接定址法设关键字值为x，那么其散列地址为H(x) = x或H(x) = ax + b(a,b为常数)</p></li><li class="lvl-3"><p>除留余数法如果M是散列表的大小，关键字为x的数据元素的散列地址为：<br>H(x) = x mod M<br>显然如果M选取不当，会造成大量碰撞和空间的浪费。经验表明，选取M为素数时，散列函数的函数值的分布会比较均匀。</p></li><li class="lvl-3"><p>数字分析法在某些应用中，关键字之间的区别集中在某些位上面。比如IP地址由网络号和主机号两个部分组成。如果在某个网络中要将自己的子网中的所有主机的信息管理起来，可以将 IP 地址作为关键字，如果采用散列的方法来保存这个集合，可以选择选取 IP 地址的主机号部分作为存储地址。</p></li></ol><p>分析关键字中的每一位数字的分布规律，并从中提取出分布均匀的若干位或它们的组合作为地址。</p><ol start="4"><li class="lvl-3"><p>平方取中法如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字平方后，取其结果的中间各位作为散列函数值。</p></li><li class="lvl-3"><p>折叠法如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法。如果数字的分布大体上是均匀的，通常的做法是选取一个长度后，将关键字按此长度分组相加。</p></li></ol><h2 id="碰撞的解决">碰撞的解决</h2><p>哈希冲突不可避免常用的解决哈希冲突的办法有2种：（1）将溢出数据元素存放到散列表中没有使用过的单元中去。此方法是封闭式的，不再使用额外的单元。因此称为<strong>闭散列表</strong>。（2）将映射到同一地址的数据元素组织成一个线性表（通常采用链表的方式）。散列表本身仅保存一个指向各自链表中第一个结点的指针。这种方式的空间是开放式的，因此被称为<strong>开散列表</strong>，也称为<strong>拉链法</strong>。</p><h2 id="线性探测法">线性探测法</h2><p>最简单可行，首先找到该数组中散列到的位置，接着开始顺序搜索，直到发现一个空位置。只要数组够大，总能找到一个空单元。操作上，find和insert几乎是走一样的路径，但删除操作则稍有区别。如果物理意义上删除，将会导致find、insert操作出现错误，所以我们采用<strong>迟删除</strong>，即将这些元素标记为删除而不是物理地从表中删除（增加一个字段）。</p><p>代码实现较容易，不做实现了（太懒了😅）</p><h2 id="二次探测法">二次探测法</h2><p>在线性探测法中，碰撞会引起连锁反应，使表中形成一些较长的连续被占单元，从而使散列表的性能下降。这些连续被占的单元称为<strong>初始聚集</strong>。初始聚集越长，insert、find操作耗时就长，性能就差。消除初始聚集的一种方法是<strong>二次聚集法</strong>。</p><p><strong>二次探测法</strong>也是一个碰撞解决方法。当发生碰撞时，它不是直接检查下一单元而是检查远离初始探测点的某一单元来消除线性探测中的初始聚集的问题。</p><p>当散列函数计算出 H 的值，并且搜索单元 H 没有成功，将依次尝试单元H + $1^2$，H + $2^2$，H + $3^2$，…，H + $i^2$(包括回绕)，这样不太容易产生连续被占单元，使得数据相对分布均匀。</p><p>下证明一个定理：<strong>如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半空单元，新的元素总能被插入。而且，在插入过程中，没有一个单元被探测两次</strong>。<br>PF：只要说明前[M/2]个替换单元是不同的，就证明了该定理。我们采用反证：不妨设这些单元中的某2个单元是H + $i^2$(mod M) 和 H + $j^2$(mod M)，其中，0 $\leq$ i,j $\leq$ [M/2] ，i $\neq$ j.<br>那么：</p><p>H + $i^2$ $\equiv$ H + $j^2$(mod M)</p><p>$i^2$ $\equiv$ $j^2$(mod M)</p><p>$i^2$ - $j^2$ $\equiv$ 0(mod M)</p><p>(i - j)(i + j) $\equiv$ 0(mod M)</p><p>Since i $\neq$ j , i + j $&lt;$ M, Contradict!</p><p>QED.</p><p>再证一个定理：<strong>不需要昂贵的乘法和除法就能实现二次探测法</strong>。设$H_{i-1}$是最近计算到的探测点，$H_i$是要计算的新的探测点，那么可以有：<br>$H_i$ =  $H_0$ + $i^2$(mod M)</p><p>$H_{i - 1}$ = $H_0$ + $(i - 1)^2$(mod M)</p><p>两式相减，得到：<br>$H_i$ = $H_{i - 1}$ + 2i - 1(mod M)</p><p>所以不需要对i进行平方计算就能得到新的H_i的值。</p><p>最后一个要考虑的问题是动态扩展。在二次探测法中，必须保持数组中有一半单元是空的。如果负载因子超过了 0.5 ，需要将数组扩大一倍。</p><h2 id="再散列法">再散列法</h2><p>2个散列函数：H1(x),H2(x)<br>探测序列为：H1(x)(mod M),(H1(x) + H2(x))(mod M),(H1(x) + 2H2(x))(mod M)…</p><h2 id="开散列表">开散列表</h2><p>将具有同一散列地址的元素都存储在一个单链表中，散列表的k号单元保存。</p><p>首先，作为一只程序设计学的不咋样的鼠鼠，我先来回忆一下<strong>函数指针</strong>！</p><ul class="lvl-0"><li class="lvl-2"><p>函数指针是指向函数的指针变量。</p></li><li class="lvl-2"><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p></li><li class="lvl-2"><p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p></li></ul><p>函数指针的声明语法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">返回类型 (*指针变量名)(参数列表);<br></code></pre></td></tr></table></figure><p>For example:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> (*funcPtr)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);  <span class="hljs-regexp">//</span> 声明一个指向函数的指针，该函数接受两个<span class="hljs-keyword">int</span>参数并返回<span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><p>接着，作为一只程序设计学的不咋样的鼠鼠，我再来回忆一下<strong>静态成员函数</strong>！</p><ul class="lvl-0"><li class="lvl-2"><p>静态成员函数只能访问对应类内部的静态数据成员。</p></li><li class="lvl-2"><p>不依赖于类的实例，可以直接通过类名调用（如 ClassName::staticFunc()）</p></li><li class="lvl-2"><p>没有this指针</p></li></ul><p>《开始》《手搓》</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">openHashTable:<span class="hljs-symbol">public</span></span> <span class="hljs-symbol">dynamicSearchTable</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt; &#123;<br><span class="hljs-keyword">private</span>:<br>    struct node &#123;<br>        SET&lt;KEY,OTHER&gt; data;<br>        node *next;<br>        node(SET&lt;KEY,OTHER&gt; d,node *n = <span class="hljs-literal">null</span>ptr):data(d),next(n)&#123;&#125;<br>        node():next(<span class="hljs-literal">null</span>ptr)&#123;&#125;<br>    &#125;;<br><br>    node **<span class="hljs-built_in">array</span>;<br>    <span class="hljs-built_in">int</span> Size;<br>    <span class="hljs-built_in">int</span> (*key)(<span class="hljs-keyword">const</span> KEY &amp;x);  <span class="hljs-comment">// 函数指针成员变量</span><br>    static <span class="hljs-built_in">int</span> defaultKey(<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;x) &#123; <span class="hljs-keyword">return</span> x; &#125;  <span class="hljs-comment">// 静态成员函数</span><br><br><span class="hljs-keyword">public</span>:<br>    openHashTable(<span class="hljs-built_in">int</span> s = <span class="hljs-number">101</span>,<span class="hljs-built_in">int</span> (*f)(<span class="hljs-keyword">const</span> KEY &amp;x));<br>    ~openHashTable();<br>    SET&lt;KEY,OTHER&gt;*find(<span class="hljs-keyword">const</span> KEY &amp;x)<span class="hljs-keyword">const</span>;<br>    <span class="hljs-built_in">void</span> insert(<span class="hljs-keyword">const</span> SET&lt;KEY,OTHER&gt; &amp;x);<br>    <span class="hljs-built_in">void</span> remove(<span class="hljs-keyword">const</span> KEY &amp;x);<br>&#125;;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">openHashTable</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">openHashTable</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">s</span> ,<span class="hljs-symbol">int</span> (*<span class="hljs-symbol">f</span>)(<span class="hljs-symbol">const</span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)) &#123;<br>    Size = s;<br>    <span class="hljs-built_in">array</span> = new node*[Size];<br>    key = f;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Size;i ++) &#123;<br>        <span class="hljs-built_in">array</span>[i] = <span class="hljs-literal">null</span>ptr;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">openHashTable</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::~<span class="hljs-symbol">openHashTable</span>() &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; Size;i ++) &#123;<br>        node *p = <span class="hljs-built_in">array</span>[i];<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr) &#123;<br>            node *q = p -&gt; next;<br>            delete p;<br>            p = q;<br>        &#125;<br>    &#125;<br>    delete []<span class="hljs-built_in">array</span>;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY, <span class="hljs-symbol">OTHER</span></span>&gt; *<span class="hljs-symbol">openHashTable</span>&lt;<span class="hljs-symbol">KEY, <span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">find</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>) <span class="hljs-symbol">const</span> &#123;<br>    <span class="hljs-built_in">int</span> pos;<br>    pos = key(x)%Size;<br>    node *p = <span class="hljs-built_in">array</span>[pos];<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr) &#123;<br>        <span class="hljs-keyword">if</span>(p -&gt; data.KEY == x) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p -&gt; data;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">openHashTable</span>&lt;<span class="hljs-symbol">KEY, <span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY, <span class="hljs-symbol">OTHER</span></span>&gt; &amp;<span class="hljs-symbol">x</span>) &#123;<br>    <span class="hljs-built_in">int</span> pos;<br>    pos = key(x.KEY)%Size;<br>    <span class="hljs-comment">/*node *p = array[pos];</span><br><span class="hljs-comment">    if(p == nullptr) &#123;</span><br><span class="hljs-comment">        array[pos] = new node(x,nullptr);</span><br><span class="hljs-comment">    &#125;else &#123;</span><br><span class="hljs-comment">        while(p -&gt; next!= nullptr) &#123;</span><br><span class="hljs-comment">            p = p -&gt; next;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        p -&gt; next = new node(x,nullptr);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//事实上你会发现，这种插入方法是自己给自己上复杂度</span><br>    <span class="hljs-comment">//所以我们更应该进行</span><br>    <span class="hljs-built_in">array</span>[pos] = new node(x,<span class="hljs-built_in">array</span>[pos]);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">openHashTable</span>&lt;<span class="hljs-symbol">KEY, <span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>) &#123;<br>    <span class="hljs-built_in">int</span> pos;<br>    pos = key(x)%Size;<br>    node *p = <span class="hljs-built_in">array</span>[pos];<br>    <span class="hljs-keyword">if</span>(p -&gt; next == <span class="hljs-literal">null</span>ptr) &#123;<br>        delete p;<br>        <span class="hljs-built_in">array</span>[pos] = <span class="hljs-literal">null</span>ptr;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(p -&gt; data.KEY == x) &#123;<br>            <span class="hljs-built_in">array</span>[pos] = p -&gt; next;<br>            delete p;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(p -&gt; next != <span class="hljs-literal">null</span>ptr) &#123;<br>                <span class="hljs-keyword">if</span>(p -&gt; next -&gt; data.KEY == x) &#123;<br>                    p -&gt; next = p -&gt; next -&gt; next;<br>                    delete p -&gt; next;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    p = p -&gt; next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL中的动态查找表">STL中的动态查找表</h2><p>STL中的动态查找表——<strong>关联容器</strong>，最基本的2个关键容器是set和map。set中的数据元素仅能包括一个字段，就是数据元素的关键字，它能有效地支待关于某个关键字是否存在的查询。map 的数据元素以（关键字，值）对的形式组织，如本书定义的集合元素类型。关键字用作为 map 中的索引，值表示所存储和读取的数据。</p><p>STL中采用红黑树实现（苯人其实认为AVL树并不比RBT慢，如果对这一点感兴趣可以参考<a href="https://github.com/skywind3000/avlmini">这个repo</a>）</p><p>在此感谢小狗<a href="https://github.com/zcychar">@zcychar</a>发现的这个repo<br>🥰🥰🥰</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic5</title>
    <link href="/2025/03/22/Mathematical-Logic5/"/>
    <url>/2025/03/22/Mathematical-Logic5/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Raytracing-ing-Build-my-first-ppm-file-I-❤️-Computer-Graphics">Before：Raytracing ing!Build my first ppm file!I ❤️ Computer Graphics!</h5><p><img src="/img/First.png" alt="PPM Hello World!"></p><h1>Mathematical Logic 5 Left Proof of Substitution Lemma 替换引理 &amp; Sequent Calculus (I)  序列演算</h1><h2 id="Left-Proof-of-Substitution-Lemma-替换引理">Left Proof of Substitution Lemma 替换引理</h2><p>对于项的替换引理证明还是比较直观容易的：<br><img src="/img/Sub%E8%AF%81%E6%98%8E1.png" alt="项替换Proof"></p><p>但对于公式来说，需要对公式进行归纳，这就有一定的难度了（特别是对∃的证明），外加由于此博客的Markdown渲染器并未配好(upd:配好了，也是终于能用Tex了)，就偷个懒直接了lecture-notes的图了🤡<br><img src="/img/Sub%E8%AF%81%E6%98%8E2.png" alt="公式替换Proof"></p><h2 id="Sequent-Calculus-Basic-Defintion">Sequent Calculus  Basic Defintion</h2><p>把证明当作数学对象来研究，这里的<strong>Sequent Calculus</strong>就是一种我们建立起来的证明系统。从已有的antecedent得到新的succedent。<br>$<br>Γ ⊢ Δ<br>$ <br>Γ 是前提集合，Δ是结论集合而Sequent Calculus要做的就是，设计一个演算系统，通过一系列规则从已知的序列推导出新的序列。</p><h3 id="Sequent-Rule-序列规则的形式">Sequent Rule 序列规则的形式</h3><p>$<br>\frac{Γ_1  φ_1…Γ_n  φ_n}{Γ’  φ}<br>$</p><h3 id="Derivability-可推导性">Derivability 可推导性</h3><p>如果可以从 Γ 推出 $\phi$ ，则记作<br>$<br>⊢ \Gamma \phi<br>$<br>这称为可推导</p><p>如果存在<strong>有限</strong>个公式<br>$<br>\phi_1 \phi_2 … \phi_n \in \Phi<br>$<br>使得<br>$<br>⊢ \phi_1 \phi_2 … \phi_n \phi<br>$<br>则称作公式$\phi$可从公式集$\Phi$中形式化证明或推导，记作<br>$<br>\Phi ⊢ \phi<br>$</p><h3 id="Correctness-正确性">Correctness 正确性</h3><p>A sequent $\Gamma$ $\phi$ is correct if<br>$<br>{\psi | \psi \in \Gamma} ⊢ \phi<br>$<br>即我们需要序列$\Gamma$中的所有公式都满足$\phi$，才能得到$\Gamma$ ⊢ $\phi$<br>引入的规则必须保证只产生正确的序列</p><h2 id="Structure-Rules-结构规则">Structure Rules 结构规则</h2><h3 id="Antecedent-前提规则">Antecedent 前提规则</h3><p>$<br>\frac{Γ ⊢ φ}{Γ’ ⊢ φ} \quad Γ ⊆ Γ’<br>$<br>如果某个结论可以从一组前提中推导出来，那么它也可以从更大的前提集合中推导出来。我们可以在推导过程中增加前提</p><h3 id="Assumption">Assumption</h3><p>$<br>\frac{}{\Gamma \vdash \varphi} \quad \text{如果 } \varphi \in \Gamma<br>$<br>如果某个公式已经是前提集合的一部分，那么它可以直接作为结论。换句话说，假设规则允许我们直接从前提集合中&quot;提取&quot;已知的公式作为结论，而无需进一步的推导。</p><h2 id="Connective-Rules-连接词规则">Connective Rules 连接词规则</h2><h3 id="Case-Analysis-案例分析规则">Case Analysis 案例分析规则</h3><p>我觉得就是<strong>分类讨论</strong>（遍历所有情况）<br>$<br>\frac{\Gamma, \psi \vdash \varphi \quad \Gamma, \neg \psi \vdash \varphi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合和某个假设 𝜓可以推导出结论 𝜑，并且从前提集合和 ¬𝜓也可以推导出𝜑，那么可以直接从前提集合推导出𝜑</p><h3 id="Contradiction-矛盾规则">Contradiction 矛盾规则</h3><p>我觉得就是<strong>反证的思想推出矛盾</strong><br>$<br>\frac{\Gamma, \neg \varphi \vdash \psi \quad \Gamma, \neg \varphi \vdash \neg \psi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合和 ¬𝜑可以推导出 𝜓和 ¬𝜓，那么可以直接从前提集合推导出 𝜑。</p><h3 id="v-introduction-in-antecedent-析取引入规则-前提版">v-introduction in antecedent 析取引入规则(前提版)</h3><p>$<br>\frac{\Gamma, \varphi \vdash \chi \quad \Gamma, \psi \vdash \chi}{\Gamma, \varphi \vee \psi \vdash \chi}<br>$<br>如果无论 𝜑为真还是 𝜓为真，𝜒都成立，那么从 𝜑∨𝜓（即 𝜑或𝜓中至少有一个为真）也可以推导出 𝜒。</p><h3 id="v-introduction-in-succedent-析取引入规则-结论版">v-introduction in succedent 析取引入规则(结论版)</h3><p>$<br>\frac{\Gamma \vdash \varphi}{\Gamma \vdash \varphi \vee \psi} \quad \text{or} \quad \frac{\Gamma \vdash \psi}{\Gamma \vdash \varphi \vee \psi}<br>$<br>如果𝜑为真，则𝜑∨𝜓也为真；如果𝜓为真，则𝜑∨𝜓也为真；因此只要𝜑和𝜓中的一个为真，𝜑∨𝜓就为真</p><h2 id="Derived-Rules-派生规则（可通过结构规则、连接词规则证明）">Derived Rules 派生规则（可通过结构规则、连接词规则证明）</h2><h3 id="排中律-Law-of-Excluded-Middle">排中律 Law of Excluded Middle</h3><p>$<br>\vdash \varphi \vee \neg \varphi<br>$<br>对于任何命题 𝜑，$ \varphi \vee \neg \varphi$  总是为真。也就是说，任何命题要么为真，要么为假，不存在中间状态</p><h3 id="修改的矛盾规则-Modified-Contradiction">修改的矛盾规则 Modified Contradiction</h3><p>$<br>\frac{\Gamma \vdash \psi \quad \Gamma \vdash \neg \psi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合 $\Gamma $ 可以推导出 $ \psi $，并且从前提集合 $ \Gamma $ 也可以推导出 $ \neg \psi $，那么可以直接从 $ \Gamma $ 推导出 $ \varphi $。</p><h3 id="链式推理-Chain-Deduction">链式推理 Chain Deduction</h3><p>$<br>\frac{\Gamma \vdash \varphi \quad \Gamma, \varphi \vdash \psi}{\Gamma \vdash \psi}<br>$<br>通过中间步骤 $ \varphi $，可以将前提集合 $ \Gamma $ 与结论 $ \psi $ 连接起来，形成一个推理链。</p><h2 id="Quantifier-Rules-量词规则">Quantifier Rules 量词规则</h2><h3 id="∃-introduction-in-succedent-结论版">∃-introduction in succedent(结论版)</h3><p>$<br>\frac{\Gamma \vdash \varphi(t/x)}{\Gamma \vdash \exists x \varphi}<br>$<br>如果存在一个具体的项  t ，使得 $ \varphi(t/x) $ 成立，那么可以推导出存在量词 $ \exists x \varphi $。</p><h3 id="∃-introduction-in-antecedent-前提版">∃-introduction in antecedent(前提版)</h3><p>$<br>\frac{\Gamma, \varphi(y/x) \vdash \psi}{\Gamma, \exists x \varphi \vdash \psi} \quad \text{如果 } y \notin \text{free}(\Gamma \cup {\exists x \varphi, \psi})<br>$<br>通过引入一个新的变量  y ，可以将存在量词 $ \exists x \varphi $ 引入前提中，从而推导出 $ \psi $。<br><strong>变量y选取的重要性</strong>（如果变量选取不当，可能会导致逻辑错误）<br>y 必须是一个新变量，不能在其他地方自由出现</p><h2 id="Equality-Rules-等式规则">Equality Rules 等式规则</h2><h3 id="Equality-等式的基本规则">Equality 等式的基本规则</h3><p>$<br>t \equiv t<br>$<br>等式的基本规则表明任何项 𝑡 都等于它自身。</p><h3 id="Substitution-替换规则">Substitution 替换规则</h3><p>$<br>\frac{\Gamma \vdash t \equiv t’ \quad \Gamma \vdash \varphi(t/x)}{\Gamma \vdash \varphi(t’/x)}<br>$<br>如果两个项  t  和  t’  相等，那么在任何公式中，可以用  t’  替换  t ，而不改变公式的真值。</p><h2 id="Soundness-可靠性定理">Soundness 可靠性定理</h2><p>$<br>\text{如果 } \Phi \vdash \varphi, \text{ 则 } \Phi \models \varphi.<br>$<br>如果从前提集合 $ \Phi $ 可以形式化推导出 $ \varphi $，那么 $ \varphi $ 在语义上也成立。也就是说，形式化推导的结果在语义上是正确的。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure17</title>
    <link href="/2025/03/20/Data-Structure17/"/>
    <url>/2025/03/20/Data-Structure17/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：感觉红黑树的实现好困难啊，即便是学完了一遍有些删除操作的细节都没有特别搞懂，感觉是一个实现和理解上都相当有难度的数据结构。今天要讲的是红黑树的一种特殊情况——AA树，希望会简单一点？（毕竟是B班写的呜呜呜）"><a href="#Before：感觉红黑树的实现好困难啊，即便是学完了一遍有些删除操作的细节都没有特别搞懂，感觉是一个实现和理解上都相当有难度的数据结构。今天要讲的是红黑树的一种特殊情况——AA树，希望会简单一点？（毕竟是B班写的呜呜呜）" class="headerlink" title="Before：感觉红黑树的实现好困难啊，即便是学完了一遍有些删除操作的细节都没有特别搞懂，感觉是一个实现和理解上都相当有难度的数据结构。今天要讲的是红黑树的一种特殊情况——AA树，希望会简单一点？（毕竟是B班写的呜呜呜）"></a>Before：感觉红黑树的实现好困难啊，即便是学完了一遍有些删除操作的细节都没有特别搞懂，感觉是一个实现和理解上都相当有难度的数据结构。今天要讲的是红黑树的一种特殊情况——AA树，希望会简单一点？（毕竟是B班写的呜呜呜）</h5><h1 id="Data-Structure-17-AA树"><a href="#Data-Structure-17-AA树" class="headerlink" title="Data Structure 17 AA树"></a>Data Structure 17 AA树</h1><h2 id="AA树的定义"><a href="#AA树的定义" class="headerlink" title="AA树的定义"></a>AA树的定义</h2><p>开幕雷击：《一种简单但却很有竞争力的平衡查找树》<br>好好好！</p><p>AA树是一类特殊的红黑树，它对红黑树增加了一个限制条件：左儿子不能为红色。<br>所以一棵AA树需要满足如下条件：</p><ol><li>每个节点都可以是红色或黑色。</li><li>根节点总是黑色。</li><li>叶节点（NULL）总是黑色。</li><li>红色节点的两个子节点必须都是黑色，即没有两个相邻的红色节点。</li><li>从根节点到 NULL 节点的每条路径都有相同数量的黑色节点。</li><li>红色节点只能作为右子节点。</li></ol><p>为了更进一步简化实现，可以用一种更直接的方法来表示平衡信息，即采用<strong>结点的层次</strong>，<strong>而不是结点的颜色</strong>。 所谓的<strong>结点层次</strong>就是结点到空结点的路径上左链的数量。<br>so，你自然会发现，AATree类中不再有枚举类型colorType了（欢呼.jpg）<br>如果把结构上的要求由颜色转为层次表示，左儿子肯定比它的父亲低1个层次，右儿子可能比父亲的层次低0或1层（右儿子可红可黑）。<br>将层次的概念的概念用图的方式表示就形成了<strong>水平链表示法</strong>。水平链连接层次相同的父子结点。下图就是一棵简单的AA树的水平链表示：<br><img src="/img/AA.png" alt="AA树水平链表示法"></p><p>这张可能更好看一些？<br><img src="/img/AA1.png" alt="AA树水平链表示法"></p><p>允许单独的右水平链接，但不允许连续的右水平链接；不允许左水平链接。</p><h2 id="AA树的存储实现"><a href="#AA树的存储实现" class="headerlink" title="AA树的存储实现"></a>AA树的存储实现</h2><p>由于AA树的平衡信息用层次表示，所以结点层次是一个成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AATree</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY,OTHER&gt;&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AANode</span>&#123;<br>        SET&lt;KEY,OTHER&gt; data;<br>        AANode *left;<br>        AANode *right;<br>        <span class="hljs-type">int</span> level; <span class="hljs-comment">//结点层次</span><br><br>        <span class="hljs-built_in">AANode</span>(<span class="hljs-type">const</span> SET&lt;KEY,OTHER&gt; &amp;d,AANode *l = <span class="hljs-literal">nullptr</span>,AANode *r = <span class="hljs-literal">nullptr</span>,<span class="hljs-type">int</span> lv = <span class="hljs-number">1</span>):<span class="hljs-built_in">data</span>(d),<span class="hljs-built_in">left</span>(l),<span class="hljs-built_in">right</span>(r),<span class="hljs-built_in">level</span>(lv)&#123;&#125;<br>    &#125;;<br>    AANode *root;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AATree</span>():<span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    ~<span class="hljs-built_in">AATree</span>() &#123;<br>        <span class="hljs-built_in">makeEmpty</span>(root);<br>    &#125;<br>    <span class="hljs-function">SET&lt;KEY,OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY,OTHER&gt; &amp;x)</span> </span>&#123;<br>        <span class="hljs-built_in">insert</span>(x,root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;k)</span> </span>&#123;<br>        <span class="hljs-built_in">remove</span>(k,root);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY,OTHER&gt; &amp;x,AANode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;k,AANode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">(AANode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LL</span><span class="hljs-params">(AANode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RR</span><span class="hljs-params">(AANode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(a &lt; b) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> b;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="AA树的运算实现"><a href="#AA树的运算实现" class="headerlink" title="AA树的运算实现"></a>AA树的运算实现</h2><p>AA树的查找和删除操作和RBT、AVL、BST均相同，不做实现了😢😉重点还是插入和删除操作</p><h3 id="AA树的插入操作"><a href="#AA树的插入操作" class="headerlink" title="AA树的插入操作"></a>AA树的插入操作</h3><p>与红黑树相同，新的数据元素总是插入为红色结点，但这可能会导致<strong>水平左链</strong>和<strong>连续水平右链</strong>的出现，显然与AA树的要求不符。<br>但无论哪种情况，都可以通过一次单旋转解决问题。如下图所示的两种情况：<br><img src="/img/%E6%B0%B4%E5%B9%B3%E5%B7%A6%E9%93%BE.png" alt="出现水平左链的情况"></p><p><img src="/img/%E6%B0%B4%E5%B9%B3%E5%8F%B3%E9%93%BE.png" alt="出现连续水平右链的情况"></p><p>我还是喜欢先上代码😣</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xl">template&lt;class KEY,class OTHER&gt;<br>void AATree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY,OTHER&gt; &amp;x,AANode *&amp;t) &#123;<br>    <span class="hljs-keyword">if</span>(t == nullptr) &#123;<br>        t = new AANode(x,nullptr,nullptr);<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(x.KEY &lt; t-&gt;</span><span class="hljs-keyword">data</span>.KEY) &#123;<br>        <span class="hljs-function"><span class="hljs-title">insert</span>(x,t -&gt;</span> left);<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(x.KEY &gt; t -&gt;</span> <span class="hljs-keyword">data</span>.KEY) &#123;<br>        <span class="hljs-function"><span class="hljs-title">insert</span>(x,t -&gt;</span> right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        return;<br>    &#125;<br>    LL(t);<br>    RR(t);<br>&#125;<br><br>template&lt;class KEY,class OTHER&gt;<br>void AATree&lt;KEY,OTHER&gt;::LL(AANode *&amp;t) &#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> != nullptr &amp;&amp; t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">level</span> == t -&gt;</span> level) &#123;<br>        AAN<span class="hljs-function"><span class="hljs-title">ode</span> *newRoot = t -&gt;</span> left;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = newRoot -&gt;</span> right;<br>        <span class="hljs-function"><span class="hljs-title">newRoot</span> -&gt;</span> right = t;<br>        t = newRoot;<br>    &#125;<br>&#125;<br><br>template&lt;class KEY,class OTHER&gt;<br>void AATree&lt;KEY,OTHER&gt;::RR(AANode *&amp;t) &#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> != nullptr &amp;&amp; t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">level</span> == t -&gt;</span> level) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> != nullptr &amp;&amp; t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">level</span> == t -&gt;</span> level) &#123;<br>            AAN<span class="hljs-function"><span class="hljs-title">ode</span> *newRoot = t -&gt;</span> right;<br>            <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = newRoot -&gt;</span> left;<br>            <span class="hljs-function"><span class="hljs-title">newRoot</span> -&gt;</span> left = t;<br>            t = newRoot;<br>            <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> level ++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AA树对水平左链、连续水平右链的调整在某些《不好的时候》可能会发生多次，下面就是一个例子：（这例子真不错）<br><img src="/img/AA%E8%B0%83%E6%95%B4.png" alt="Bad Situation"></p><p>不管是什么问题，都可以通过在向根回溯的过程中反复应用 LL&#x2F;RR 策略来解决。如果使用递归函数，这些回溯过程都是自动的。（就很好了😋）</p><h3 id="AA树的删除操作"><a href="#AA树的删除操作" class="headerlink" title="AA树的删除操作"></a>AA树的删除操作</h3><p>与BST相同，AA 树的删除也是归结为删除一个叶结点和删除一个只有一个儿子的结点。<br>AA 树的删除与 AVL 和红黑树一样，在结点被删除后要检查是否失去平衡。如果失去平衡，则需要调整。<br>我们分3种情况进行讨论：<br>（1） 删除结点是红结点，那么：无事发生<br>（2） 删除结点是黑结点，但有右孩子（这涵盖了一个条件：这个右孩子一定是红结点）。所以：直接将右孩子替换成被删结点，无事发生<br>（3）删除结点是黑结点，而且很不幸没有孩子。删除它将会影响平衡。</p><p>鉴于本人患有ADHD，所以还是先上代码😅😅😅</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xl">template&lt;class KEY,class OTHER&gt;<br>void AATree&lt;KEY,OTHER&gt;::remove(const KEY &amp;k,AANode *&amp;t) &#123;<br>    <span class="hljs-keyword">if</span>(t == nullptr) &#123;<br>        return;<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(k &lt; t -&gt;</span> <span class="hljs-keyword">data</span>.KEY) &#123;<br>        <span class="hljs-function"><span class="hljs-title">remove</span>(k,t -&gt;</span> left);<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(k &gt; t -&gt;</span> <span class="hljs-keyword">data</span>.KEY) &#123;<br>        <span class="hljs-function"><span class="hljs-title">remove</span>(k,t -&gt;</span> right);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> != nullptr &amp;&amp; t -&gt;</span> right != nullptr) &#123;<br>            AAN<span class="hljs-function"><span class="hljs-title">ode</span> *tmp = t -&gt;</span> right;<span class="hljs-comment">//找到下一个结点替代当前结点</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(tmp -&gt;</span> left != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">tmp</span> = tmp -&gt;</span> left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span> = tmp -&gt;</span> <span class="hljs-keyword">data</span>;<br>            <span class="hljs-function"><span class="hljs-title">remove</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>.KEY,t -&gt;</span> right);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//划归到那2种情况</span><br>            AANode *oldNode = t;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> left != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">t</span> = t -&gt;</span> left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">t</span> = t -&gt;</span> right;<br>            &#125;<br>            delete oldNode;<br>            return;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//最后进行平衡的调整</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> == nullptr || t -&gt;</span> right == nullptr) &#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> level = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">level</span> = min(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">level</span> ,t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> level) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> != nullptr &amp;&amp; t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">level</span> &gt; t -&gt;</span> level) &#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">level</span> = t -&gt;</span> level;<br>    &#125;<br>    LL(t);<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> right != nullptr) &#123;<br>        LL(<span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> != nullptr &amp;&amp; t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> right != nullptr) &#123;<br>        LL(<span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> right);<br>    &#125;<br>    RR(t);<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> right != nullptr) &#123;<br>        RR(<span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> right);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>是不是关于调整的部分几乎完全看不懂？没事，因为我也一样😰😰😰<br>如果需要，对根结点执行 LL 旋转；如果需要，对根结点的右儿子执行 LL 旋转；如果需要，对根结点的右儿子的右儿子执行 LL 旋转；如果需要，对根结点执行 RR 旋转；如果需要，对根结点的右儿子执行RR旋转。<br>最坏情况下需要进行3次LL操作和2次RR操作<br>luogu上的一篇文章很详细地用图片展示了这一过程，指路👇：<br><a href="https://www.luogu.com.cn/article/9gwe0tgz">AA树的删除操作</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AA树确实比AVL和RBT来的简洁不少。但是我个人认为AA树的删除操作可以通过具体的例子来说服我，但是依然从理论上来说并不能让我完全信服，我觉得我们有必要进行更深入的思考。</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>Balanced Binary Tree</tag>
      
      <tag>Red Black Tree</tag>
      
      <tag>AA Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构5</title>
    <link href="/2025/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"/>
    <url>/2025/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-5-优先级队列"><a href="#数据结构-5-优先级队列" class="headerlink" title="数据结构 5 优先级队列"></a>数据结构 5 优先级队列</h1><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>结点间的关系由结点的优先级决定，而不是入队的先后顺序。</p><p>我们最先想到的是使用线性结构进行优先级队列的实现</p><ul><li>如果按优先级排序<br>但是入队操作复杂度达到了O(N)</li><li>如果按到达时间排序<br>但是出队操作复杂度达到了O(N)</li></ul><p>于是我们考虑…</p><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>堆是一棵完全二叉树（<strong>结构性</strong>），且满足下列2个条件之一：父结点小于等于子结点（小根堆）or 父结点大于等于子结点（大根堆）（<strong>有序性</strong>）</p><p>基于二叉堆的优先级队列<br>成员函数：实现队列的所有操作<br>数据成员：基于二叉堆的结构性（完全二叉树）可以使用顺序存储——数组</p><h2 id="优先级队列的定义"><a href="#优先级队列的定义" class="headerlink" title="优先级队列的定义"></a>优先级队列的定义</h2><p>入队enQueue的过程：</p><ul><li>插入在最底层的一个空位</li><li>向上移动到合适的位置（<strong>向上过滤</strong>）<br>和父结点进行比较</li><li>时间复杂度：最坏的时间性能是对数级的O(logN)，也可通过数学证明平均时间复杂度</li></ul><p>出队deQueue的过程：</p><ul><li>删除根结点</li><li>将最后一个结点移到根结点（保持结构性）</li><li>向下移动到合适的位置（<strong>向下过滤</strong>）</li><li>很少有能提前结束的</li></ul><p>建堆：<br><strong>方法一</strong>：在空堆中执行N次连续插入<br>中间不保证二叉堆结构</p><p><strong>方法二</strong>：不考虑中间状态，保证所有元素加入后满足堆的特性<br>最坏情况下时间复杂度达到O(N)（在<a href="https://janez-uint.github.io/2025/03/01/Introduction-to-Algorithms1/">MIT6.006 1</a>中介绍了证明）<br>将左子树和右子树调整成堆<br>对根结点调用percolateDown，以恢复堆的有序性<br>也就是说，对<strong>所有非叶结点向下过滤</strong></p><h2 id="其他堆"><a href="#其他堆" class="headerlink" title="其他堆"></a>其他堆</h2><p>D-堆 “完全D叉树” O(logN)<br>可能用于队列太大，要放在外存中时</p><p><strong>左堆、斜堆、二项堆——支持归并</strong></p><h3 id="左堆"><a href="#左堆" class="headerlink" title="左堆"></a>左堆</h3><p>满足堆的有序性，但平衡稍弱一些的堆，不要求是完全二叉树<br>npl(x)为<strong>x到不满两个孩子的节点的最短路径</strong>，即具有0个或一个孩子的结点的npl为0，npl(NULL) &#x3D; -1<br><strong>对每个节点x，左孩子的npl不小于右孩子的npl</strong><br>显然，左堆是一棵像左倾斜的树<br>归并方法：将根结点稍大的堆与另一个堆的右子树归并（对于小根堆） 不会很偏<br>递归终止条件：当某个堆为空时，另一个堆就是归并结果。<br>入队、出队操作均可以用归并操作实现</p><h3 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h3><p>斜堆是自调整的左堆，将根结点较大的堆和另一个堆的右子树归并，然后交换左右子树（更简单，不用维护左偏值信息）</p><h3 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h3><p>一个二项树的集合，每个高度的二项树至多出现一次。</p><p><strong>二项树</strong><br>有序性：满足堆的有序性<br>结构性：高度为0的二项树是单个节点，高度为k的二项树Bk是将一棵Bk-1加到另一棵Bk-1的根上</p><p>由于元素数可以二进制表示，故堆的结构是唯一的。</p><p><strong>归并操作</strong>：<br>由低到高依次归并两个优先级队列中高度相同的树。<br>高度相同的树归并时，将根结点大的作为根结点小的子树（小根堆）。<br>若由于前一次归并导致有3棵高度形同的树，则归并其中2棵。<br>由于N个结点最多有logN棵二项树，故时间复杂度为O(logN)。</p><p><strong>入队操作</strong>：<br>将入队结点形成一棵单结点的树组成的集合，归并2个集合。<br>最坏情况下，原集合每个高度的树都有，则时间复杂度为O(logN)。</p><p><strong>删除操作</strong>：<br>找出具有最小根值的树T<br>将T从原先的集合中删掉，在T中删除根结点，归并T与原先的集合。<br>最坏情况时间复杂度依然是O(logN)。</p><h2 id="STL中的优先级队列"><a href="#STL中的优先级队列" class="headerlink" title="STL中的优先级队列"></a>STL中的优先级队列</h2><p>头文件：#include<queue><br>类模板：priority_queue<br>实现方式：二叉堆</p><h2 id="排队系统的模拟"><a href="#排队系统的模拟" class="headerlink" title="排队系统的模拟"></a>排队系统的模拟</h2><p>单服务台系统 VS 多服务台系统<br>多服务台系统中，需要将产生的到达事件和离开事件都加入优先级队列中。</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Priority Queue</tag>
      
      <tag>Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure16</title>
    <link href="/2025/03/15/Data-Structure16/"/>
    <url>/2025/03/15/Data-Structure16/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：2023-12-31——2025-03-15，440天后，又在影院与LaLaLand重逢。2023-12-31，上完了最后一节课，惆怅，迷茫，又适逢LaLaLand重映，第一次在影院看了（以前在家看过不少遍）。我承认，就连23年的年终总结有近一半也与这个我未曾谋面的人有关。在那个时间点看LaLaLand真的让我很久都没有释怀，也曾有过很多冲动的想法，不想高考，想飞去Melbourne，想去曾经学在的Berkeley-CA。这是我第一次将这件事说出来，那段懵懂的喜欢就像LA傍晚的天空那样，是浪漫的紫色。说不清楚讲不明白，我到底是曾经喜欢过，还只是向往一段Mia和Seb的爱情与梦想，甚至说只是想去一次LA吧。LA可能是我除了南京、上海之外最熟悉的城市了（虽然从未去过）。幻想过格里菲斯天文台的浪漫，比弗利山庄的纸醉金迷，SantaMonica的热情…也幻想着天使之城有像Seb那样执着于理想的年轻钢琴家，契合的灵魂，在蓝调的格里菲斯公园共舞…我的vx、github头像一直是灯光下Seb的演奏，可能我喜欢的人，是Seb那样的吧。依然是久久不能平复。曾一次又一次地告诉自己，坦然接受生命中的失去与遗憾，却发现风起时，意难平。或许最遗憾的是，不会钢琴吧…"><a href="#Before：2023-12-31——2025-03-15，440天后，又在影院与LaLaLand重逢。2023-12-31，上完了最后一节课，惆怅，迷茫，又适逢LaLaLand重映，第一次在影院看了（以前在家看过不少遍）。我承认，就连23年的年终总结有近一半也与这个我未曾谋面的人有关。在那个时间点看LaLaLand真的让我很久都没有释怀，也曾有过很多冲动的想法，不想高考，想飞去Melbourne，想去曾经学在的Berkeley-CA。这是我第一次将这件事说出来，那段懵懂的喜欢就像LA傍晚的天空那样，是浪漫的紫色。说不清楚讲不明白，我到底是曾经喜欢过，还只是向往一段Mia和Seb的爱情与梦想，甚至说只是想去一次LA吧。LA可能是我除了南京、上海之外最熟悉的城市了（虽然从未去过）。幻想过格里菲斯天文台的浪漫，比弗利山庄的纸醉金迷，SantaMonica的热情…也幻想着天使之城有像Seb那样执着于理想的年轻钢琴家，契合的灵魂，在蓝调的格里菲斯公园共舞…我的vx、github头像一直是灯光下Seb的演奏，可能我喜欢的人，是Seb那样的吧。依然是久久不能平复。曾一次又一次地告诉自己，坦然接受生命中的失去与遗憾，却发现风起时，意难平。或许最遗憾的是，不会钢琴吧…" class="headerlink" title="Before：2023.12.31——2025.03.15，440天后，又在影院与LaLaLand重逢。2023.12.31，上完了最后一节课，惆怅，迷茫，又适逢LaLaLand重映，第一次在影院看了（以前在家看过不少遍）。我承认，就连23年的年终总结有近一半也与这个我未曾谋面的人有关。在那个时间点看LaLaLand真的让我很久都没有释怀，也曾有过很多冲动的想法，不想高考，想飞去Melbourne，想去曾经学在的Berkeley,CA。这是我第一次将这件事说出来，那段懵懂的喜欢就像LA傍晚的天空那样，是浪漫的紫色。说不清楚讲不明白，我到底是曾经喜欢过，还只是向往一段Mia和Seb的爱情与梦想，甚至说只是想去一次LA吧。LA可能是我除了南京、上海之外最熟悉的城市了（虽然从未去过）。幻想过格里菲斯天文台的浪漫，比弗利山庄的纸醉金迷，SantaMonica的热情…也幻想着天使之城有像Seb那样执着于理想的年轻钢琴家，契合的灵魂，在蓝调的格里菲斯公园共舞…我的vx、github头像一直是灯光下Seb的演奏，可能我喜欢的人，是Seb那样的吧。依然是久久不能平复。曾一次又一次地告诉自己，坦然接受生命中的失去与遗憾，却发现风起时，意难平。或许最遗憾的是，不会钢琴吧…"></a>Before：2023.12.31——2025.03.15，440天后，又在影院与LaLaLand重逢。2023.12.31，上完了最后一节课，惆怅，迷茫，又适逢LaLaLand重映，第一次在影院看了（以前在家看过不少遍）。我承认，就连23年的年终总结有近一半也与这个我未曾谋面的人有关。在那个时间点看LaLaLand真的让我很久都没有释怀，也曾有过很多冲动的想法，不想高考，想飞去Melbourne，想去曾经学在的Berkeley,CA。这是我第一次将这件事说出来，那段懵懂的喜欢就像LA傍晚的天空那样，是浪漫的紫色。说不清楚讲不明白，我到底是曾经喜欢过，还只是向往一段Mia和Seb的爱情与梦想，甚至说只是想去一次LA吧。LA可能是我除了南京、上海之外最熟悉的城市了（虽然从未去过）。幻想过格里菲斯天文台的浪漫，比弗利山庄的纸醉金迷，SantaMonica的热情…也幻想着天使之城有像Seb那样执着于理想的年轻钢琴家，契合的灵魂，在蓝调的格里菲斯公园共舞…我的vx、github头像一直是灯光下Seb的演奏，可能我喜欢的人，是Seb那样的吧。依然是久久不能平复。曾一次又一次地告诉自己，坦然接受生命中的失去与遗憾，却发现风起时，意难平。或许最遗憾的是，不会钢琴吧…</h4><h4 id="City-of-star-Are-you-shining-just-for-me"><a href="#City-of-star-Are-you-shining-just-for-me" class="headerlink" title="City of star  Are you shining just for me"></a>City of star  Are you shining just for me</h4><h4 id="And-you-will-be-all-right"><a href="#And-you-will-be-all-right" class="headerlink" title="And you will be all right."></a>And you will be all right.</h4><h4 id="记得高三的时候看过wxl的一篇作文，写的是爱乐之城中红与蓝的色调，好像还挺契合今天红黑树的主题的😢叫红蓝树也未尝不可，反正都是RBT"><a href="#记得高三的时候看过wxl的一篇作文，写的是爱乐之城中红与蓝的色调，好像还挺契合今天红黑树的主题的😢叫红蓝树也未尝不可，反正都是RBT" class="headerlink" title="记得高三的时候看过wxl的一篇作文，写的是爱乐之城中红与蓝的色调，好像还挺契合今天红黑树的主题的😢叫红蓝树也未尝不可，反正都是RBT"></a>记得高三的时候看过wxl的一篇作文，写的是爱乐之城中红与蓝的色调，好像还挺契合今天红黑树的主题的😢叫红蓝树也未尝不可，反正都是RBT</h4><h1 id="Data-Structure-16-红黑树"><a href="#Data-Structure-16-红黑树" class="headerlink" title="Data Structure 16 红黑树"></a>Data Structure 16 红黑树</h1><p>首先声明一下，鉴于本人已经通过了map大作业的AVL实现（就是炫耀，盐都不盐了🤣😉），且RBT是A班的要求，与我无关，故我不会对RBT进行详细的代码实现，更侧重于操作的思想</p><h2 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h2><p>一种平衡树，常用来替换 AVL ，时间代价同样是O(logN)的。它是一棵具有下列特点的二叉查找树：<br>（1）每个结点被染成红色或黑色<br>（2）<strong>根结点是黑色的</strong><br>（3）如果一个结点是<strong>红色</strong>的，那么它的<strong>儿子结点必须是黑色的</strong>。<br>（4）从任何一个结点出发到空结点（即空指针指向的结点）的路径上，<strong>必须包含相同数量的黑色结点</strong>。</p><p>从红黑树的定义可知，红黑树是比 AVL 树平衡性更弱的平衡树（AVL树具有严格平衡性，所以在查找操作的时间性能上要优于RBT）。在任何一条路径上不能有两个连续的红结点。因此，在每条路径上红结点的个数都是有限的。也就是说，各条路径的长度差是有限的。最长的路径是最短路径的2倍。<br>下图是一棵红黑树：<br><img src="/img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="正确的红黑树"></p><p>而这就不是红黑树了：<br><img src="/img/%E4%BC%AA%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="虚假的红黑树"></p><p>我们容易通过数学归纳的方法得到，对于一棵有N个结点的红黑树，其高度最多为2log(N + 1)。这里Call back一下AVL的高度最多为1.44logN，还是要略好一些的😝</p><h2 id="红黑树的存储实现"><a href="#红黑树的存储实现" class="headerlink" title="红黑树的存储实现"></a>红黑树的存储实现</h2><p>相较于先前写过的BST、AVL，RBT结点多了一个枚举类型colorType，用于记录该点的颜色。但与BST、AVL不同的是，在BST、AVL中，我们采用了递归的方式来实现insert、remove等操作，所以insert、remove等拥有私有成员函数，但是红黑树的insert、remove操作采用<strong>非递归</strong>的方式实现，不需要私有成员函数了。</p><h2 id="红黑树的插入实现"><a href="#红黑树的插入实现" class="headerlink" title="红黑树的插入实现"></a>红黑树的插入实现</h2><p><strong>红黑树的插入操作</strong><br>如果将新结点着色为黑色，那么将违背红黑树的性质4，因为这将导致从根结点到插入结点的路径上的黑结点个数比其他路径上的黑结点个数多。因此，只能将新插入的结点着色为<strong>红色</strong>。<strong>如果新插入结点的父结点是黑色的，则平衡没有被破坏，整个插入过程结束</strong>。但如果<strong>新插入的结点的父结点是红色的</strong>，就将出现连续的红结点，这将违背红黑树的性质3。为解决这个问题，<strong>基本的方法是修改结点的着色和旋转</strong>。</p><p><strong>红黑树的旋转操作</strong><br>分为2种情况：<br><strong>1.父结点 P 的兄弟结点 S 是黑色的</strong>（一红一黑）<br>（1）插入结点是外侧结点<br>我们进行LLb或RRb旋转，如下图所示：<br><img src="/img/LLb.png" alt="LLb情况"><br><img src="/img/RRb.png" alt="RRb情况"><br>省流：其实就是AVL的旋转 LL or RR + 颜色调整</p><p>（2）插入结点是内侧结点<br>我们进行LRb或RLb旋转，如下图所示：<br><img src="/img/LRb.png" alt="LRb情况"><br><img src="/img/RLb.png" alt="RLb情况"><br>省流：其实就是AVL的旋转 LR or RL + 颜色调整</p><p><strong>2.父结点 P 的兄弟结点 S 是红色的</strong>（两红）<br>这种情况的处理真妙！用不着什么旋转，只要把这对双红兄弟变成双黑，把根结点变成红色即可，维护了性质4，如下图所示：<br><img src="/img/%E7%9D%80%E8%89%B2.png" alt="重新着色"></p><p>but:真的有这么容易吗？注意到根结点成了红色，但如果根结点的父亲也是红色呢？那就与性质3相违背了，所以我们还需要<strong>向上调整</strong>，最坏可能会到根</p><h2 id="红黑树好在哪儿😅"><a href="#红黑树好在哪儿😅" class="headerlink" title="红黑树好在哪儿😅"></a>红黑树好在哪儿😅</h2><p>目前的感觉是不仅树比AVL高，还比AVL难写（幸好不用写🤣）<br>但其实，优势其实在调整上。写完AVL其实不难发现，插入删除很容易就会让某个根结点失去平衡性，需要多次的调整，往往还不是一次调整可以结束的，需要不断递归向上。但是红黑树有1&#x2F;2的情况是无需调整的（对应根结点为黑色），剩余1&#x2F;2的操作，涉及旋转的只需进行一次调整，而重新着色的有1&#x2F;2的概率只进行一次操作，剩下的向上调整其实概率已经很小了。且又递归地每上一层概率更小，因此，红黑树在维护平衡性方面时间性能相当不错。<br>这大概就是 Java 中的 TreeMap、JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的原因吧。</p><h2 id="红黑树的删除实现"><a href="#红黑树的删除实现" class="headerlink" title="红黑树的删除实现"></a>红黑树的删除实现</h2><p>删除操作首先使用普通的二叉查找树的删除算法删除结点，然后进行旋转及颜色的调整。BST的删除最终可以归结到2种情况：删除叶结点和删除只有一个儿子的结点。我们只需解决<strong>这两种情况下的着色问题</strong>。</p><p>如果被删结点是红色的，删除操作结束，因为并未引起红黑树性质的改变。但是，<strong>若被删结点是黑色的</strong>，将会引起和该结点相关的路径上的黑色结点数量的减少，从而不满足红黑树的性质4。<br>从这里可以得到一个启发：如果能够保证被删结点是<strong>红色叶结点</strong>，就可以简化删除操作。那么如何做到这一点呢？<br>设结点X是所遇到的当前结点，T是它的兄弟结点，而结点P是它们的父结点。对每个遇到的X，都试图把它变成红色。当最后遇到被删结点时，由于它是红色的叶结点，可以直接删除。</p><p>在自根向下的搜索过程中，当搜索到一个新结点时，可以确信其父结点P是红色的，而结点X和T是黑色的（因为不可能有两个连续的红色结点存在）。根据X的颜色，可以分成两种情况。</p><p>下面进行分类讨论：<br><strong>1.结点 X 有两个黑色儿子</strong>  意味着结点X可以放心地变红<br>（1）T 有两个黑色儿子，调整颜色，将 P 变成黑色， X 和 T 变成红色，如下图所示：<br><img src="/img/erase1.png" alt="Erase1"></p><p>（2）T 有一个外侧的红色儿子，让 T 和 P 进行一次单旋转，并重新着色，如下图所示：<br><img src="/img/erase2.png" alt="Erase2"></p><p>（3）T 有一个内侧的红色儿子，对 P 执行一次双旋转，让 T 的红儿子旋转到 P ，并重新着色，如下图所示：<br><img src="/img/erase3.png" alt="Erase3"><br>注意：如果T有2个红色儿子，那么单旋双旋均可（显然单旋简单一些）</p><p><strong>2.结点 X 至少有一个儿子是红色的</strong><br><strong>如果 X 不是被删结点</strong>：<br>可以继续前进到下一层。<br>（1）幸运的话，“前进”一层之后，新的 X 正好就是红色结点😋，回归到情况一，问题就解决了，这大概有一半的可能性。 （走向红色）<br>（2）否则，当前结点 X 是黑色的（走向黑色），结点 T 是红色的，父结点 P 是黑色的，如下图所示：<br><img src="/img/Erase4.png" alt="Bad Situation"><br>进行一次旋转：<br><img src="/img/erase5.png" alt="Erase4"><br>由于旋转后结点 X 仍然不是红色的，但父结点已经是红色的，即转换为情况一，按情况一继续调整结点 X 的颜色。</p><p><strong>如果X不巧就是被删结点</strong>（且有2个儿子）<br>（1）有2个儿子<br>此时将在右子树上寻找“替身”。如果 X 的右孩子是红结点，无须调整，直接沿右孩子往下走一层。否则左孩子一定是个红结点。对 X 执行一次 LL 旋转使 X 变成红色。<br>（2）只有1个儿子<br>则该孩子必为红结点，将 X 与孩子结点做一个单旋转。此时 X 变成了红结点。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>其实我删除操作有一小部分并不是很理解，但已经深切地认识到RBT的调整着色的思想，且RBT调整的次数确实要小于AVL，性能上有一定的优越性。但是insert操作应该能写出来，remove是真的难写啊！（相较之下AVL的remove操作已经好写很多了）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/cy973071263/article/details/122543826">【数据结构】史上最好理解的红黑树讲解，让你彻底搞懂红黑树</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>AVL</tag>
      
      <tag>Balanced Binary Tree</tag>
      
      <tag>Red Black Tree</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic4</title>
    <link href="/2025/03/14/Mathematical-Logic4/"/>
    <url>/2025/03/14/Mathematical-Logic4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"><a href="#Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜" class="headerlink" title="Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"></a>Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜</h5><h5 id="今天是3月14日，𝜋节。2022-03-14-2025-03-14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。"><a href="#今天是3月14日，𝜋节。2022-03-14-2025-03-14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。" class="headerlink" title="今天是3月14日，𝜋节。2022.03.14 - 2025.03.14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。"></a>今天是3月14日，𝜋节。2022.03.14 - 2025.03.14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。</h5><h1 id="Mathematical-Logic-4-同构引理的证明-替换"><a href="#Mathematical-Logic-4-同构引理的证明-替换" class="headerlink" title="Mathematical Logic 4 同构引理的证明 &amp; 替换"></a>Mathematical Logic 4 同构引理的证明 &amp; 替换</h1><h2 id="Call-back-previous-一阶逻辑语义"><a href="#Call-back-previous-一阶逻辑语义" class="headerlink" title="Call back previous 一阶逻辑语义"></a>Call back previous 一阶逻辑语义</h2><p><strong>同构</strong><br>存在一个A -&gt; B 的映射满足：</p><ol><li>是双摄</li><li>保持关系（n元关系运算符）</li><li>保持运算（n元函数运算符）</li><li>保持常量（常数c）</li></ol><p>则结构A、结构B同构</p><p>在上周的作业中，我们证明了同构是一种等价关系。回忆，等价关系需要满足三个条件：</p><ol><li>自反性</li><li>对称性</li><li>传递性</li></ol><h2 id="同构引理的证明"><a href="#同构引理的证明" class="headerlink" title="同构引理的证明"></a>同构引理的证明</h2><p>Recall:<br>A、B是2个同构的S-结构，那么对于所有S-sentence 𝜑，有：</p><p>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑 </p><p>Prof:<br>由重合引理可知：<br>A |&#x3D; 𝜑 ⟺ (A,β) |&#x3D; 𝜑<br>B |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>so A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑  ⟺  (A,β) |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>定义β^𝜋(x) :&#x3D; 𝜋(β(x))<br>那么我们要证：<br>(A,β) |&#x3D; 𝜑 ⟺ (B,β^𝜋) |&#x3D; 𝜑 (𝜑 是任意S-公式)<br>&#x2F;&#x2F; 这不就从句子推广到公式上了嘛 </p><p>也就是要证明：<br>I:&#x3D; (A,β) I^𝜋:&#x3D; (B,β^𝜋)<br>𝜋(I(t)) &#x3D; I^𝜋(t)</p><p>这里改写成解释，也就可以进行结构归纳法（对公式的归纳了）<br>略</p><h2 id="项的替换-Substitution"><a href="#项的替换-Substitution" class="headerlink" title="项的替换 Substitution"></a>项的替换 Substitution</h2><p>设t 是一个S-term，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义项的替换：<br><img src="/img/%E6%9B%BF%E6%8D%A2.png" alt="替换"></p><p>(a)如果t &#x3D; x是一个变量，那么：<br><img src="/img/%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="变量替换"></p><p>(b)如果t &#x3D; c是一个常数，那么：<br><img src="/img/%E5%B8%B8%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="常量替换"></p><p>(c)对于一个函数项<br><img src="/img/%E5%87%BD%E6%95%B0%E9%A1%B9%E6%9B%BF%E6%8D%A2.png" alt="函数项替换"></p><h2 id="公式上的替换"><a href="#公式上的替换" class="headerlink" title="公式上的替换"></a>公式上的替换</h2><p>设𝜑 是一个S-formula，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义：<br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A21.png" alt="公式替换"><br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A22.png" alt="公式替换"></p><h2 id="赋值上的替换（对于自由变量）"><a href="#赋值上的替换（对于自由变量）" class="headerlink" title="赋值上的替换（对于自由变量）"></a>赋值上的替换（对于自由变量）</h2><p><img src="/img/%E8%B5%8B%E5%80%BC%E6%9B%BF%E6%8D%A2.png" alt="赋值替换"></p><h2 id="替换引理"><a href="#替换引理" class="headerlink" title="替换引理"></a>替换引理</h2><p>替换引理分为2个部分：</p><h3 id="项的替换引理"><a href="#项的替换引理" class="headerlink" title="项的替换引理"></a>项的替换引理</h3><p>对一个项 𝑡 进行替换后，其解释等于在原解释 𝐼 的基础上，将变量x0,…,xr替换为项t0,…,tr的解释<br><img src="/img/%E9%A1%B9%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%90%86.png" alt="项的替换引理"></p><h3 id="公式的替换引理"><a href="#公式的替换引理" class="headerlink" title="公式的替换引理"></a>公式的替换引理</h3><p>对一个公式 𝜑 进行替换后，其真值等于在原解释 𝐼 的基础上，将变量x0,…,xr替换为项t0,…,tr的解释后的真值<br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%90%86.png" alt="公式的替换引理"></p><h3 id="二者均为语法替换-⟺-语义更新"><a href="#二者均为语法替换-⟺-语义更新" class="headerlink" title="二者均为语法替换 ⟺  语义更新"></a>二者均为语法替换 ⟺  语义更新</h3>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Of DS——Monotonic Stack &amp; Queue</title>
    <link href="/2025/03/13/AlgorithmOfDS1/"/>
    <url>/2025/03/13/AlgorithmOfDS1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：最近在de-STLite的最后一个数据结构map。周二用一个下午-一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️">Before：最近在de STLite的最后一个数据结构map。周二用一个下午+一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️</h5><h1>Algorithm of Data Structure 1 单调栈&amp;单调队列&amp;栈模拟递归</h1><h2 id="单调栈">单调栈</h2><p>定义：栈内元素满足某种单调性质，可以单增也可以单减</p><p>在处理每个元素时，将其与栈顶元素进行比较，如果当前元素大于（或小于）栈顶元素，则将栈顶元素出栈，直到满足单调性质为止。然后，将当前元素入栈，继续处理下一个元素（<strong>当前元素必须入栈</strong>）</p><p>单调栈可以快速找到每个元素的下一个更大（或更小）元素，时间复杂度为O(n)（n为序列的长度）</p><p>具体来说，<strong>单调递增栈可用于寻找下一个更小元素，而单调递减栈可用于寻找下一个更大元素</strong>，并且只需要遍历整个序列一次</p><p>Example：找到数列中每个元素下一个比它大的元素下标（1 — base）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈顶位置</span><br>stack[top] = <span class="hljs-number">0</span>; <span class="hljs-comment">//a[0]入栈  stack数组记录栈内元素下标</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span> &amp;&amp; a[stack[top]] &lt; a[i])&#123;<br>        ans[stack[top]] = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//记录答案</span><br>        top --; <span class="hljs-comment">//当前栈顶元素出栈</span><br>    &#125;<br>    stack[++ top] = i;<br>&#125;<br><span class="hljs-keyword">while</span>(top &gt;=<span class="hljs-number">0</span>)&#123;<br>    ans[stack[top --]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈内剩余元素不存在下一个比它大的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：需要一个stack数组记录栈内情况，一个top记录栈顶位置，一个a存储原本序列数据，和一个ans存储答案</p><h2 id="单调栈例题">单调栈例题</h2><p><a href="https://www.luogu.com.cn/problem/P1901">luogu P1901</a></p><ul class="lvl-0"><li class="lvl-2"><p>某地有N个能量发射站排成一行，每个发射站i都有不相同的高度Hi，并能向两边（两端的发射站只能向一边）同时发射能量值为Vi的能量，发出的能量只被两边最近的且比它高的发射站接收。</p></li><li class="lvl-2"><p>显然，每个发射站发出的能量有可能被0~2个其他发射站所接受。</p></li><li class="lvl-2"><p>请计算出接收最多能量的发射站接收的能量是多少。</p></li></ul><p>小黄题，15分钟速通😋 Strong女也只能切黄题了呜呜呜</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>main() &#123;<br>   <span class="hljs-built_in"> int </span>n;<br>    cin &gt;&gt; n;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        cin &gt;&gt; h1[i];<br>        cin &gt;&gt; v1[i];<br>    &#125;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        h2[i] = h1[n - 1 -i];<br>        v2[i] = v1[n - 1- i];<br>    &#125;<br>   <span class="hljs-built_in"> int </span>top1 = 0;<br>   <span class="hljs-built_in"> int </span>top2 = 0;<br>    stack1[top1] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top1 &gt;= 0 &amp;&amp; h1[stack1[top1]] &lt; h1[i]) &#123;<br>            ans1[stack1[top1]] = i;<br>            total1[i] += v1[stack1[top1]];<br>            top1 --;<br>        &#125;<br>        stack1[++ top1] = i;<br>    &#125;<br>    while(top1 &gt;= 0) &#123;<br>        ans1[stack1[top1 --]] = -1;<br>    &#125;<br><br>    stack2[top2] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top2 &gt;= 0 &amp;&amp; h2[stack2[top2]] &lt; h2[i]) &#123;<br>            ans2[stack2[top2]] = i;<br>            total2[i] += v2[stack2[top2]];<br>            top2 --;<br>        &#125;<br>        stack2[++ top2] = i;<br>    &#125;<br>    while(top2 &gt;= 0) &#123;<br>        ans2[stack2[top2 --]] = -1;<br>    &#125;<br><br>   <span class="hljs-built_in"> int </span>maxE = 0;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>       <span class="hljs-built_in"> int </span>current = total1[i] + total2[n - 1 - i];<br>        if(current &gt; maxE) &#123;<br>            maxE = current;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><p>高效地维护队列中元素的单调性（递增或递减），同时支持在队列两端的插入和删除操作</p><ul class="lvl-0"><li class="lvl-2"><p>可在队首出队</p></li><li class="lvl-2"><p>仅在队尾入队</p></li><li class="lvl-2"><p>如果影响单调性，可能从队尾出队</p></li></ul><p>省流：其实是一个双端队列（deque）（这不是隔壁这次大作业嘛🤣有福了）</p><p><strong>它通常用于解决需要在一个滑动窗口（或固定长度的子数组）内找到最大值或最小值的问题</strong></p><ul class="lvl-0"><li class="lvl-2"><p>插入元素：当新元素进入窗口时，从队列尾部移除所有小于新元素的元素，然后将新元素插入队列尾部。</p></li><li class="lvl-2"><p>移除元素：当元素离开窗口时，如果它是队列头部的元素，则从队列头部移除。</p></li><li class="lvl-2"><p>获取最值：队列头部的元素始终是当前窗口的最大值（或最小值，取决于单调性）</p></li></ul><p>可实现在O(1)的时间复杂度下获得最值比如我们现在要一个递增的单调队列</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> minFront = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> minBack = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-built_in">num</span>[i] = read();<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; minWin[minFront] &lt;= i - k)&#123; <span class="hljs-comment">//队头指针小于等于队尾指针 &amp;&amp; 队头元素索引已经不在窗口范围内</span><br>        ++ minFront;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; <span class="hljs-built_in">num</span>[i] &lt; minWin[minBack])&#123;<br>        -- minBack; <span class="hljs-comment">// 将破坏单调性的元素出列</span><br>    &#125;<br>    <span class="hljs-comment">//加入队列</span><br>    minWin[++ minBack] = <span class="hljs-built_in">num</span>[i];<br>    <span class="hljs-keyword">if</span>(i &gt;= k)&#123;<br>        cout &lt;&lt; minWin[minFront];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列例子">单调队列例子</h2><p>小Z的家门口种了N棵树，第i棵树在目标点xi，高度hi。如果一棵树左边D距离内和右边D距离内有高度至少是它的两倍的树，那么小Z认为这棵树不够茁壮。春天到了，他想给不够茁壮的树多施点肥，请你帮忙数数有几棵不够茁壮的树。</p><p>思路：长度为D（若不足D 也可）的数组（窗口），移动即可。两个方向都扫一遍</p><h2 id="栈模拟递归">栈模拟递归</h2><p>递归过程：</p><ol><li class="lvl-3"><p>执行代码块0</p></li><li class="lvl-3"><p><strong>保存现场准备进入下一层</strong></p></li><li class="lvl-3"><p>接受下层返回的数据</p></li><li class="lvl-3"><p><strong>恢复现场</strong></p></li><li class="lvl-3"><p>继续执行代码块1</p></li></ol><p>直接用递归程序实现递归时，第二步和第四步都是编译器在帮助你完成而非递归实现，我们期望：自己用实现保存现场和恢复现场</p><p>用栈模拟递归的优势在于：</p><ol><li class="lvl-3"><p>避免递归深度限制</p></li><li class="lvl-3"><p>更直观的控制流程</p></li><li class="lvl-3"><p>避免递归调用的开销</p></li></ol><h2 id="END">END</h2><p>你可以当我哑巴一样你不会看见我的抵抗请别怕我受伤 我自己会圆场</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Monotonic Stack</tag>
      
      <tag>Monotonic Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构4</title>
    <link href="/2025/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/"/>
    <url>/2025/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/</url>
    
    <content type="html"><![CDATA[<h1>数据结构 4 字符串 树状结构</h1><h2 id="字符串实现方式">字符串实现方式</h2><p>当然也有<strong>顺序实现和链接实现</strong>。顺序存储使用字符数组存储字符串。C语言中使用<strong>普通数组</strong>进行处理，将每个操作由一个函数实现，这些函数实现在<strong>ctring</strong>库中，但无法用运算符操纵字符串，还存在内存溢出的问题。而C++采用<strong>动态数组</strong>进行存储，实现了一个<strong>string类</strong>，根据字符串长度重新分配空间，解决了C语言存在的缺陷，但在时间性能上有所下降。</p><p>链接存储我们自然而然想到使用单链表，虽然在时间上有了很大优化，但空间利用率较低，于是我们可以考虑<strong>块状链表</strong>。我们允许一个结点存在空余空间。进行分裂结点和合并结点的操作。</p><h2 id="树状结构——处理层次关系的数据结构">树状结构——处理层次关系的数据结构</h2><p>树是由n个结点组成的有限集合T，并且满足：<br>1.有一个根结点<br>2.其余结点分为m个集合，这些集合本身也是一棵树有些问题可以看成是树的结构，如八皇后问题（本质是DFS）</p><p>树有一些特殊的术语：</p><ul class="lvl-0"><li class="lvl-2"><p>根结点、叶结点、内部结点</p></li><li class="lvl-2"><p>结点的度（一个结点的直接后继数）和树的度（结点的最大度）</p></li><li class="lvl-2"><p>儿子结点</p></li><li class="lvl-2"><p>父亲结点</p></li><li class="lvl-2"><p>兄弟结点</p></li><li class="lvl-2"><p>祖先结点</p></li><li class="lvl-2"><p>子孙结点</p></li><li class="lvl-2"><p>结点所处层次</p></li><li class="lvl-2"><p>树的高度（一棵树上最大的层次号）</p></li><li class="lvl-2"><p>有序树</p></li><li class="lvl-2"><p>无序树</p></li><li class="lvl-2"><p>森林</p></li></ul><h2 id="二叉树">二叉树</h2><p>满二叉树：任意一层的结点个数都达到了最大值完全二叉树：在满二叉树的最底层自右向左依次去掉若干结点</p><p>二叉树的性质：</p><ul class="lvl-0"><li class="lvl-2"><p>第 i 层最多 2^(i - 1)个结点</p></li><li class="lvl-2"><p>高度为k，最多有2^k - 1个结点</p></li><li class="lvl-2"><p>n0 = n2 + 1</p></li><li class="lvl-2"><p>具有n个结点的完全二叉树高度是[log_2 n] + 1</p></li><li class="lvl-2"><p>对于完全二叉树，左儿子为2i，右儿子为2i + 1</p></li></ul><h2 id="二叉树的运算">二叉树的运算</h2><p>一个重要的操作：遍历前序遍历、中序遍历、后序遍历</p><p>如斐波那契数列的求解过程，我们采用<strong>后序遍历</strong><br>再如快速排序过程，我们采用<strong>前序遍历</strong>（先进行划分）</p><p>前序+中序可以确定一棵二叉树后序+中序也可确定一棵二叉树但前序+后序不可确定一棵二叉树</p><h2 id="二叉树的存储">二叉树的存储</h2><p>把树的层次关系映射成线性关系，对于完全二叉树来说这是容易做到的，但对于非完全二叉树来说，就需要添加一些哑结点，把一棵普通的树修补成一棵完全二叉树（空间浪费）。更多情况下我们选择<strong>链接存储</strong>二叉树。标准形式：二叉链表（只存储儿子结点）广义的存储方式：三叉链表（2个儿子结点+父结点）</p><p>二叉树是递归定义的，所以操作可用递归实现，我们一般把这些递归函数设为二叉树类的私有成员函数。</p><p>二叉树的遍历操作可以采用递归实现前序：实现find(x) 查找操作中序  后序<br>层次（可用队列实现，回顾广搜BFS）递归实现：形式优美，易懂</p><h2 id="成员函数实现">成员函数实现</h2><p>获得子结点</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq">T lchild(T x,T flag)&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == nullptr |<span class="hljs-type">| tmp</span> -&gt; <span class="hljs-built_in">left</span> == nullptr)&#123; //短路判别<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp -&gt; <span class="hljs-built_in">left</span> -&gt; data;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一棵树可通过非递归实现（队列），也可通过递归实现</p><h2 id="前序、中序、后序遍历的非递归实现——栈的模拟递归">前序、中序、后序遍历的非递归实现——栈的模拟递归</h2><p>（联系2025.03.16晚上机课）栈的模拟递归中元素为Data</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span>&#123;<br>    Node *p;<span class="hljs-comment">//参数</span><br>    <span class="hljs-type">int</span> pc;<span class="hljs-comment">//程序计数器（核心数据）</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>为任务设定状态（也就是通过pc这一变量确认进行到哪一步了）</p><h2 id="表达式树">表达式树</h2><p><strong>中缀表达式</strong><br>构建过程总结：顺序扫描中缀表达式直至结束</p><ol><li class="lvl-3"><p>运算数先检查当前的表达式树是否存在。如果不存在，则表示扫描到的是第一个运算数，将它作为树根。如果树存在，则将此运算数作为<strong>前一运算符的右孩子</strong>。</p></li><li class="lvl-3"><ul class="lvl-2"><li class="lvl-5">&amp; -<br>运算优先级低，将它作为根结点，原来的树作为它的左子树</li></ul></li><li class="lvl-3"><ul class="lvl-2"><li class="lvl-5">&amp; /<br>与根结点比较：（1）如果根结点也是 * 或 /，则根结点先执行，故将当前运算符作为根结点，原来的树作为左子树；（2）如果根结点是 + 或 - ，则根结点应该后执行，所以将当前运算符作为右子树的根结点，原来的右子树作为新根结点的左子树。</li></ul></li></ol><p><strong>括号的处理</strong><br>用递归的观点看这个问题：将括号内的子表达式构建一棵子树作为整个表达式的一个运算数</p><h2 id="表达式树类的设计——二叉链表">表达式树类的设计——二叉链表</h2><p>数据成员：指向根结点的指针结点类型：值的类型、值及左右指针公有成员函数：构造函数、result函数（后序遍历整棵树）私有成员函数：递归的create、带有递归参数的result函数、getToken（create函数的子函数，获取语法单位）</p><h2 id="哈夫曼树">哈夫曼树</h2><p>在计算机中，每个字符用一个编码来表示大多数编码系统都采用等长编码，如ASCII编码<br><strong>前缀编码</strong><br>字符只放在叶结点中，由于字符只放在叶结点中，所以每个字符的编码都不可能是其他字符编码的前缀。故前缀编码可被<strong>唯一解码</strong>！让出现频率高的字符拥有较短的编码可以节省空间，于是我们有了：<br><strong>哈夫曼树</strong>！哈夫曼树是一棵最小代价的二叉树，在这棵树上，所有的字符都包含在叶结点上。要使得整棵树的代价最小，显然权值大的叶子应当尽量靠近树根，权值小的叶子可以适当离树根远一些。哈夫曼算法很巧妙：给定一个具有n个权值{ w1,w2,………wn }的结点的集合</p><ol><li class="lvl-3"><p>F = { T1,T2,………Tn }</p></li><li class="lvl-3"><p>初始时，设集合 A = F。</p></li><li class="lvl-3"><p>执行 i = 1 至 n -1 的循环，在每次循环时执行以下操作:</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>从当前集合中选取权值最小、次最小的两个结点，以这两个结点作为内部结点 bi 的左右儿子，bi 的权值为其左右儿子权值之和。</p></li><li class="lvl-2"><p>在集合中去除这两个权值最小、次最小的结点，并将内部结点bi 加入其中。这样，在集合A中，结点个数便减少了一个。</p></li></ul><p>这样，在经过了n-1 次循环之后，集合A中只剩下了一个结点，这个结点就是根结点。</p><p>哈夫曼树只有度数为0和2的结点，所以一棵哈夫曼树有2n-1个结点。由于编码的获得需要父结点信息，所以我们采用用数组表示的三叉链表。被编码元素存储在数组的后一半。哈夫曼树的生成是从右向左填写数组的前一半。特别注意的是：哈夫曼树的实现仍然是链接存储，不是顺序存储！（又不是完全二叉树，只是事先开好空间）</p><p>存储设计：</p><ul class="lvl-0"><li class="lvl-2"><p>结点表示：结点的数据、权值和父结点和左右孩子的位置</p></li><li class="lvl-2"><p>哈夫曼树的存储：一个动态结点数组</p></li></ul><p>操作：</p><ul class="lvl-0"><li class="lvl-2"><p>构造函数：构建一棵哈夫曼树，给出节点数据数组，权值数组和数据个数</p></li><li class="lvl-2"><p>获取树上结点的哈夫曼编码，返回一个数组，数组的元素由数据和编码两部分组成的</p></li></ul><h2 id="树和森林（一般的树而非二叉树）">树和森林（一般的树而非二叉树）</h2><p>树的标准存储：除有数据字段外，还有K个指针字段（K为树的度数）广义标准存储：在标准形式的基础上，增加指向父亲结点的字段。</p><p>为了节省空间，我们可以采用<strong>孩子兄弟链表示法</strong>（用的最多的表示方法）左链：第一个儿子；右链：下一个兄弟</p><p>还有一种表示方法：<strong>双亲表示法</strong><br>只记录每个结点的父结点位置</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>String</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic3</title>
    <link href="/2025/03/08/Mathematical-Logic3/"/>
    <url>/2025/03/08/Mathematical-Logic3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"><a href="#Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣" class="headerlink" title="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"></a>Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣</h5><p>🐖🐖🐖</p><h1 id="Mathematical-Logic-3-重合引理-同构引理"><a href="#Mathematical-Logic-3-重合引理-同构引理" class="headerlink" title="Mathematical Logic 3 重合引理 同构引理"></a>Mathematical Logic 3 重合引理 同构引理</h1><h2 id="概念回顾"><a href="#概念回顾" class="headerlink" title="概念回顾"></a>概念回顾</h2><p><strong>项</strong>是由<strong>变量、常量符号和函数符号</strong>通过递归方式构造的表达式。<br><strong>公式</strong>（formula）是由<strong>项</strong>通过<strong>谓词符号、逻辑连接词和量词构造</strong>的表达式。<br><strong>结构</strong>由<strong>域</strong>和<strong>解释函数</strong>组成。<br><strong>解释</strong>由<strong>结构</strong>和<strong>赋值函数</strong>（将自由变量映射到域中的元素）组成。</p><ul><li>原子公式：包括等式公式、谓词公式R</li><li>逻辑连接词：¬、∧、∨、→、↔</li><li>量词：∀xφ (x是变量，φ 是公式)、∃xφ (x是变量，φ 是公式)</li></ul><p>我们可以解释term、解释formula、解释sentence</p><h2 id="结构归纳法（对公式进行归纳）"><a href="#结构归纳法（对公式进行归纳）" class="headerlink" title="结构归纳法（对公式进行归纳）"></a>结构归纳法（对公式进行归纳）</h2><p>公式的归纳基于公式的结构，即公式的构造方式。由于公式是通过递归方式定义的（<strong>从原子公式逐步构造出复杂公式</strong>），因此我们可以使用结构归纳法来证明公式的性质。<br>公式的归纳证明通常分为以下几个步骤：</p><ul><li>证明性质𝑃对所有原子公式成立</li><li>归纳步骤：假设性质𝑃对某些公式𝜑和𝜓成立（归纳假设），然后证明𝑃对通过这些公式构造的复杂公式也成立。</li></ul><h2 id="重合引理（The-Coincidence-Lemma）"><a href="#重合引理（The-Coincidence-Lemma）" class="headerlink" title="重合引理（The Coincidence Lemma）"></a>重合引理（The Coincidence Lemma）</h2><p>设I1(A1,β1),I2(A2,β2)是2个S-解释，且满足以下条件：</p><ul><li>A1 &#x3D; A2（解释的域相同）</li><li>对于S：&#x3D; S1 ∩ S2中的每个符号，它们在A1、A2中的解释相同</li></ul><p>那么：</p><ul><li>对于任何S项t，如果β1(x) &#x3D; β2(x)对于t中的所有变量x成立，则I1(x) &#x3D; I2(x)<br>即需要满足<strong>结构的解释相同</strong>和<strong>变量的赋值相同</strong></li><li>对于任何S公式𝜑，如果β1(x) &#x3D; β2(x)对于𝜑中的所有自由变量x成立，则I1 |&#x3D; 𝜑 当且仅当 I2 |&#x3D; 𝜑<br>即需要满足<strong>结构的解释相同</strong>和<strong>自由变量的赋值相同</strong></li></ul><p>证明依赖于<strong>结构归纳法</strong></p><h2 id="同构引理（The-Isomorphism-Lemma）"><a href="#同构引理（The-Isomorphism-Lemma）" class="headerlink" title="同构引理（The Isomorphism Lemma）"></a>同构引理（The Isomorphism Lemma）</h2><p>首先给出<strong>同构</strong>的定义：<br>在模型论中，同构是指两个结构之间存在一个<strong>双射</strong>（bijection），这个双射<strong>保持了结构中的所有关系、函数和常量</strong>。<br>具体来说：<br>设A(A,I)和B(B,J)是2个S—结构，其中A和B是它们的域，I和J是解释函数。<br>一个同构𝜋：A → B是一个双射，满足以下条件：</p><ul><li>保持关系<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%85%B3%E7%B3%BB.png" alt="保持关系"></li><li>保持运算<br><img src="/img/%E4%BF%9D%E6%8C%81%E8%BF%90%E7%AE%97.png" alt="保持运算"></li><li>保持常量<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%B8%B8%E9%87%8F.png" alt="保持常量"></li></ul><p>如果存在这样的双射𝜋，则称结构A和B是同构的，记作A≅B<br>例子：群论 &amp; 图论中的同构</p><p>同构的性质：</p><ul><li>自反性（Reflexivity）：A ≅ A</li><li>对称性（Symmetry）：若A ≅ B，则B ≅ A</li><li>传递性（Transitivity）：若A ≅ B 且 B ≅ C ，则A ≅ C</li></ul><p>因此，同构是一个<strong>等价关系</strong></p><p>那么同构引理可以表示为：<br>如果A、B是两个同构的S-结构，则对于任何<strong>S-句子</strong>𝜑，有<br>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑<br>这意味着，同构的结构在一阶逻辑中无法被区分，它们满足相同的句子。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure15</title>
    <link href="/2025/03/07/Data-Structure15/"/>
    <url>/2025/03/07/Data-Structure15/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-Am-I-noisy-I-really-regret-Why-am-I-being-so-annoying-Why-am-I-becoming-jealous-of-something-unnecessary-Maybe-it’s-because-of-something-romantic-something-secret-something-I-keep-chasing-and-that-is-you-Sometimes-I-find-out-that-she-is-not-that-perfect-but-I-still-ignore-all-those-stuffs-😢😢😢"><a href="#Before-Am-I-noisy-I-really-regret-Why-am-I-being-so-annoying-Why-am-I-becoming-jealous-of-something-unnecessary-Maybe-it’s-because-of-something-romantic-something-secret-something-I-keep-chasing-and-that-is-you-Sometimes-I-find-out-that-she-is-not-that-perfect-but-I-still-ignore-all-those-stuffs-😢😢😢" class="headerlink" title="Before: Am I noisy?I really regret.Why am I being so annoying?Why am I becoming jealous of something unnecessary?Maybe it’s because of something romantic,something secret,something I keep chasing,and that is you.Sometimes I find out that she is not that perfect,but I still ignore all those stuffs.😢😢😢"></a>Before: Am I noisy?I really regret.Why am I being so annoying?Why am I becoming jealous of something unnecessary?Maybe it’s because of something romantic,something secret,something I keep chasing,and that is you.Sometimes I find out that she is not that perfect,but I still ignore all those stuffs.😢😢😢</h5><p>有人又emo了，为什么呢？因为最近发生的那些吗…就忘了吧<br>是过去，是现在，是未来</p><h1 id="Data-Structure-15-动态查找表-BST-AVL"><a href="#Data-Structure-15-动态查找表-BST-AVL" class="headerlink" title="Data Structure 15 动态查找表 BST &amp; AVL"></a>Data Structure 15 动态查找表 BST &amp; AVL</h1><p>既支持查找操作，又支持增、删操作的集合称为<strong>动态查找表</strong>。<br>动态查找表抽象类可以这样定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dynamicSearchTable</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> SET&lt;KEY,OTHER&gt;* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY&amp; x)</span> </span>== <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(CONST SET&lt;KEY,OTHER&gt;&amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY&amp; x)</span> </span>== <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">dynamicSearchTable</span>()&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用于处理动态查找表的树称为<strong>查找树</strong>(Search Tree)。另一种动态查找表的实现是<strong>散列表</strong>，它是专用于集合查找的数据结构。</p><h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 Binary Search Tree"></a>二叉查找树 Binary Search Tree</h2><p>注：鉴于关于BST的实现已经在<a href="https://janez-uint.github.io/2025/03/01/Introduction-to-Algorithms2/">Introduction to Algorithm 2</a>中实现了，这里只会简单说明一下一些要点</p><p>首先是存储：与普通二叉树的存储一样，只需存储二叉查找树的根结点<br>下面是一些运算实现：</p><ul><li>查找：从根结点开始，决定是向左子树找还是向右子树找</li><li>插入：原则上必须保证插入一个结点后，这棵树仍是一棵二叉查找树；且在插入前需要进行查找操作以确保插入的元素不会重复</li><li>（最复杂的操作）删除：如果删除的是叶结点，那么直接删除；如果删除的结点只有一侧存在结点，则那一侧的结点作为新的根结点；最复杂的是删除结点仍有2个子结点的情况，我们在右子树中找到最小的元素，为了避免大量数据元素的移动，我们选择将r的信息与这个最小的结点进行值交换，最小的那个结点成为了新的根结点，我们只需要在右子树中删除原有结点即可（划归到了1.2两种情况）</li></ul><p>（老生常谈了）BST并不保证平衡，可能退化成链表，复杂度炸了</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>注：鉴于关于AVL的思想已经在<a href="https://janez-uint.github.io/2025/03/06/Introduction-to-Algorithms3/">Introduction to Algorithm 3</a>中介绍了(<strong>特别是证明树有对数级高度</strong>)</p><p><strong>AVL树中每个结点的左右子树的高度最多差 1</strong></p><p>首先还是存储上，AVL结点多了一个量用于记录结点高度<br>具体成员函数上，有抽象类规定的插入、删除和查找函数，除此之外，在私有成员函数中还包括了一组工具函数。包括调整树的平衡的adjust函数，四种旋转函数LL、RR、LR、RL，一个求树高度的height函数，清空AVL树的clear函数。</p><h3 id="旋转rotate操作"><a href="#旋转rotate操作" class="headerlink" title="旋转rotate操作"></a>旋转rotate操作</h3><p>具体来讲一讲AVL中一个特殊的操作：<strong>维护AVL的平衡</strong>。造成AVL失衡主要有四种情况：<br><img src="/img/AVL%E6%97%8B%E8%BD%AC.png" alt="AVL四种失衡情况"></p><p>首先，我们给出四种情形的示例图：<br><img src="/img/LL%E6%83%85%E5%86%B5.png" alt="LL型情况"><br><img src="/img/LR%E6%83%85%E5%86%B5.png" alt="LR型情况"><br><img src="/img/RR%E6%83%85%E5%86%B5.png" alt="RR型情况"><br><img src="/img/RL%E6%83%85%E5%86%B5.png" alt="RL型情况"></p><p>观察树可以发现，导致出现LL、RR型进行的插入操作发生在<strong>树的外部</strong>，可以通过<strong>单旋转</strong>调整好，而LR、RL型就复杂一些，插入操作发生在<strong>树的内部</strong>，需更复杂的<strong>双旋转</strong>操作。</p><p>不妨先看LL型：<br>插入前，结点A是平衡的，结点B原来的平衡度应该为0，否则A不会失去平衡或成为第一个失去平衡的结点。经过一次右旋的操作，树依然是有序的。如选图所示：<br><img src="/img/%E5%8F%B3%E6%97%8B%E6%93%8D%E4%BD%9C.png" alt="右旋操作"></p><p>下面是代码实现（应该或许大概还是挺易懂的😢，虽然笨人已经被搞红温了）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">LL</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    AVLnode *newRoot = t.left;<br>    t.left = newRoot.right;<br>    newRoot.right = t;<br>    t -&gt; height = max(t -&gt; left,t -&gt; right) + <span class="hljs-number">1</span>;<br>    newRoot -&gt; height = max(height(t),height(newRoot -&gt; left)) + <span class="hljs-number">1</span>;<br>    t = newRoot;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理可以得到RR型，需要进行左旋操作，如下图所示：<br><img src="/img/%E5%B7%A6%E6%97%8B%E6%83%85%E5%86%B5.png" alt="左旋操作"></p><p>下面是代码实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">RR</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    AVLnode *newRoot = t.right;<br>    t.right = newRoot.left;<br>    newRoot.left = t;<br>    t -&gt; height = max(t -&gt; left,t -&gt; right) + <span class="hljs-number">1</span>;<br>    newRoot -&gt; height = max(height(t),height(newRoot -&gt; right)) + <span class="hljs-number">1</span>;<br>    t = newRoot;<br>&#125;<br></code></pre></td></tr></table></figure><p>LR、RL实际上是把LL、RR的操作进行复合<br>还是先来看一下过程吧，如图所示：<br><img src="/img/LR%E6%93%8D%E4%BD%9C.png" alt="LR操作"><br><img src="/img/RL%E6%93%8D%E4%BD%9C.png" alt="RL操作"></p><p>代码基于了LL、RR操作</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">LR</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    RR(t -&gt; left);<br>    LL(t);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">RL</span>(<span class="hljs-symbol">Avlnode</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    LL(t -&gt; right);<br>    RR(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>To be honest：我觉得写成LL、RR、LR、RL的样子不是很直观，不如写成leftRotate、rightRotate、leftAndrightRotate、rightAndleftRotate，这样写至少能告诉我下面要进行怎样的操作。但单看怎么Rotate又不知道对应的哪种情况😇😇😇区别在于实现函数和调用函数的方便程度吧</p><h3 id="插入insert操作（kind-of-a-conclusion）"><a href="#插入insert操作（kind-of-a-conclusion）" class="headerlink" title="插入insert操作（kind of a conclusion）"></a>插入insert操作（kind of a conclusion）</h3><p><strong>递归算法</strong>可能是实现AVL树插入的最简单的方法，要在AVL树T中插入一个键值为x的结点，可以递归地将它插入T的某棵合适的子树（记作T’），如果插入后T’的高度没有改变，就完成了操作。否则，根据x和T及T’中的键值选择单旋转或双旋转（以T为根），操作也结束了。</p><p>与二叉查找树一样，插入操作也是通过递归实现的。如果树是空树，将结点插入为根结点，递归结束。如果插入结点比根结点小，则在左子树上插入。如果插入结点比根结点大，则在右子树上插入。只是AVL树还要多做一件事，<strong>就是在插入后要检查从插入结点到根结点的路径上有没有结点失衡</strong>。如果有，则作相应的调整。从插入结点到根结点的回溯过程由递归函数自动完成，在递归调用返回后检查根结点的平衡度。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;&amp;<span class="hljs-symbol">x</span>)&#123;<br>    insert(x,root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;&amp;<span class="hljs-symbol">x,<span class="hljs-symbol">AvlNode</span></span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        t = new AVLNode(x,<span class="hljs-literal">null</span>ptr,<span class="hljs-literal">null</span>ptr);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &lt; t -&gt; data.key)&#123;<br>        insert(x,t -&gt; left);<br>        <span class="hljs-keyword">if</span>(height(t -&gt; left) - height(t -&gt; right) == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(x.key &lt; t -&gt; left -&gt; data.key)&#123;<br>                LL(t);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                LR(t);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t -&gt; data.key)&#123;<br>        insert(x,t -&gt; right);<br>        <span class="hljs-keyword">if</span>(height(t -&gt; right) - height(t -&gt; left) == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(x.key &gt; t -&gt; right -&gt; data.key)&#123;<br>                RR(t);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                LR(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>    t -&gt; height = max(height(t -&gt; left),height(t -&gt; right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这还是比较容易的😋😋😋至多只需要调整一个结点</p><h3 id="删除remove操作"><a href="#删除remove操作" class="headerlink" title="删除remove操作"></a>删除remove操作</h3><p>两步操作：</p><ul><li>删除结点 x（与BST一样）</li><li>调整平衡</li></ul><p>删除操作没有插入操作那么幸运，调整可能导致整棵子树高度下降，从而影响该子树的父结点的平衡度。只有当某个结点的高度在删除前后保持不变，才无须继续调整。<br>下面是代码实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    remove(x,root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">AVLTree</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x,<span class="hljs-symbol">Avlnode</span></span>* &amp;<span class="hljs-symbol">t</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x == t -&gt; data.key)&#123;<br>        <span class="hljs-keyword">if</span>(t -&gt; left == <span class="hljs-literal">null</span>ptr || t -&gt; right == <span class="hljs-literal">null</span>ptr)&#123;<br>            AVLnode *oldNode = t;<br>            <span class="hljs-keyword">if</span>(t -&gt; left == <span class="hljs-literal">null</span>ptr)&#123;<br>                t = t -&gt; right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                t = t -&gt; left;<br>            &#125;<br>            delete oldNode;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        AVLNode *tmp = t -&gt; right;<br>        <span class="hljs-keyword">while</span>(tmp -&gt; left != <span class="hljs-literal">null</span>ptr)&#123;<br>            tmp = tmp -&gt; left;<br>        &#125;<br>        t -&gt; data = tmp -&gt; data;<br>        <span class="hljs-keyword">if</span>(remove(tmp -&gt; data,t -&gt; right))&#123;  <span class="hljs-comment">//若树不会变矮</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> adjust(t,<span class="hljs-number">1</span>); <span class="hljs-comment">//1表示调整右子树</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; t -&gt; data.key)&#123;<br>        <span class="hljs-keyword">if</span>(remove(x,t -&gt; left))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> adjust(t,<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; t -&gt; data.key)&#123;<br>        <span class="hljs-keyword">if</span>(remove(x,t -&gt; right))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> adjust(t,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/5%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="左子树删除一个结点后的5种情况"></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//返回值为true即说明高度没变，无需进一步检查平衡，反之，则需要进一步检查</span><br>template&lt;class KEY,class OTHER&gt;<br>bool AVLTree&lt;KEY,OTHER&gt;::adjust(AVLnode *&amp; t,int subtree)&#123;<br>    <span class="hljs-keyword">if</span>(subtree)&#123;  <span class="hljs-comment">//在右子树上删除，使右子树变矮</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) - height(t -&gt;</span> right) == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            -- <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> height;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) &lt; height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> right))&#123;<br>            LR(t);<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        LL(t);<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//在左子树上删除，使左子树变矮</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>) - height(t -&gt;</span> left) == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            -- <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> height;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) &gt; height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> right))&#123;<br>            RL(t);<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        RR(t);<br>        <span class="hljs-function"><span class="hljs-title">if</span>(height(t -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>) == height(t -&gt;</span> right))&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.csdn.net/qq_25806863/article/details/74755131">AVL树的旋转图解和简单实现</a></li><li><a href="https://blog.csdn.net/m0_45067620/article/details/117913500">二叉平衡(AVL)树中的 LL旋转、RR旋转、LR旋转、RL旋转 的详细解释</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>BST</tag>
      
      <tag>AVL</tag>
      
      <tag>Balanced Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms3</title>
    <link href="/2025/03/06/Introduction-to-Algorithms3/"/>
    <url>/2025/03/06/Introduction-to-Algorithms3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"><a href="#Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢" class="headerlink" title="Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"></a>Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢</h5><h1 id="Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL"><a href="#Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL" class="headerlink" title="Introduction to Algorithms 3 Balanced Binary Search Tree——AVL"></a>Introduction to Algorithms 3 Balanced Binary Search Tree——AVL</h1><p>First, recall an important definition of <strong>Height of a Node</strong>: <strong>length of the longest downward path to a leaf</strong></p><h2 id="The-Importance-of-Being-Balanced"><a href="#The-Importance-of-Being-Balanced" class="headerlink" title="The Importance of Being Balanced"></a>The Importance of Being Balanced</h2><p>As we talk about last time,BST suppports insert&#x2F;delete&#x2F;min&#x2F;max&#x2F;next_larger&#x2F;next_smaller or in a time complexity of <strong>O(h)</strong>.But that’s not what we want.Somehow if h equals to n,it’s gonna be really bad.</p><p>We love this tree😋😋😋：<br><img src="/img/PerfectTree.png" alt="Perfectly Balanced Binary Tree"></p><p>We hope to do some adjustments to the tree so that h can equal to <strong>logN</strong>.</p><h2 id="AVL-Trees——Adel’son-Vel’skii-Landis-1962"><a href="#AVL-Trees——Adel’son-Vel’skii-Landis-1962" class="headerlink" title="AVL Trees——Adel’son-Vel’skii &amp; Landis 1962"></a>AVL Trees——Adel’son-Vel’skii &amp; Landis 1962</h2><h3 id="Main-Defintion"><a href="#Main-Defintion" class="headerlink" title="Main Defintion:"></a>Main Defintion:</h3><p>For every node,require <strong>heights</strong> of left &amp; right children to differ by at most <strong>± 1</strong>.</p><ul><li>We mark nil trees as height <strong>-1</strong>（quite smart cuz -1 + 1 &#x3D; 0）</li><li>Each nodes stores its height</li></ul><p><img src="/img/AVL%E4%BE%8B%E5%AD%90.png" alt="An example of an AVL tree"></p><h3 id="Balance"><a href="#Balance" class="headerlink" title="Balance"></a>Balance</h3><p>Consider the largest height of an AVL tree with N nodes.(worst time complexity)<br>Equalently,we can consider <strong>the minimun node numbers of an AVL tree with height h</strong>!<br>Great thoughts!</p><p>We can do a rough Maths proof:<br>N_h &#x3D; N_(h - 1) + N_(h - 2) &gt; 2N_(h - 2)<br>&#x3D;&gt; N_h &gt; 2^(h&#x2F;2)<br>&#x3D;&gt; h &lt; 2 log(N_h)<br>So proved that h is alogN(a is a parameter)</p><p>Theoretical computer scientists can do this more accurately,like what the picture below shows using Fibonacci:<br><img src="/img/AVLproof.png" alt="The secret behind the logN height of the AVL tree"></p><h3 id="AVL-insert"><a href="#AVL-insert" class="headerlink" title="AVL insert"></a>AVL insert</h3><p>1.insert as in simple BST(just the normal one)<br>2.<strong>work your way up tree, restoring AVL property</strong>(the most important step of building the AVL tree)</p><p>Each Step of the famous <strong>AVL Rotation</strong>:</p><ul><li><p>suppose x is lowest node violating(违背) AVL</p></li><li><p>assume x is right-heavy (left case symmetric)</p></li><li><p>if x’s right child is right-heavy or balanced:<br><img src="/img/AVL%E6%97%8B%E8%BD%AC1.png" alt="AVL Inserting Balance"></p></li><li><p>else: follow steps<br><img src="/img/AVL%E6%97%8B%E8%BD%AC2.png" alt="AVL Inserting Balance"></p></li><li><p>then continue up to x’s grandparent, greatgrandparent</p></li></ul><h2 id="Other-Balanced-Trees"><a href="#Other-Balanced-Trees" class="headerlink" title="Other Balanced Trees"></a>Other Balanced Trees</h2><ul><li>B-Trees&#x2F;2-3-4 Trees Bayer and McCreight 1972 (see CLRS 18)</li><li>BB[α] Trees Nievergelt and Reingold 1973</li><li>Red-black Trees CLRS Chapter 13</li><li>Splay-Trees Sleator and Tarjan 1985</li><li>Skip Lists Pugh 1989</li><li>Scapegoat Trees Galperin and Rivest 1993</li><li>Treaps Seidel and Aragon 1996</li></ul><h2 id="Comparison-with-Heap"><a href="#Comparison-with-Heap" class="headerlink" title="Comparison with Heap"></a>Comparison with Heap</h2><p><img src="/img/HeapAVL1.png"><br><img src="/img/HeapAVL2.png"></p><h2 id="End-Start-BHW-3-Map"><a href="#End-Start-BHW-3-Map" class="headerlink" title="End(Start BHW 3 Map~~~)"></a>End(Start BHW 3 Map~~~)</h2>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>AVL</tag>
      
      <tag>Balanced Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure14</title>
    <link href="/2025/03/06/Data-Structure14/"/>
    <url>/2025/03/06/Data-Structure14/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Long-Time-No-See-这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting-always-comes-to-an-end-你是我声色张扬下欲盖弥彰的温柔理想。"><a href="#Before：Long-Time-No-See-这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting-always-comes-to-an-end-你是我声色张扬下欲盖弥彰的温柔理想。" class="headerlink" title="Before：Long Time No See!这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting always comes to an end.你是我声色张扬下欲盖弥彰的温柔理想。"></a>Before：Long Time No See!这周前几天一直在小作业、数分作业、物理作业、物理实验（依托），到了周四也算是闲下来了，有了一大把自学的时间😋😋😋这周还是挺不错的？珍惜能天天见面的日子吧🥰Waiting always comes to an end.你是我声色张扬下欲盖弥彰的温柔理想。</h5><h1 id="Data-Structure-14-集合与静态查找表"><a href="#Data-Structure-14-集合与静态查找表" class="headerlink" title="Data Structure 14 集合与静态查找表"></a>Data Structure 14 集合与静态查找表</h1><h2 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h2><p>首先，集合中数据元素的关系十分松散，除了属于同一集合外，没有任何逻辑关系。但集合中的元素有一个区别其他元素的唯一标识，通常称为<strong>键值</strong>或<strong>关键字值</strong>。故每个集合中的元素可以看成由两部分组成：<strong>关键字值</strong>和<strong>其他信息</strong>。<br>故我们可以这样定义集合中元素的类型：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">struct</span> <span class="hljs-symbol">SET</span>&#123;<br>    KEY key;<br>    OTHER other;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于集合中元素不存在直接前驱、直接后继等，故集合中的主要操作只有<strong>添加元素、删除元素以及查找某个元素是否出现在集合中</strong>。但当集合元素非常多时，查找某个元素将花费很长时间，我们需要一种手段来<strong>加速查找过程</strong>。因此将集合中的元素按它的唯一标识排序也是集合的基本运算。</p><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><p>通常将用于查找的数据结构称为<strong>查找表</strong>。查找就是要<strong>确定指定关键字值的数据元素在查找表中是否存在</strong>。（注意，有一些特殊的情况可能会出现一些数据结构含有相同关键字值，这样的集合称为<strong>多重集</strong>，我们暂不讨论这种情况）。<br>如果查找表中的数据元素个数和每个数据元素的值是不变的，这样的查找表我们通常称为<strong>静态查找表</strong>。如果对查找表不但要进行查找操作，还要进行插入、删除操作，那么查找表将是动态变化的，其数据元素的个数并不是一个稳定的常数，这样的查找表通常称为<strong>动态查找表</strong>。<br>显而易见，动态查找表的要求更高呢😢不仅要查找迅速，插入删除也要迅速（已经开始😇）</p><p>被查找的所有数据元素全部存放在<strong>内存储器</strong>中时的查找操作称为<strong>内部查找</strong>，如果数据元素太多，不能全部放在内存之中，只能将它们存放到<strong>外存储器</strong>中去，这时的查找操作便称之为<strong>外部查找</strong>。在外存储器中，每个数据元素通常称为<strong>记录</strong>。<br>在内部查找中，一般以比较次数作为衡量时间性能的一个标准。在外部查找中，被查找的数据是存储在外存储器上，查找时必须把<strong>外存储器</strong>上的数据<strong>读入内存</strong>。与外存访间相比，比较时间是微不足道的，所以在外部查找中一般以<strong>外存储器的访问次数</strong>作为衡量标准。<strong>减少访问外存的次数</strong>，将会大大减少查找的时间代价。</p><p>如果没记错（就是没记错），BPT也是要在外存上实现的吧。。。😇😇😇😇😇</p><h2 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h2><p>数据元素个数及数据元素的值不允许变化的查找表称为<strong>静态查找表</strong>。（嗯几秒前刚讲过🤣）通常将被查找的数据存放在一个<strong>数组或顺序表</strong>中。</p><p>与其他各类数据结构一样，各个静态查找表中的数据元素类型是不一样的，因此，查找函数应该是一个函数模板。模板参数是数据元素的类型。静态查找表可以存放在一个数组中，也可以存放在 C+＋的标准模板库中的类模板vector中。</p><h2 id="无序表的查找——顺序查找"><a href="#无序表的查找——顺序查找" class="headerlink" title="无序表的查找——顺序查找"></a>无序表的查找——顺序查找</h2><p>由于无序表中元素无序，只能顺序查找按顺序检查保存在数组中的集合元素，直到找到一个匹配为止。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqSearch</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;<span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    data[<span class="hljs-number">0</span>].key = x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = size;data[i].key != x;i --);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这样写少了一次检查下标是否合法的比较，利用0处作为哨岗<br>时间复杂度为O(N)</p><h2 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h2><p>当集合中的元素是按照关键字值的次序存放在数组时，称为<strong>有序表</strong>。</p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>以按递增顺序存储为例</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqSearch</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;<span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    data[<span class="hljs-number">0</span>].key = x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = size;data[i].key &gt; x;i --);<br>    <span class="hljs-keyword">if</span>(data[i].key == x &amp;&amp; i != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">KEY,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">OTHER</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqSearch</span>(<span class="hljs-symbol">SET</span>&lt;<span class="hljs-symbol">KEY,<span class="hljs-symbol">OTHER</span></span>&gt;<span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">KEY</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-built_in">int</span> low = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> high = size;<br>    <span class="hljs-built_in">int</span> mid;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        mid = (low + high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(data[mid] == x)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[mid] &lt; x)&#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(logN)</p><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>假设分布均匀，则可利用公式判断位置：<br><code>next = low + (high - low + 1)*(x - a[low])/(a[high] - a[low])</code><br>但缺点同样很明显：计算太繁杂了（鼠鼠现在的算力手算兴许是算不出来的吧🤣🤣🤣）<br>所以使用插值查找需满足2个假设：<br>1.访问一个数据元素必须比一个典型的指令费时得多。例如，数组可能在磁盘里而不是在内存里，而且每次比较都需要<strong>访问一次磁盘</strong>。<br>2.这些数据必须不仅有序，而且分布相当均匀，这可以使每次估计都相当准确。</p><h3 id="分块查找😋😋😋"><a href="#分块查找😋😋😋" class="headerlink" title="分块查找😋😋😋"></a>分块查找😋😋😋</h3><p>这不是小作业刚做完的嘛嘻嘻，爽到了🥰🥰🥰<br>这不是Bookstore的文件存储测试，可爱的（逆天的阴间的）BlockList嘛🤣现在还挺喜欢BlockList的，笑死了，感觉还是挺好写的嘻嘻嘻<br><img src="/img/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE.png" alt="分块查找表"></p><p>这张图真是太清楚了，如果早点看到，一切就会不同吧😥<br>总结一下，分块查找分两个阶段。先查找索引表，<strong>确定数据所在的块</strong>。由千索引表是有序的，可以采取<strong>顺序查找或二分查找</strong>。第二步是<strong>块内查找</strong>。如果块内是有序的，可以采用二分查找。如果块内是无序的，则只能采用顺序查找。<br>挺简单的，这是真心话，真简单，真的太简单了。真服了🤡</p><p>时间复杂度即便都采用顺序查找，也可以达到O(sqrt(N))，还是很快的？<br>尽情期待B PLUS TREE~~~</p><h2 id="STL不给用，就不说了（也没啥值得说的bushi）"><a href="#STL不给用，就不说了（也没啥值得说的bushi）" class="headerlink" title="STL不给用，就不说了（也没啥值得说的bushi）"></a>STL不给用，就不说了（也没啥值得说的bushi）</h2>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构3</title>
    <link href="/2025/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"/>
    <url>/2025/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-3-队列"><a href="#数据结构-3-队列" class="headerlink" title="数据结构 3 队列"></a>数据结构 3 队列</h1><h2 id="Where-队列？"><a href="#Where-队列？" class="headerlink" title="Where 队列？"></a>Where 队列？</h2><p>计算机中CPU将时间切成很多个小的时间单元，实际上是轮流在为用户服务，存在一个等待运行的过程——尽情期待《操作系统》（bushi）</p><p>银行ATM 取款机 排队的过程</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>难以判断是满是空时，我们一般选择牺牲一个单元（但似乎记录一下队列的长度也可以解决问题）</p><p>循环队列类同样需要由队列的抽象类派生<br>即便是循环队列同样可能存在存储空间不够的情况，所以我们仍然需要私有成员函数doubleSpace，需要注意的是，这里的doubleSpace函数在平移数据时，<strong>需要从front开始</strong></p><h2 id="队列链接实现"><a href="#队列链接实现" class="headerlink" title="队列链接实现"></a>队列链接实现</h2><p>使用不带头结点的单链表实现，同时需要记录头尾结点的位置（空间换时间），这样就使得入队（在链表尾处实现）和出队（在链表头实现）的复杂度都是O(1)的时间复杂度。<br>注意：这里是因为在链表头插入删除都很方便，但在链表尾处插入操作是O(1)的，但删除操作需要将队尾元素前一个元素的next指针置空，复杂度达到了O(n)，故我们考虑在头处删除（对应出队操作），在尾处插入（对应入队操作）</p><p>更要注意的是，在enQueue（入队操作）时，如果尾结点是空指针，<strong>需要进行特判</strong>（RE启动！）<br>deQueue操作需要返回出队元素的值，所以还要先保存那个值，同时记得delete（leak启动！）还有一个特殊情况，就是当队中只有一个元素时，将其出队后，需要将尾结点也置空。</p><h2 id="STL中的队列"><a href="#STL中的队列" class="headerlink" title="STL中的队列"></a>STL中的队列</h2><p>和栈一样，是容器适配器，借助已有线性表。由于vector在表头操作很糟糕，所以我们一般采用list和deque。<br>包含头文件<br><code> #include&lt;queue&gt;</code></p><h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><h3 id="列车车厢重排"><a href="#列车车厢重排" class="headerlink" title="列车车厢重排"></a>列车车厢重排</h3><p>一列货运列车共有n节车厢，每节车厢将被放在不同的车站。假定n个车站的编号分别为1 – n，货运列车按照第n站到第1站的次序经过这些车站。车厢的编号与它们的目的地相同。为了便于从列车上卸掉相应的车厢，必须重新排列这些车厢，将第n节车厢放在最后，第1节车厢放在最前面。</p><p>Thought：利用k根轨道重排n节车厢，初始排列次序在数组in中</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">arrange</span><span class="hljs-params">(<span class="hljs-type">int</span> in[],<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    linkQueue&lt;<span class="hljs-type">int</span>&gt; *buffer = <span class="hljs-keyword">new</span> linkQueue&lt;<span class="hljs-type">int</span>&gt;;<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">putbuffer</span>(buffer,k,in[i])) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">checkbuffer</span>(buffer,k,last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">putbuffer</span><span class="hljs-params">(linkQueue&lt;<span class="hljs-type">int</span>&gt;*buffer,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> in)</span></span>&#123;<br>    <span class="hljs-type">int</span> avail = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; size;j ++)&#123;<br>        <span class="hljs-keyword">if</span>(buffer[j].<span class="hljs-built_in">isEmpty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(avail == <span class="hljs-number">-1</span>)&#123;<br>                avail = j;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(buffer[j].<span class="hljs-built_in">getTail</span>() &lt; in &amp;&amp; buffer[j].<span class="hljs-built_in">getTail</span>() &gt; max)&#123;<br>                avail = j;<br>                max = buffer[j].<span class="hljs-built_in">getTail</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(avail != <span class="hljs-number">-1</span>)&#123;<br>        buffer[avail].<span class="hljs-built_in">enQueue</span>(in);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkbuffer</span><span class="hljs-params">(linkQueue&lt;<span class="hljs-type">int</span>&gt;*buffer,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;last)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag)&#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; size;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(!buffer[j].<span class="hljs-built_in">isEmpty</span>()&amp;&amp; buffer[j].<span class="hljs-built_in">getHead</span>() == last + <span class="hljs-number">1</span>)&#123;<br>                last ++;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排队系统的模拟"><a href="#排队系统的模拟" class="headerlink" title="排队系统的模拟"></a>排队系统的模拟</h3><p><strong>模拟</strong>（simulation）是计算机的一个重要应用，是指用计算机来仿真现实系统的操作并收集统计数据。</p><p><strong>虚拟时间</strong><br>模拟系统是一个虚拟的系统，一般不需要使用真实的精确时间，只要用一个时间单位即可，这个时间单位叫做一个嘀嗒。一个嘀嗒可以表示1秒，也可以表示1分钟，也可以表示一小时，这根据应用来决定。</p><p><strong>时间驱动的模拟</strong><br>工作过程：沿着时间轴模拟这一时刻发生的事情，并做相应的处理<br>如龟兔赛跑</p><h3 id="事件驱动的模拟"><a href="#事件驱动的模拟" class="headerlink" title="事件驱动的模拟"></a>事件驱动的模拟</h3><p>工作过程：按事件发生的时间一件一件处理<br>如排队系统的模拟<br>特点:</p><ul><li>事件不是连续发生的</li><li>没有必要模拟没有事件发生的时间</li></ul><h3 id="如何产生顾客到达事件和服务时间"><a href="#如何产生顾客到达事件和服务时间" class="headerlink" title="如何产生顾客到达事件和服务时间"></a>如何产生顾客到达事件和服务时间</h3><p>尽管服务时间和顾客到达的间隔时间是可变的，但从统计上来看是服从一定的概率分布。<br>要生成顾客的到达时间或生成服务时间必须掌握如何按照某个概率生成事件。<br>如顾客到达的间隔时间服从[a，b]之间的均匀分布，则可以生成一个[a，b]之间的一个随机数x，表示前一个顾客到达后，经过了x的时间后又有一个顾客到达了。<br><code>rand() * (b – a + 1)/(RAND_MAX + 1) + a</code></p><h3 id="设计单服务台排队系统"><a href="#设计单服务台排队系统" class="headerlink" title="设计单服务台排队系统"></a>设计单服务台排队系统</h3><p>设计一个只有一个服务台的排队系统，希望通过这个模拟器得到顾客的平均排队时间。顾客到达的时间间隔服从[arrivaLow, arrivalHigh]的均匀分布；服务时间长度服从[serviceTimeLow, serviceTimeHigh]间的均匀分布；一共模拟customNum个顾客。要求统计顾客的平均排队时间。</p><h3 id="模拟过程"><a href="#模拟过程" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>生成所有的顾客到达事件，按到达时间排成一个队列。</p><ul><li>依次处理队列中的每个元素，直到队列为空</li><li>检查顾客的到达时间和当前时间，计算等待时间，记入累计值；</li><li>生成顾客服务时间</li><li>将当前事件拨到该顾客的离开时间</li><li>返回累计值除以顾客数的结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms2</title>
    <link href="/2025/03/01/Introduction-to-Algorithms2/"/>
    <url>/2025/03/01/Introduction-to-Algorithms2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：风止于秋水，我止于你"><a href="#Before：风止于秋水，我止于你" class="headerlink" title="Before：风止于秋水，我止于你"></a>Before：风止于秋水，我止于你</h5><h1 id="Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort"><a href="#Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort" class="headerlink" title="Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort"></a>Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort</h1><h2 id="Base-on"><a href="#Base-on" class="headerlink" title="Base on ?"></a>Base on ?</h2><p><strong>Runway Reservation System</strong>!!!(My favourite plane! We’re saved!)</p><p><img src="/img/Runway.png" alt="Runway Reservation System"></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Each node x in the binary tree has a key <strong>key(x)</strong>.Nodes other than the root have a <strong>parent p(x)</strong>.Nodes may have a left child <strong>left(x)</strong> and&#x2F;or a right child <strong>right(x)</strong>.<br>ps：ALL POINTERS!Unlike in the Heap.</p><p><strong>Characteristics</strong>：for any node x, for all nodes y in the left subtree of x, key(y) ≤ key(x). For all nodes y in the right subtree of x key(y) ≥ key(x).</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>As the picture shows below🤓<br><img src="/img/BST%E6%8F%92%E5%85%A5.png" alt="BST insert operation"></p><p>Under the problem,we need to do the “Within K minutes Check” before inserting.If doesn’t follow,then stop the insertion.</p><h2 id="Find-Exists-find-val"><a href="#Find-Exists-find-val" class="headerlink" title="Find Exists : find(val)"></a>Find Exists : find(val)</h2><p>Follow left and right pointers until you find it or hit NIL.</p><h2 id="Find-the-minimum-element-in-a-BST-findmin"><a href="#Find-the-minimum-element-in-a-BST-findmin" class="headerlink" title="Find the minimum element in a BST : findmin()"></a>Find the minimum element in a BST : findmin()</h2><p>Just go left until you can’t.</p><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><p>All the operations above have an O(h) time complexity.<br>ps: <strong>h is the height of BST</strong></p><p>We may find a problem: somehow in a tricky (or abstract) way of insertion, the BST may turn to a <strong>List</strong>.So the complexity will be O(n),but we hope O(logn).😣😣😣</p><p>We’re gonna talk about it next time in the <strong>AVL Chapter</strong>😋😋😋<br>Balanced BSTs to the rescue in the next lecture!</p><h2 id="Find-the-next-larger-element-next-larger-x"><a href="#Find-the-next-larger-element-next-larger-x" class="headerlink" title="Find the next larger element: next_larger(x)"></a>Find the next larger element: next_larger(x)</h2><p>IF right child is not NIL,return minimun(x -&gt; right)<br>    else y &#x3D; parent(x)</p><pre><code class="hljs">while y not NIL and x = right(y)    x =  y    y = parent(y)return y;</code></pre><h2 id="How-many-planes-are-scheduled-to-land-at-times-≤-t"><a href="#How-many-planes-are-scheduled-to-land-at-times-≤-t" class="headerlink" title="How many planes are scheduled to land at times ≤ t?"></a>How many planes are scheduled to land at times ≤ t?</h2><p>Algorithm:<br>1.Walk down tree to find desired time( find t pos )<br>2.Add in nodes that are smaller<br>3.Add in subtree sizes to the left( record the size of the subtrees)</p><h2 id="附上早上手写的BST"><a href="#附上早上手写的BST" class="headerlink" title="附上早上手写的BST"></a>附上早上手写的BST</h2><p>（由于赶时间就没写类模板了，int型BST凑合看看吧😢）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by JaneZ on 2025/3/2.</span><br><span class="hljs-comment">//</span><br>#ifndef BST_H<br>#define BST_H<br>#include &lt;cstdio&gt;<br><br>class BinarySearchTree &#123;<br>private:<br>    struct treeNode &#123;<br>        treeNode *parent;<br>        treeNode *left;<br>        treeNode *right;<br>        int count; <span class="hljs-comment">//单个结点出现次数</span><br>        int size; <span class="hljs-comment">//以该结点为根 的子树大小</span><br>        int value; <span class="hljs-comment">//存储的值，这里以整数为例</span><br><br>        treeNode(treeNode *p = nullptr,treeNode *l = nullptr,treeNode *r = nullptr,int c = <span class="hljs-number">1</span>,int s = <span class="hljs-number">1</span>,int v = <span class="hljs-number">0</span>):<br>        parent(p),left(l),right(r),count(c),size(s),value(v)&#123;&#125;<br>    &#125;;<br><br>    treeNode *root;<br><br>    treeNode *buildTree(treeNode *other) &#123;<br>        <span class="hljs-keyword">if</span>(other != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">treeNode</span> *r = new treeNode(nullptr,nullptr,nullptr,other-&gt;</span><span class="hljs-function"><span class="hljs-title">count</span>,other-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>,other-&gt;</span>value);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = buildTree(other -&gt;</span> left);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = buildTree(other -&gt;</span> right);<br>            return r;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            return nullptr;<br>        &#125;<br>    &#125;<br><br>    void clear(treeNode *r) &#123;<br>        <span class="hljs-keyword">if</span>(r != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> left);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> right != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> right);<br>            &#125;<br>            delete r;<br>        &#125;<br>    &#125;<br>public:<br>    BinarySearchTree():root(nullptr)&#123;&#125;<br><br>    BinarySearchTree(const BinarySearchTree &amp;other) &#123;<br>        root = buildTree(other.root);<br>    &#125;<br><br>    ~BinarySearchTree() &#123;<br>        clear(root);<br>    &#125;<br><br>    treeNode *search(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == val) &#123;<br>            return r;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &lt; r -&gt;</span> value)&#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> right,val);<br>        &#125;<br>    &#125;<br><br>    treeNode *insert(treeNode *r,int key) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            r = new treeNode(nullptr,nullptr,nullptr,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,key);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == key) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span>count ++;<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &lt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> left,key);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &gt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//返回新的根结点</span><br>    treeNode *remove(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(val &lt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = remove(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> right,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> count &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> count --;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr ) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> right;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> right == nullptr) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> left;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//用右子树的最小值作为新的根结点</span><br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *pos = findMin(r -&gt;</span> right);<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> = pos -&gt;</span> count;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">value</span> = pos -&gt;</span> value;<br>                    <span class="hljs-function"><span class="hljs-title">pos</span> -&gt;</span> count = <span class="hljs-number">1</span>;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,pos -&gt;</span> value);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    treeNode *findMin(treeNode *r) &#123;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> = r -&gt;</span> left;<br>        &#125;<br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名</span><br>    int queryRank(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value == val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                return <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value &gt; val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">return</span> queryRank(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> 1 + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名为第k名的树</span><br>    int queryKth(treeNode *r,int k) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> left ,k);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> count &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,k - (r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> : 0) - r -&gt;</span> count);<br>    &#125;<br>&#125;;<br><br>#endif <span class="hljs-comment">//BST_H</span><br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Still an easy one.Can’t wait to see AVL!<br>立下flag，争取这周搞定用AVL实现的map!😋</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Algorithms1</title>
    <link href="/2025/03/01/Introduction-to-Algorithms1/"/>
    <url>/2025/03/01/Introduction-to-Algorithms1/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"><a href="#Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭" class="headerlink" title="Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 @three-hats-user 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"></a>Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 <a href="https://github.com/Jxint001">@three-hats-user</a> 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭</h4><h1 id="Introduction-to-Algorithms-1-Heaps-and-heap-sort"><a href="#Introduction-to-Algorithms-1-Heaps-and-heap-sort" class="headerlink" title="Introduction to Algorithms 1  Heaps and heap sort"></a>Introduction to Algorithms 1  Heaps and heap sort</h1><h2 id="Priority-Queues-Definition"><a href="#Priority-Queues-Definition" class="headerlink" title="Priority Queues Definition"></a>Priority Queues Definition</h2><p>A data structure implementing a set S of elements,each associated with a key,supporting the following operations: </p><ul><li>insert(S,x)</li><li>max(S)</li><li>extract_max(S):return element of S with largest key and remove it from S</li><li>increase_key(S,x,k):increase the value of element x’ s key to new value k</li></ul><p>Priority Queues can be built by using Heap or AVL.</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>As I said seconds before,<strong>Heap</strong> is one of the Implementations of a priority queue.</p><p>First,we are going to visualize an <strong>Array</strong> as a <strong>nearly complete binary tree</strong>（完全二叉树）</p><p>Let’s just talk about <strong>Max Heap</strong> here（Min Heap is exactly the same）</p><p><strong>Max Heap Property</strong>:The key of a node is $\geq$ than the key children.<br>For example:</p><p><img src="/img/%E5%A4%A7%E6%A0%B9%E5%A0%86%E4%BE%8B%E5%AD%90.png" alt="Max Heap Example"></p><p>Almost the same basic characteristics as Binary Tree</p><p>Here’re some simple Heap Operations:</p><ul><li>build max heap: produce a max-heap from an unordered array</li><li><strong>max_heapify</strong>: correct a single violation(违反) of the heap property in a subtree at its root</li><li>insert,extract_max,heapsort</li></ul><h3 id="The-most-important-procedure-Max-heapify"><a href="#The-most-important-procedure-Max-heapify" class="headerlink" title="The most important procedure: Max_heapify"></a>The most important procedure: Max_heapify</h3><p>• Assume that the trees rooted at left(i) and right(i) are max-heaps.</p><p>• If element A[i] violates the max-heap property, correct violation by “trickling” element A[i] down the tree, making the subtree rooted at index i a max-heap.</p><p>Here is an example of Max_heapify:<br><img src="/img/Heapify1.png" alt="Max_heapify1"><br><img src="/img/Heapify2.png" alt="Max_heapify2"><br><img src="/img/Heapify3.png" alt="Max_heapify3"></p><p>Time Complexity: O(logN)</p><h3 id="Build-Max-Heap"><a href="#Build-Max-Heap" class="headerlink" title="Build Max Heap"></a>Build Max Heap</h3><p>For n&#x2F;2 to 1  &#x2F;&#x2F;从后往前第一个非叶节点开始<br>    do Max_heapify(A,i)</p><p>这里我们很容易“看出”时间复杂度是O(NlogN)，然而真的如此嘛？<br>可以想一下，最底一层的非叶结点进行的操作次数至多只有1次，而并非logN次，只有根结点才会进行logN次操作，所以经过数学推导，我们可以验证，建堆操作的时间复杂度是O(N)</p><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p>I think it’s just a simple use of Max_Heap.Easy to understand and I will just show the thoughts.<br>(1)Build Max_Heap from an unordered array.<br>(2)Find A[1] (the biggest element)<br>(3)Swap elements A[1] and A[n]<br>(4)Discard(移除) n from the heap<br>(5)Run MaxHeapify to fix the missing 1 place<br>(6)Go to Step 2 until empty</p><p>The time complexity of Heap Sort is O(NlogN)</p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>这节的内容整体还是挺容易的，特别是在写完priority_queue之后😋<br>Keep Going!</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic2</title>
    <link href="/2025/02/28/Mathematical-Logic2/"/>
    <url>/2025/02/28/Mathematical-Logic2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"><a href="#Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅" class="headerlink" title="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"></a>Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅</h5><h5 id="Result：果断重开了"><a href="#Result：果断重开了" class="headerlink" title="Result：果断重开了"></a>Result：果断重开了</h5><h5 id="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"><a href="#Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！" class="headerlink" title="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"></a>Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！</h5><h1 id="Mathematical-Logic-2-一阶逻辑的语义"><a href="#Mathematical-Logic-2-一阶逻辑的语义" class="headerlink" title="Mathematical Logic 2 一阶逻辑的语义"></a>Mathematical Logic 2 一阶逻辑的语义</h1><h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><p>在不同的场合下，同一个一阶逻辑命题可能有不同的含义。如对∀v0Rv0v0，既可以解读成“任意自然数都整除自己”（真），也可以解读成“任何实数都小于自己”（假）<br>So：讨论语义时首先需要确定讨论的数学对象</p><p>刚刚的例子中，自然数和实数明确了讨论对象取自怎样的集合，这个集合称作<strong>域</strong>（universe），记为A</p><p>确定符号集中每个符号的含义，就是确定每个符号对应的元素、集合或映射具体是什么：</p><ul><li>一个n元关系就是某个A^n的子集 a(R)</li><li>一个n元函数就是某个A^n到A的映射 a(f)</li><li>每个常数符号对应A中某个特定元素 a(c)</li></ul><p>我们把这个从符号到其具体含义的映射记为a。<br>A 和 a 确定了一阶逻辑中变量的“定义域”和符号集中每个符号的含义。我们把二元组(A,a)记为 𝔄，称作<strong>S-结构</strong>。</p><p>对于符号集S &#x3D; {R,f,c}，我们通常将a(R)写作$R^𝔄$或$R^A$，a(f)写作$f^𝔄$或$f^A$，a(c)写作$c^𝔄$或$c^A$。</p><h2 id="Interpretation-解释"><a href="#Interpretation-解释" class="headerlink" title="Interpretation 解释"></a>Interpretation 解释</h2><p>Structure给出了变量的定义域和符号集的语义，但我们接下来还有<strong>terms</strong>和<strong>formulas</strong></p><p><strong>一个term的语义是从一个term到universe中一个元素的映射</strong>——$\beta$<br>为了确定这个映射，我们首先需要知道term中的每个变量代表universe当中的哪个元素，这就是要我们给出一个$v_i$ -&gt; A 的映射$\beta$</p><p>所以我们把一个S-structure和一个S-assignment的二元组称作I &#x3D; (𝔄,$\beta$)<br>定义<strong>解释</strong>的语义</p><ul><li>对于变量x，I(x) &#x3D; $\beta$(x)</li><li>对于常量c，I(c) &#x3D; $c^𝔄$</li><li>对于n元函数关系f $\in$ S，$t_1,t_2,…,t_n$均为S-terms。那么有I(ft_1 … t_n) &#x3D; $f^𝔄$(I(t_1),I(t_2),…,I(t_n))</li></ul><p><strong>formula的语义是从一个term到“真或假”的映射(类似于bool?)</strong><br>对于一个formula 𝜑  ，我们用记号 I |&#x3D; 𝜑  来表示 公式 𝜑 的语义为真，读作I 满足𝜑 ，|&#x3D; 即称为<strong>满足关系</strong>。（ 解释 I 满足公式 𝜑  ）</p><p>下面是一些原子性&#x2F;关于逻辑连词&#x2F;量词的情况<br><img src="/img/%E8%A7%A3%E9%87%8A%E6%BB%A1%E8%B6%B3%E5%85%AC%E5%BC%8F.png" alt="解释满足formulas"></p><p>(a) 当且仅当I(t_1)，I(t_2)是universe下的同一个元素<br>(b) 当且仅当 (I(t_1),…,I(t_n)) 属于$R^𝔄$<br>(c) 当且仅当 解释I 不满足公式 𝜑<br>(d) 当且仅当 解释I 满足公式 𝜑 且 解释I 满足公式Ψ<br>(e) 当且仅当 解释I 满足公式 𝜑  或 解释I 满足公式Ψ<br>(f) （一个有点神奇的解释）当且仅当 I |&#x3D; φ（语法上）表明解释I 满足公式 𝜑 （语义上）<br>(g) 当且仅当（还有一个当且仅当，亿点点绕）（解释I 满足 公式 𝜑 当且仅当解释I 满足公式Ψ）</p><p>比较复杂的就是 ∀ 和 ∃<br>(h) 想说的意思是：当且仅当universe中每个元素为公式 𝜑 中出现的x赋值并保持其他变量赋值不变，公式 𝜑 始终不变</p><p>为此我们定义一个描述为formula中的某个特定变量赋特殊的值的方便的符号：<br><img src="/img/Assignment.png" alt="修改赋值函数"></p><p>于是新的解释I 变为了：<br><img src="/img/%E6%96%B0%E8%A7%A3%E9%87%8A.png" alt="新的解释"><br>这表示在解释I 中，将变量 𝑥 的赋值修改为 𝑎，其他部分保持不变。</p><p>于是(h)表示的即为：对于域 𝐴中的每一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 都为真。</p><p>(i) （也是同理）存在域 𝐴中的一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 为真。</p><p>如果一个公式 𝜑 是valid(恒真)，那么所有的解释都能满足公式 𝜑</p><p>逻辑推论的定义：<br>Φ 是一个S-公式的集合；<br>公式 𝜑 是一个单独的S-公式<br>如果 Φ |&#x3D; 𝜑，表示 𝜑 是 Φ 的逻辑推论，即公式 𝜑 可以从 Φ 中逻辑推导出来</p><p>我们称公式 𝜑 是可满足的，如果存在一个S-解释I，使得公式 𝜑 在解释I下为真</p><p>公式 𝜑 和公式 Ψ 是逻辑等价的，如果 𝜑 |&#x3D; Ψ 且 Ψ |&#x3D; 𝜑</p><p><img src="/img/%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7.png" alt="逻辑等价例子"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/">https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/</a></p><p>这位博主真的救命，讲的太清楚了</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure13</title>
    <link href="/2025/02/27/Data-Structure13/"/>
    <url>/2025/02/27/Data-Structure13/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：priority-queue终于启动了！"><a href="#Before：priority-queue终于启动了！" class="headerlink" title="Before：priority_queue终于启动了！"></a>Before：priority_queue终于启动了！</h5><h5 id="情书只有三行，爱意起于一瞬，结局愿是一生"><a href="#情书只有三行，爱意起于一瞬，结局愿是一生" class="headerlink" title="情书只有三行，爱意起于一瞬，结局愿是一生"></a>情书只有三行，爱意起于一瞬，结局愿是一生</h5><h1 id="Data-Structure-13-优先级队列"><a href="#Data-Structure-13-优先级队列" class="headerlink" title="Data Structure 13 优先级队列"></a>Data Structure 13 优先级队列</h1><h2 id="优先级队列是什么？"><a href="#优先级队列是什么？" class="headerlink" title="优先级队列是什么？"></a>优先级队列是什么？</h2><p>元素之间的关系是由<strong>元素的优先级</strong>决定的，而不是由入队的先后次序决定。在优先级队列中，优先级最高的元素是队头元素，优先级最低的元素是队尾元素。</p><h2 id="基于树的优先级队列"><a href="#基于树的优先级队列" class="headerlink" title="基于树的优先级队列"></a>基于树的优先级队列</h2><p>基于线性表的优先级队列入队出队的时间复杂度总有一个会到O(N)，我们不可以接受这个时间复杂度，所以：<br>我们介绍一种基于树状组织的优先级队列——<strong>二叉堆</strong>。它可以使入队和出队操作的最坏情况下时间复杂度是O(logN)。</p><h2 id="优先级队列的存储实现"><a href="#优先级队列的存储实现" class="headerlink" title="优先级队列的存储实现"></a>优先级队列的存储实现</h2><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆是一棵满足结构性和有序性的二叉树，鉴于树状结构能给出指数的时间性能，所以将优先级队列组织成树是很自然的。我们需要保证树的高度尽可能小，所以这棵树最好是满二叉树，如果不满完全二叉树也可以。</p><p>完全二叉树可以采用顺序存储，利用父子结点的下标关系。另一个特性是有序性，堆的有序性是指最小的（或最大的）元素位于根的位置。</p><p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于&#x2F;小于等于其父亲的键值。<br>当根结点是最小元素时，称为<strong>最小化堆</strong>，当根结点是最大元素时，称为<strong>最大化堆</strong>。在优先级队列中如果数值越小优先级越高，则采用最小化堆存储；反之，如果数值越大优先级越高，则采用最大化堆存储。</p><h3 id="优先队列类的定义"><a href="#优先队列类的定义" class="headerlink" title="优先队列类的定义"></a>优先队列类的定义</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priorityQueue</span>: <span class="hljs-keyword">public</span> queue&lt;Type&gt;&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">int</span> capacity = <span class="hljs-number">100</span>);<br>        <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">const</span> Type data[],<span class="hljs-type">int</span> size);<br>        ~<span class="hljs-built_in">priorityQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp;x)</span></span>;<br>        <span class="hljs-function">Type <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">Type <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> currentSize; <span class="hljs-comment">//队列中元素个数</span><br>        Type *array; <span class="hljs-comment">//二叉堆数组起始地址</span><br>        <span class="hljs-type">int</span> maxSize; <span class="hljs-comment">//数组规模</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(<span class="hljs-type">int</span> hole)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优先队列的运算实现——以大根堆为例"><a href="#优先队列的运算实现——以大根堆为例" class="headerlink" title="优先队列的运算实现——以大根堆为例"></a>优先队列的运算实现——以大根堆为例</h3><p>首先是不带初始数据构造函数、析构函数、判空和取首函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">priorityQueue</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">capacity</span> = <span class="hljs-symbol">100</span>)&#123;<br>    <span class="hljs-built_in">array</span> = new Type[capacity];<br>    maxSize = capacity;<br>    currentSize = <span class="hljs-number">0</span>;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::~<span class="hljs-symbol">priorityQueue</span>()&#123;<br>    delete []<span class="hljs-built_in">array</span>;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> currentSize == <span class="hljs-number">0</span>;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">Type</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">getHead</span>()&#123;<br>    <span class="hljs-keyword">if</span>(!isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>enQueue操作，即入队的过程，我们把它称作<strong>向上过滤</strong>，这种实现方法是在下一个可用的位置创建一个空结点，然后把它沿着堆往上冒，这个过程的时间复杂度是O(logN)。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">enQueue</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">Type</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(currentSize == maxSize - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">double</span>Space();<br>    &#125;<br>    <span class="hljs-built_in">int</span> pos = ++currentSize;<br>    <span class="hljs-keyword">while</span>(pos != <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[pos] &gt; <span class="hljs-built_in">array</span>[pos/<span class="hljs-number">2</span>])&#123;<br>            <span class="hljs-built_in">int</span> tmp = <span class="hljs-built_in">array</span>[pos];<br>            <span class="hljs-built_in">array</span>[pos] = <span class="hljs-built_in">array</span>[pos/<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">array</span>[pos/<span class="hljs-number">2</span>] = tmp;<br>            pos /= <span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>deQueue操作，即出队的过程，二叉堆中我们要做的是删除根结点。我们的核心思想是：把根结点和完全二叉树中的最后一个结点交换值，然后删除最后一个结点，将根结点分别与左右结点进行比较，把它沿着堆往下过滤，这一过程称为<strong>向下过滤</strong>，时间复杂度同样是O(logN)。</p><p>实现这一过程，我们需要调用一个私有成员函数<code>void percolateDown(int hole);</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">Type</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">deQueue</span>()&#123;<br>    <span class="hljs-comment">//交换</span><br>    Type deNode;<br>    deNode = <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[currentSize - <span class="hljs-number">1</span>];<br>    percolateDown(<span class="hljs-number">1</span>); <span class="hljs-comment">//向下过滤根结点</span><br><br>    <span class="hljs-keyword">return</span> deNode;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">percolateDown</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">hole</span>)&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span> * hole &lt;= currentSize)&#123;<br>        <span class="hljs-keyword">if</span>(hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= currentSize)&#123;<br>            <span class="hljs-comment">//说明左右结点均存在</span><br>            Type tmp;<br>            <span class="hljs-built_in">int</span> x;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole + <span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole])&#123;<br>                tmp = <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole];<br>                x = <span class="hljs-number">2</span> * hole;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tmp = <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole + <span class="hljs-number">1</span>];<br>                x = <span class="hljs-number">2</span> * hole + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp &gt; <span class="hljs-built_in">array</span>[hole])&#123;<br>                Type t = <span class="hljs-built_in">array</span>[hole];<br>                <span class="hljs-built_in">array</span>[hole] = tmp;<br>                <span class="hljs-built_in">array</span>[x] = t;<br>                hole = x;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//只有左结点存在</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[hole] &gt; <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole])&#123;<br>                Type tmp = <span class="hljs-built_in">array</span>[hole];<br>                <span class="hljs-built_in">array</span>[hole] = <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole];<br>                <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span> * hole] = tmp;<br>                hole = <span class="hljs-number">2</span> * hole;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是如何构造这个二叉堆了<br>最简单的做法是执行N次enQueue操作（类似于二分查找），时间复杂度达到了O(NlogN)，考虑一种复杂度更低的建堆方法。</p><p>我们可以从编号最大的非叶结点开始，对结点进行<strong>向下过滤</strong>，这样计算下来的时间复杂度来到了O(N)（具体推导可见Introduction to Algorithms）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">buildHeap</span>()&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = currentSize / <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">1</span>;i--)&#123;<br>        percolateDown(i);<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt;<br><span class="hljs-symbol">priorityQueue</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">priorityQueue</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">Type</span> <span class="hljs-symbol">data</span>[],<span class="hljs-symbol">int</span> <span class="hljs-symbol">size</span>)&#123;<br>    currentSize = size;<br>    maxSize = size + <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">array</span> = new Type[maxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt;= currentSize;i++)&#123;<br>        <span class="hljs-built_in">array</span>[i] = data[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    buildHeap();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="However"><a href="#However" class="headerlink" title="However"></a>However</h2><p>我觉得这样写却有一些不美观，虽然利用数组下标节省了很多空间，但在处理归并堆时，使用数组就不太合适了，所以priority_queue同样可以用二叉链表实现，而且我们可以将push和pop的操作都统一到merge里去，就非常简洁了。</p><p>我在STLite2025——priority_queue类的实现中用了一个二叉链表来实现大根堆（实则维护了一棵<strong>左偏树</strong>）。害还不是因为一定要归并队列，不然谁还用链表写啊（真占内存）</p><p>先介绍一下<strong>左偏树</strong>（也可以叫<strong>左偏堆</strong>）<br>左偏树具有堆的性质，优点在于<strong>可以快速合并</strong>。对于一棵二叉树，我们定义外节点为子节点数小于两个的节点（省流：有空子节点的结点），定义一个节点的 <strong>dist</strong> 为其到子树中最近的外节点所经过的边的数量。空节点的 <strong>dist</strong> 为0。<br>特别注意：左偏树并不是一棵完全二叉树，故dist与树的深度没有关系</p><p>如下图所示，这是一棵左偏树：<br><img src="/img/%E5%B7%A6%E5%81%8F%E6%A0%911.png" alt="左偏树"></p><p>这，也是一棵左偏树：<br><img src="/img/%E5%B7%A6%E5%81%8F%E6%A0%912.png" alt="左偏树"></p><p>左偏树作为一个可并堆，核心操作在于归并堆merge操作：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl">Node *mergeHeap(Node *l,Node *r) &#123;<br>    <span class="hljs-keyword">if</span>(l == nullptr) &#123;<br>        return r;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>        return l;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(Compare()(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>,r -&gt;</span> <span class="hljs-keyword">data</span>)) &#123;<br>        std::swap(l ,r ); <span class="hljs-comment">//这一步是为了维护左子树的根结点一定较大</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">l</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = mergeHeap(l -&gt;</span> right,r);<br>    <span class="hljs-comment">// 这一步将左子树的右子树与右子树合并，这样左偏值最多增大 1</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(l -&gt;</span> left == nullptr) &#123;<br>        <span class="hljs-function"><span class="hljs-title">std</span>::swap(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>, l -&gt;</span> right);<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> != nullptr &amp;&amp; l -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">dist</span> &lt; l -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> dist) &#123;<br>        <span class="hljs-function"><span class="hljs-title">std</span>::swap(l -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span>, l -&gt;</span> right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">if</span>(l -&gt;</span> right == nullptr) &#123;<br>        <span class="hljs-function"><span class="hljs-title">l</span> -&gt;</span> dist = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">l</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">dist</span> = l -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> dist + <span class="hljs-number">1</span>;<br>    &#125;<br>    return l;<br>&#125;<br></code></pre></td></tr></table></figure><p>merge操作合并两个大小分别为 n 和 m 的堆复杂度是O(logN + logM)，实现了对数级复杂度</p><h2 id="其他可并堆"><a href="#其他可并堆" class="headerlink" title="其他可并堆"></a>其他可并堆</h2><h3 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h3><p>斜堆是满足堆的有序性，但没有任何平衡条件限定的二叉树。在斜堆中，不能保证树的深度是对数的。但从平均的概念上能够保证所有的操作都是对数的时间性能。它比左偏堆简单，不需要为结点保存空路径信息。</p><p>归并策略是：根结点值比较大的堆与根结点比较小的堆的右子堆归并，在完成一个归并前，对产生的临时树的右路径上的每个结点交换它们的左右孩子。</p><h3 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h3><p>二项堆不是用一棵满足堆的有序性的二叉树表示，而是用一个森林表示。森林中的每一棵树都有一定的约束，称为二项树。二项树是满足堆的有序性的树。高度为0的二项树是只有根结点的树，高度为k的二项树凡是将一棵B_(k - 1)加到另一棵B_(k - 1)的根上形成的。在这片森林中，每个高度的二项树之多只有一棵。</p><p><img src="/img/%E4%BA%8C%E9%A1%B9%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="二项树结构"></p><p>从二项树的特性可以看出，对给定的元素个数，可以构造唯一的一个二项堆。（二进制表示整数）<br>二项堆的归并操作：由低到高依次归并两个优先级队列中高度相同的树，也就是<strong>归并两个二项堆中对应的树</strong>。入队操作可以看成是归并的特例，出队操作只需删除最小根结点的二项树，将其裂成一个二项堆，再将其与原有二叉堆合并即可。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>树状结构正式结束！明天（尽量）进入集合结构！</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://oi-wiki.org/ds/heap/">https://oi-wiki.org/ds/heap/</a><br><a href="https://oi-wiki.org/ds/leftist-tree/">https://oi-wiki.org/ds/leftist-tree/</a><br><a href="https://www.luogu.com.cn/article/uoeyv3gq">https://www.luogu.com.cn/article/uoeyv3gq</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>Priority Queue</tag>
      
      <tag>Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure12</title>
    <link href="/2025/02/26/Data-Structure12/"/>
    <url>/2025/02/26/Data-Structure12/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）"><a href="#Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）" class="headerlink" title="Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）"></a>Before：喜欢物理，喜欢数分，喜欢数据结构😋😋😋（疑似学了一天发疯）</h5><h5 id="喜欢日升日落，喜欢璀璨星河，喜欢得不到的你"><a href="#喜欢日升日落，喜欢璀璨星河，喜欢得不到的你" class="headerlink" title="喜欢日升日落，喜欢璀璨星河，喜欢得不到的你"></a>喜欢日升日落，喜欢璀璨星河，喜欢得不到的你</h5><h1 id="Data-Structure-12-哈夫曼树-树和森林"><a href="#Data-Structure-12-哈夫曼树-树和森林" class="headerlink" title="Data Structure 12 哈夫曼树 树和森林"></a>Data Structure 12 哈夫曼树 树和森林</h1><h2 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h2><p>背景：<br>大多数计算机采用<strong>ASCII 编码</strong>，ASCII编码是一种等长的编码，每个字符的编码长度相同。但我们有一些常用的ASCII字符，也有一些较不常用的字符。如果所有字符均等长，将会造成保存文本空间较为庞大。所以我们可以让<strong>使用频率较高</strong>的字符拥有较短的编码，<strong>使用频率较低</strong>的字符拥有较长的编码，使得保存文本的空间减少。</p><p>举一个例子，现在有一个文本，下列字符的出现频率分别为：<br>a(10),e(15),i(12),s(3),t(4),空格(13),换行(1)</p><p>那么其占用的空间可以这样计算：</p><p><img src="/img/%E6%AD%A3%E5%B8%B8%E7%BC%96%E7%A0%81.png" alt="正常编码占用空间"></p><p>占用空间为：3*（10 + 15 + 12 + 3 + 4 + 13 + 1） &#x3D; 174 bit</p><p>而若采用不等长编码，文本存储空间将会大大节省：</p><p>3 * 10 + 2 * 15 + 2 * 12 + 5 * 3 + 4 * 4 + 2 * 13 + 5 * 1 &#x3D; 146 bit</p><p>那么如何找到这个优化的编码呢？可以先构建一棵哈夫曼树，再从哈夫曼树获得哈夫曼编码</p><h2 id="哈夫曼树构建"><a href="#哈夫曼树构建" class="headerlink" title="哈夫曼树构建"></a>哈夫曼树构建</h2><p>我们构建一棵<strong>完全二叉树</strong>，在这棵树中，字符仅被存放在叶结点中，每个字符的编码是从根结点到叶结点的路径，<strong>0表示左子树，1表示右子树</strong>。<br>Example：如果从根结点出发，向右，向左，再向右，表示的即为101。</p><p>我们可以得到：若一个字符到根结点，经过的树枝数为L，在文本中出现的次数为w，则占用的存储空间为 L*w。每个字符总的存储量被定义为这个编码的<strong>代价</strong>。</p><p>按照上述建树的方式，我们可以将先前例子中的文本表示成一棵瓦努请安二叉树：<br><img src="/img/%E7%AD%89%E9%95%BF%E7%BC%96%E7%A0%81%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="等长编码下的完全二叉树"><br>我们考虑对这棵树进行一些优化，比如可以看到换行字符的父结点只有一个子结点，故我们考虑将换行符移到其父结点的位置，这样换行符的存储空间就减小了 1bit，得到一个比原来更优的存储方案。这样一种存储方案其实还包含了字符间的一个性质：<strong>没有一个字符的编码会是另一个另一个字符编码的前缀。</strong><br>换句话说，字符编码可以有不同的长度，只要每个字符的编码与其他任何字符编码的前缀不同即可。这种编码方式称为<strong>前缀编码</strong>。</p><p>上述问题的最优二叉树如下图所示：</p><p><strong>我们要找到一棵最小代价的二叉树！！！</strong><br>隆重推出：</p><h2 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h2><p>下面是Huffman Tree的构造规则：<br>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。n个权值分别设为 w_1、w_2、… 、w_n。<br>(1)将w_1、w_2、… 、w_n看成是有n棵树的森林（每棵树仅有一个结点）；<br>(2)在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br>(3)从森林中删除选取的两棵树，并将新树加入森林；<br>(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树（最优二叉树）</p><h2 id="哈夫曼树类的实现"><a href="#哈夫曼树类的实现" class="headerlink" title="哈夫曼树类的实现"></a>哈夫曼树类的实现</h2><p>我们采用动态数组来实现哈夫曼树，优势在于：父子节点关系可以通过下标计算，代码更简洁<br>思路已经很清楚了，就直接上代码了😋</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hfTree</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>            Type data;<br>            <span class="hljs-type">int</span> parent,lchild,rchild; <span class="hljs-comment">// 存地址（数组下标）</span><br>            <span class="hljs-type">int</span> weight; <span class="hljs-comment">// 权值</span><br>        &#125;;<br>        Node *elem;<br>        <span class="hljs-type">int</span> length;<br>    <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hfCode</span>&#123; <span class="hljs-comment">// 哈夫曼编码信息</span><br>            Type data;<br>            string code;<br>        &#125;;<br><br>        <span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *x,<span class="hljs-type">const</span> <span class="hljs-type">int</span> *w,<span class="hljs-type">int</span> size);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCode</span><span class="hljs-params">(hfCode result[])</span></span>;<br>        ~<span class="hljs-built_in">hfTree</span>()&#123;<br>            <span class="hljs-keyword">delete</span> []elem;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们首先要实现哈夫曼树类中最重要的一个函数——<strong>构造函数</strong>，我们需要在构造函数中实现哈夫曼树的构建。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fortran">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-keyword">Type</span>&gt;<br>hfTree&lt;<span class="hljs-keyword">Type</span>&gt;::hfTree(const <span class="hljs-keyword">Type</span> *x,const <span class="hljs-built_in">int</span> *w,<span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>)&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">min1</span>,min2; // 第一小、第二小的权值<br>    <span class="hljs-built_in">int</span> x,y; // 第一小、第二小的下标<br>    length = <span class="hljs-built_in">size</span> * <span class="hljs-number">2</span>;<br>    elem = new Node[<span class="hljs-built_in">size</span> * <span class="hljs-number">2</span>];<br><br>    for(<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">size</span>;i &lt; length;i ++)&#123;<br>        elem[i].<span class="hljs-keyword">data</span> = x[i - <span class="hljs-built_in">size</span>];<br>        elem[i].weight = w[i - <span class="hljs-built_in">size</span>];<br>        elem[i].parent = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    for(<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>        <span class="hljs-built_in">min1</span> = min2 = <span class="hljs-number">32647</span>;<br>        for(<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>;j &lt; length;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(elem[j].parent == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(elem[j].weight &lt; <span class="hljs-built_in">min1</span>)&#123;<br>                    min2 = <span class="hljs-built_in">min1</span>;<br>                    <span class="hljs-built_in">min1</span> = elem[j].weight;<br>                    y = x;<br>                    x = j;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(elem[j].weight &lt; min2)&#123;<br>                    min2 = elem[j].weight;<br>                    y = j;<br>                &#125;<br>            &#125;<br>            elem[x].parent = i;<br>            elem[y].parent = i;<br>            elem[i].lchild = y;<br>            elem[i].rchild = x;<br>            elem[i].weight = <span class="hljs-built_in">min1</span> + min2;<br>            elem[i].parent = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getCode函数用来获得字符对应的Huffman编码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">void</span> hfTree&lt;Type&gt;::<span class="hljs-built_in">getCode</span>(hfCode result[])&#123;<br>    <span class="hljs-type">int</span> size = length/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> p,c;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = size;i &lt; length;i++)&#123;<br>        result[i - size].data = elem[i].data;<br>        result[i - size].code = <span class="hljs-string">&quot;&quot;</span>;<br>        p = elem[i].parent;<br>        s = i;<br><br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p.lchild == s)&#123;<br>                result[i - size].code += <span class="hljs-string">&quot;0&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[i - size].code += <span class="hljs-string">&quot;1&quot;</span>;<br>            &#125;<br>            s = p;<br>            p = elem[p].parent;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>搞定！是不是挺简单的😋</p><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p><strong>不再是二叉树，而是n叉树，结点里该存什么？</strong></p><h3 id="树的存储实现"><a href="#树的存储实现" class="headerlink" title="树的存储实现"></a>树的存储实现</h3><ul><li><p>孩子链表示法<br>由于每个结点的孩子数量差异较大，如果开一个指针数组存孩子地址会造成大量空间的浪费，于是考虑用链表对所有子结点的地址进行存储<br><img src="/img/%E5%AD%A9%E5%AD%90%E9%93%BE.png" alt="孩子链表示法"></p></li><li><p>孩子兄弟链表示法（<strong>最常用的树的存储结构</strong>）<br>孩子兄弟链表示法中结点形式与二叉树一致，区别在于：<strong>左指针指向第一个儿子，右指针指向下一个兄弟</strong>（看到这里Jane不禁叫好，真是绝妙😝）<br><img src="/img/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E9%93%BE.png" alt="孩子兄弟链表示法"></p></li><li><p>双亲表示法<br>树上每个结点可以有多个儿子，但只能有一个父亲。所以想法很简单，通过指向父结点的指针将整棵树组织起来。这个结构可以直接存在数组里。<br><img src="/img/%E5%8F%8C%E4%BA%B2.png" alt="双亲表示法"></p></li></ul><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ul><li>前序遍历</li><li>后序遍历</li><li>层次遍历</li></ul><h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><p>树的孩子兄弟链表示法其实就可以把一棵树当成是二叉树进行考虑，<strong>把二叉树的左结点看作是第一个儿子，右节点看作是下一个兄弟</strong>。<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2.png" alt="一般树向二叉树的转换"></p><p>我们还可以将森林转化成一棵大二叉树，利用了一个性质：<strong>根结点没有兄弟，即根结点没有右子树</strong>，只需以下2步：<br>（1）将森林里每一棵树转化成二叉树<br>（2）将B_i 作为B_(i-1)根结点的右子树</p><p><img src="/img/%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2.png" alt="将森林转化为一棵二叉树"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/sugarbliss/article/details/80315327">https://blog.csdn.net/sugarbliss/article/details/80315327</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>Huffman Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure11</title>
    <link href="/2025/02/25/Data-Structure11/"/>
    <url>/2025/02/25/Data-Structure11/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：全世界都在偶遇她，只有我没机会嘛😥"><a href="#Before：全世界都在偶遇她，只有我没机会嘛😥" class="headerlink" title="Before：全世界都在偶遇她，只有我没机会嘛😥"></a>Before：全世界都在偶遇她，只有我没机会嘛😥</h5><h1 id="Data-Structure-11-二叉链表遍历的非递归实现及二叉树的应用"><a href="#Data-Structure-11-二叉链表遍历的非递归实现及二叉树的应用" class="headerlink" title="Data Structure 11 二叉链表遍历的非递归实现及二叉树的应用"></a>Data Structure 11 二叉链表遍历的非递归实现及二叉树的应用</h1><h2 id="二叉链表遍历的非递归实现"><a href="#二叉链表遍历的非递归实现" class="headerlink" title="二叉链表遍历的非递归实现"></a>二叉链表遍历的非递归实现</h2><p>上一节翁阿姨的课上，我们讲到了通过栈对函数实现非递归调用，而今天所说的二叉链表遍历的非递归实现，同样也是依靠链接栈这一数据结构实现的。实现时需要注意进栈顺序的细节，下面给出代码实现。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">template &lt;class T&gt;<br>void binaryTree&lt;T&gt;::preOrder() const&#123;<br>    linkStack&lt;Node *&gt; s;<br>    s.push(root);<br>    <span class="hljs-keyword">while</span>(!s.isEmpty())&#123;<br>        Node *tmp = s.pop();<br>        <span class="hljs-function"><span class="hljs-title">cout</span> &lt;&lt; tmp -&gt;</span> <span class="hljs-keyword">data</span>;<br><br>        <span class="hljs-function"><span class="hljs-title">if</span>(tmp -&gt;</span> left != nullptr)&#123;<br>            <span class="hljs-function"><span class="hljs-title">s</span>.push(tmp -&gt;</span> left);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(tmp -&gt;</span> right != nullptr)&#123;<br>            <span class="hljs-function"><span class="hljs-title">s</span>.push(tmp -&gt;</span> right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而中序遍历在实现时则有一些不同，因为中序遍历要求<strong>先访问左子树</strong>，再访问根结点，最后访问<strong>右子树</strong>，所以在根结点出栈后不能先访问它，而将其暂存，先访问<strong>左子树</strong>，再访问它。为了解决这一问题，我们重新更换一种结点，记录结点进栈的次数。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct StNode&#123;<br>    Node *node<span class="hljs-comment">;</span><br>    int timePop<span class="hljs-comment">;</span><br>    StNode(Node *n <span class="hljs-operator">=</span> nullptr)&#123;<br>        node <span class="hljs-operator">=</span> n<span class="hljs-comment">;</span><br>        timePop <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    &#125;<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nsis">template &lt;class T&gt;<br>void binaryTree&lt;T&gt;::midOrder() const&#123;<br>    linkStack&lt;StNode&gt; s<span class="hljs-comment">;</span><br>    StNode <span class="hljs-literal">current</span>(root)<span class="hljs-comment">;</span><br><br>    while(!s.isEmpty())&#123;<br>        <span class="hljs-literal">current</span> = s.<span class="hljs-keyword">pop</span>()<span class="hljs-comment">;</span><br>        ++ <span class="hljs-literal">current</span>.timePop<span class="hljs-comment">;</span><br>        if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">2</span>)&#123;<br>            // 出栈<span class="hljs-number">2</span>次了<br>            cout &lt;&lt; <span class="hljs-literal">current</span>.node -&gt; data &lt;&lt; endl<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span> != nullptr)&#123;<br>                <span class="hljs-literal">current</span>.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;else&#123;<br>            // 重新被推回栈中<br>            s.<span class="hljs-keyword">push</span>(<span class="hljs-literal">current</span>)<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span> != nullptr)&#123;<br>                <span class="hljs-literal">current</span>.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是后序遍历，与中序遍历实现方法类似，但只有在第三次出栈时才会被访问</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nsis">template &lt;class T&gt;<br>void binaryTree&lt;T&gt;::postOrder() const&#123;<br>    linkStack&lt;StNode&gt; s<span class="hljs-comment">;</span><br>    StNode <span class="hljs-literal">current</span>(root)<span class="hljs-comment">;</span><br><br>    while(!s.isEmpty())&#123;<br>        <span class="hljs-literal">current</span> = s.<span class="hljs-keyword">pop</span>()<span class="hljs-comment">;</span><br>        ++ <span class="hljs-literal">current</span>.timePop<span class="hljs-comment">;</span><br><br>        if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">3</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-literal">current</span>.node -&gt; data &lt;&lt; endl<span class="hljs-comment">;</span><br>        &#125;else if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">2</span>)&#123;<br>            s.<span class="hljs-keyword">push</span>(<span class="hljs-literal">current</span>)<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span> != nullptr)&#123;<br>                s.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">right</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;else if(<span class="hljs-literal">current</span>.timePop == <span class="hljs-number">1</span>)&#123;<br>            s.<span class="hljs-keyword">push</span>(<span class="hljs-literal">current</span>)<span class="hljs-comment">;</span><br>            if(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span> != nullptr)&#123;<br>                s.<span class="hljs-keyword">push</span>(StNode n(<span class="hljs-literal">current</span>.node -&gt; <span class="hljs-literal">left</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的应用——计算表达式"><a href="#二叉树的应用——计算表达式" class="headerlink" title="二叉树的应用——计算表达式"></a>二叉树的应用——计算表达式</h2><p>由于算术运算符是二元运算符，故可以很自然地表示成一棵二叉树，根结点表示运算符，左右孩子是运算数，这棵树被称为<strong>表达式树</strong>，既然如此，我们知道对这棵树的遍历是<strong>后序遍历</strong><br>下面就是一棵表达式树：<br><img src="/img/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91.png" alt="表达式树"></p><p>所描述的表达式为：**(4 - 2)<em>(10 + (4 + 6)&#x2F;2) + 2</em>*</p><p>这个逻辑构造似乎还是比较好理解的，所以，我们就直接来看看如何建树吧。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class calc&#123;<br>    enum <span class="hljs-keyword">Type</span>&#123;DATA,ADD,SUB,MULTI,DIV,OPAREN,CPAREN,EOL&#125;;<br><br>    struct <span class="hljs-keyword">node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">        Type</span> <span class="hljs-keyword">type</span>;<br>        int data;<br>        <span class="hljs-keyword">node</span> <span class="hljs-title">*lchild</span>,rchild;<br><br>        <span class="hljs-keyword">node</span><span class="hljs-title">(Type</span> t,int d = <span class="hljs-number">0</span>,<span class="hljs-keyword">node</span> <span class="hljs-title">*lc</span> = nullptr,<span class="hljs-keyword">node</span> <span class="hljs-title">*rc</span> = nullptr)&#123;<br>            <span class="hljs-keyword">type</span> = t;<br>            data = d;<br>            lchild = lc;<br>            rchild = rc;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*root</span>;<br><br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*create</span>(char *&amp;s); //创建一棵表达式树<br>    <span class="hljs-keyword">Type</span> getToken(char *&amp;s,int &amp;value); // 获得一个切片<br>    int result(<span class="hljs-keyword">node</span> <span class="hljs-title">*t</span>); //计算表达式结果<br><br>    public:<br>        calc(char *s)&#123;<br>            root = create(s);<br>        &#125;<br><br>        int result()&#123;<br>            if(root == nullptr)&#123;<br>                return <span class="hljs-number">0</span>;<br>            &#125;<br>            return result(root);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>create函数的实现</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xquery">calc::node *calc::create(char *&amp;s)&#123;<br>    calc::node *p,<span class="hljs-built_in">*root</span> = nullptr;<br>    Type returnType;<br>    int <span class="hljs-keyword">value</span>;<br><br>    while(*s)&#123;<br>        returnType = calc::getToken(s,<span class="hljs-keyword">value</span>);<br><br>        <span class="hljs-keyword">switch</span>(returnType)&#123;<br>            <span class="hljs-keyword">case</span> DATA:case OPAREN:<br>                <span class="hljs-keyword">if</span>(returnType == DATA)&#123;<br>                    <span class="hljs-type">node</span> *p = new <span class="hljs-type">node</span>(DATA,<span class="hljs-keyword">value</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    p = create(s);<br>                &#125;<br>                <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> != nullptr)&#123;<br>                    <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> -&gt; rchild == nullptr)&#123;<br>                       <span class="hljs-built_in"> root</span> -&gt; rchild = p;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                       <span class="hljs-built_in"> root</span> -&gt; rchild -&gt; rchild = p;<br>                    &#125;<br>                &#125;<br>                break;<br>            <span class="hljs-keyword">case</span> ADD: <span class="hljs-keyword">case</span> SUB:<br>                <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> == nullptr)&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span>,p);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span><span class="hljs-built_in">,root</span>);<br>                &#125;<br>                break;<br>            <span class="hljs-keyword">case</span> MULTI: <span class="hljs-keyword">case</span> DIV:<br>                <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> == nullptr)&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span>,p);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span> -&gt; type == MULTI ||<span class="hljs-built_in"> root</span> -&gt; type == DIV)&#123;<br>                   <span class="hljs-built_in"> root</span> = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span><span class="hljs-built_in">,root</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                   <span class="hljs-built_in"> root</span> -&gt; rchild = new <span class="hljs-type">node</span>(returnType,<span class="hljs-number">0</span><span class="hljs-built_in">,root</span> -&gt; rchild);<br>                &#125;<br>                break;<br>            <span class="hljs-keyword">case</span> CPAREN: caseEOL:<br>                <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>getToken 函数与先前在Bookstore-2024中写的TokenScanner类类似，故不描述了（好懒啊😅）</p><p>另一个比较有趣的函数——result</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xl">int calc::result(calc::node *t)&#123;<br>    int num1,num2;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> type == DATA)&#123;<br>        <span class="hljs-function"><span class="hljs-title">return</span> t -&gt;</span> <span class="hljs-keyword">data</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">num1</span> = calc(t -&gt;</span> lchild);<br>    <span class="hljs-function"><span class="hljs-title">num2</span> = calc(t -&gt;</span> rchild);<br>    <span class="hljs-function"><span class="hljs-title">if</span>(t -&gt;</span> type == ADD)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 + num2;<br>        return num1 + num2;<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(t -&gt;</span> type == SUB)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 - num2;<br>        return num1 - num2;<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(t -&gt;</span> type == MULTI)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 * num2;<br>        return num1 * num2;<br>    &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(t -&gt;</span> type == DIV)&#123;<br>        <span class="hljs-function"><span class="hljs-title">t</span> -&gt;</span> <span class="hljs-keyword">data</span> = num1 / num2;<br>        return num1 / num2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclude"><a href="#Conclude" class="headerlink" title="Conclude"></a>Conclude</h2><p>这两天一直在写二叉树，总结一下，真是对<strong>递归</strong>很巧妙的应用呢！<br>下面就是<strong>Huffman Tree</strong>了，离priority_queue越来越近了😝</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure10</title>
    <link href="/2025/02/24/Data-Structure10/"/>
    <url>/2025/02/24/Data-Structure10/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：接Data-Structure-9，继续二叉链表…"><a href="#Before：接Data-Structure-9，继续二叉链表…" class="headerlink" title="Before：接Data Structure 9，继续二叉链表…"></a>Before：接Data Structure 9，继续二叉链表…</h5><h5 id="PS-Today-is-a-happy-day-for-Jane-maybe-you-can-guess-why"><a href="#PS-Today-is-a-happy-day-for-Jane-maybe-you-can-guess-why" class="headerlink" title="PS: Today is a happy day for Jane,maybe you can guess why?"></a>PS: Today is a happy day for Jane,maybe you can guess why?</h5><h1 id="Data-Structure-10-二叉链表"><a href="#Data-Structure-10-二叉链表" class="headerlink" title="Data Structure 10 二叉链表"></a>Data Structure 10 二叉链表</h1><h2 id="二叉链表类定义"><a href="#二叉链表类定义" class="headerlink" title="二叉链表类定义"></a>二叉链表类定义</h2><p>首先，回顾一下《C++程序设计思想与方法》，<strong>友元函数（friend function）</strong>是一个特殊的函数，它可以访问类的私有（private）和保护（protected）成员，即使它不是该类的成员函数。</p><p>下面给出定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-type">T</span>&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> binaryTree:public bTree&lt;<span class="hljs-type">T</span>&gt;&#123;</span><br><span class="hljs-class">    friend void printTree(<span class="hljs-title">const</span> <span class="hljs-title">binaryTree</span>&lt;<span class="hljs-type">T</span>&gt; &amp;<span class="hljs-title">t</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>);</span><br><span class="hljs-class">private:</span><br><span class="hljs-class">    struct <span class="hljs-type">Node</span>&#123;</span><br><span class="hljs-class">        <span class="hljs-type">Node</span> *left,right;</span><br><span class="hljs-class">        <span class="hljs-type">T</span> data;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        <span class="hljs-type">Node</span>():left(<span class="hljs-title">nullptr</span>),right(<span class="hljs-title">nullptr</span>)&#123;&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        <span class="hljs-type">Node</span>(<span class="hljs-type">T</span> <span class="hljs-title">data</span>,<span class="hljs-type">Node</span> *<span class="hljs-title">l</span> = <span class="hljs-title">nullptr</span>,<span class="hljs-type">Node</span> *<span class="hljs-title">r</span> == <span class="hljs-title">nullptr</span>)&#123;</span><br><span class="hljs-class">            left = l;</span><br><span class="hljs-class">            right = r;</span><br><span class="hljs-class">            data = <span class="hljs-type">Data</span>;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        ~<span class="hljs-type">Node</span>()&#123;&#125;</span><br><span class="hljs-class">    &#125;;</span><br><span class="hljs-class"></span><br><span class="hljs-class">    <span class="hljs-type">Node</span> *root; // 二叉树根结点</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    binaryTree():root(<span class="hljs-title">nullptr</span>)&#123;&#125;</span><br><span class="hljs-class">    binaryTree(<span class="hljs-type">T</span> <span class="hljs-title">x</span>):root(<span class="hljs-title">new</span> <span class="hljs-type">Node(x)</span>)&#123;&#125;</span><br><span class="hljs-class">    ~binaryTree();</span><br><span class="hljs-class"></span><br><span class="hljs-class">    void clear();</span><br><span class="hljs-class">    bool isEmpty() const;</span><br><span class="hljs-class">    <span class="hljs-type">T</span> <span class="hljs-type">Root</span>(<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const;</span><br><span class="hljs-class">    <span class="hljs-type">T</span> lChild(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const;</span><br><span class="hljs-class">    <span class="hljs-type">T</span> rChild(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const;</span><br><span class="hljs-class">    void delLeft(<span class="hljs-type">T</span> <span class="hljs-title">x</span>);</span><br><span class="hljs-class">    void delRight(<span class="hljs-type">T</span> <span class="hljs-title">x</span>);</span><br><span class="hljs-class">    void preOrder() const;</span><br><span class="hljs-class">    void midOrder() const;</span><br><span class="hljs-class">    void postOrder() const;</span><br><span class="hljs-class">    void levelOrder() const;</span><br><span class="hljs-class">    void createTree(<span class="hljs-type">T</span> <span class="hljs-title">flag</span>);</span><br><span class="hljs-class">    <span class="hljs-type">T</span> parent(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">T</span> <span class="hljs-title">flag</span>) const&#123;&#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">private:</span><br><span class="hljs-class">    <span class="hljs-type">Node</span> *find(<span class="hljs-type">T</span> <span class="hljs-title">x</span>,<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">    void clear(<span class="hljs-type">Node</span> *&amp;<span class="hljs-title">t</span>);</span><br><span class="hljs-class">    void preOrder(<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">    void midOrder(<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">    void postOrder(<span class="hljs-type">Node</span> *<span class="hljs-title">t</span>) const;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="二叉链表类的运算实现"><a href="#二叉链表类的运算实现" class="headerlink" title="二叉链表类的运算实现"></a>二叉链表类的运算实现</h2><p>首先是isEmpty、Root、clear和析构函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> root == <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">T</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Root</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">flag</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">clear</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *&amp;<span class="hljs-symbol">t</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    clear(t-&gt;left);<br>    clear(t-&gt;right);<br>    delete t;<br>    t = <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::~<span class="hljs-symbol">binaryTree</span>()&#123;<br>    clear(root);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是遍历函数的实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">preOrder</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout &lt;&lt; t-&gt;data;<br>    preOrder(t-&gt;left);<br>    preOrder(t-&gt;right);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">preOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    preOrder(root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">midOrder</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    midOrder(t-&gt;left);<br>    cout &lt;&lt; t-&gt;data;<br>    midOrder(t-&gt;right);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">midOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    midOrder(root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">postOrder</span>(<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    postOrder(t-&gt;left);<br>    postOrder(t-&gt;right);<br>    cout &lt;&lt; t-&gt;data;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">postOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    postOrder(root);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">levelOrder</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-comment">// 这里采用链接队列实现</span><br>    <span class="hljs-comment">// 类似于广度优先搜索（BFS）</span><br>    linkQueue&lt;Node *&gt; que;<br>    Node *tmp;<br>    que.enQueue(root);<br><br>    <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>        tmp = que.deQueue;<br>        cout &lt;&lt; tmp -&gt; data;<br>        <span class="hljs-keyword">if</span>(tmp -&gt; left)&#123;<br>            que.enQueue(tmp -&gt; left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp -&gt; right)&#123;<br>            que.enQueue(tmp -&gt; right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是find、lChild、rChild、delLeft、delRight函数实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">Node</span> *<span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">find</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x,<span class="hljs-symbol">binaryTree</span></span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Node</span> *<span class="hljs-symbol">t</span>) <span class="hljs-symbol">const</span>&#123;<br>    Node *tmp;<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t-&gt;data == x)&#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp = find(x,t-&gt;left))&#123;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp = find(x,t-&gt;right))&#123;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">T</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">lChild</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T</span></span> <span class="hljs-symbol">flag</span>) <span class="hljs-symbol">const</span>&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; left == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp -&gt; left -&gt; data;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">T</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">rChild</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T</span></span> <span class="hljs-symbol">flag</span>) <span class="hljs-symbol">const</span>&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; right == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp -&gt; right -&gt; data;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">delLeft</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x</span>)&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; left == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    clear(tmp -&gt; left);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">binaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">delRight</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">x</span>)&#123;<br>    Node *tmp = find(x,root);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp -&gt; right == <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    clear(tmp -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是createTree建树操作</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">template<span class="hljs-tag">&lt;class T&gt;</span><br>void binaryTree<span class="hljs-tag">&lt;T&gt;</span>::createTree(T flag)&#123;<br>    linkQueue<span class="hljs-tag">&lt;Node *&gt;</span>que;<br>    <span class="hljs-keyword">Node</span> <span class="hljs-title">*tmp</span>;<br>    T x,lData,rData;<br>    cin &gt;&gt; x;<br>    que.enQueue(new <span class="hljs-keyword">Node</span><span class="hljs-title">(x</span>));<br>    while(!que.isEmpty())&#123;<br>        tmp = que.deQueue();<br>        cin &gt;&gt; lDta &gt;&gt; rData;<br>        if(lData != flag)&#123;<br>            que.enQueue(tmp -&gt; left = new <span class="hljs-keyword">Node</span><span class="hljs-title">(lData</span>));<br>        &#125;<br>        if(rData != flag)&#123;<br>            que.enQueue(tmp -&gt; right = new <span class="hljs-keyword">Node</span><span class="hljs-title">(rData</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>附上友元函数打印树</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stata">void printTree(<span class="hljs-keyword">const</span> binaryTree&lt;T&gt; &amp;t,T flag)&#123;<br>    linkQueue&lt;T&gt;<span class="hljs-keyword">que</span>;<br>    <span class="hljs-keyword">que</span>.enQueue(t -&gt; root -&gt; data);<br>    <br>    <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">que</span>.isEmpty())&#123;<br>        T tmp = <span class="hljs-keyword">que</span>.deQueue();<br>        T <span class="hljs-keyword">l</span> = lChild(tmp,flag);<br>        T r = rChild(tmp,flag);<br>        cout &lt;&lt; tmp &lt;&lt; <span class="hljs-keyword">l</span> &lt;&lt; r &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">l</span> != flag)&#123;<br>            <span class="hljs-keyword">que</span>.enQueue(<span class="hljs-keyword">l</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r != flag)&#123;<br>            <span class="hljs-keyword">que</span>.enQueue(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic4</title>
    <link href="/2025/02/23/Java-Basic4/"/>
    <url>/2025/02/23/Java-Basic4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭"><a href="#Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭" class="headerlink" title="Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭"></a>Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭</h5><h1 id="Java-Basic-4"><a href="#Java-Basic-4" class="headerlink" title="Java Basic 4"></a>Java Basic 4</h1><h2 id="Good-program-design"><a href="#Good-program-design" class="headerlink" title="Good program design"></a>Good program design</h2><p>Correct &#x2F; Easy to understand &#x2F; Easy to modify &#x2F; speed</p><h3 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h3><p>Variables: nouns,lowercase first letter,capitals separating words<br>Methods: Verbs,lowercase first letter<br>Classes:nouns,uppercase first letter</p><h3 id="Good-Class-Design"><a href="#Good-Class-Design" class="headerlink" title="Good Class Design"></a>Good Class Design</h3><ul><li>Make fields and methods private by default 默认私有即可，无需强行private</li><li>Only make methods public if you need to 只有必要时将函数设为公有</li><li>If you need access to a field, create a method 我们建议将成员变量设成private，再通过get或set函数来获取值或修改值</li></ul><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><h3 id="Interval-Testing"><a href="#Interval-Testing" class="headerlink" title="Interval Testing"></a>Interval Testing</h3><p>Important cases<br>下界以下、等于下界、在区间内、等于上界、上界以上</p><h3 id="Eclipse-Warnings"><a href="#Eclipse-Warnings" class="headerlink" title="Eclipse Warnings"></a>Eclipse Warnings</h3><p>May not be a mistake, but it likely is.<br>Always fix all warning!</p><h3 id="Assertion-断言"><a href="#Assertion-断言" class="headerlink" title="Assertion 断言"></a>Assertion 断言</h3><p>断言用于验证代码是否按预期运行</p><ul><li>当断言条件为真时，程序正常运行，不会有额外操作。</li><li>当断言条件为假时，程序会崩溃并抛出错误。</li></ul><p><code>assert difference &gt;= 0</code><br>这行代码表示断言变量difference的值大于或等于0，如果不满足该条，程序将报错。</p><h2 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h2><p><img src="/img/interface.png" alt="Implementation/Interface"><br>Java接口可以在不了解对象内部工作原理的情况下对其进行操作。</p><ul><li>当处理相似但不完全相同的对象时，接口很有用</li><li>当想要使用他人编写的代码时，接口也很实用。通过定义接口，代码提供者可以明确对外提供的功能契约，使用者只需按照接口定义来调用，而无需关心具体实现细节</li></ul><p>类比：C++中的抽象基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Graphics<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drawable</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Graphics surface)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(Color color)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Graphics<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drawable</span>&#123;<br>    <span class="hljs-comment">//some stuff...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Graphics surface)</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>implement关键字：用于类与接口之间的关系，表明一个类要实现接口中定义的所有抽象方法。<strong>一个类可以实现多个接口</strong>，从而具备多种不同的行为。（与后文提到的extends一个重要的区别）</p><h3 id="Interface-Notes-关于抽象基类"><a href="#Interface-Notes-关于抽象基类" class="headerlink" title="Interface Notes 关于抽象基类"></a>Interface Notes 关于抽象基类</h3><ul><li>只有函数</li><li>不提供具体代码实现，只提供定义</li><li>一个类可以实现任意数量的接口<br>关于最后一点，在C++中，可以举个这样的例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 第一个抽象类，模拟第一个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数，模拟接口方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Flyable</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 第二个抽象类，模拟第二个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Swimmable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数，模拟接口方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Swimmable</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 一个类继承多个抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> : <span class="hljs-keyword">public</span> Flyable, <span class="hljs-keyword">public</span> Swimmable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 实现Flyable接口的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Duck is flying.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// 实现Swimmable接口的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Duck is swimming.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><p>当通过接口来引用对象时，只能访问接口中定义的成员（方法、常量等）<br>举个例子：<br><code>Drawable d = new BouncingBox(...);</code><br>d只能访问Grawable接口中定义的draw函数<br>相当于接口限定了外部可见功能的边界</p><h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Drawable d <span class="hljs-operator">=</span> new BouncingBox(...)<span class="hljs-comment">;</span><br>BouncingBox box <span class="hljs-operator">=</span> (BouncingBox) d<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>则box可以调用BouncingBox类中</p><h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>extends关键字：用于类与类之间的继承关系，即一个类（子类、派生类）可以继承另一个类（父类、基类）的属性和方法。<br>特别注意的是：<strong>在 Java 里，类的继承只支持单继承，也就是一个子类只能有一个直接父类。</strong><br>class A extends B{}：A是B的子类<br>A拥有B的全部成员变量和函数，且可以增加自己的成员变量和函数</p><p>Example:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    void eat() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Animal is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    void bark() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Dog is barking.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然A也可以通过implement替换父类中的某个函数<br>Example:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> speed;<br><br>    void move() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Vehicle is moving.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">extends</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> numDoors;<br><br>    <span class="hljs-variable">@Override</span><br>    void move() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is moving on the road.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>Java中的报错信息主要为以下几种：<br><img src="/img/Exceptions.png" alt="Java Exceptions"><br>Java 通过创建异常对象并抛出的方式处理异常</p><h3 id="throw-主动抛出异常"><a href="#throw-主动抛出异常" class="headerlink" title="throw 主动抛出异常"></a>throw 主动抛出异常</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>throws &amp; throw：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) throws ArrayOutOfBoundsException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= size())<br>        throw <span class="hljs-built_in">new</span> ArrayOutOfBoundsException(&quot;&quot;+<span class="hljs-keyword">index</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>throws关键字：用于方法声明中，它告诉 Java 这个get方法在执行过程中可能会抛出ArrayOutOfBoundsException（数组越界异常）</li><li>throw关键字：用于实际抛出一个ArrayOutOfBoundsException异常对象，并将index作为参数传递给异常构造函数，方便在异常处理时获取相关信息。</li></ul><h3 id="try-catch-捕获并处理异常"><a href="#try-catch-捕获并处理异常" class="headerlink" title="try-catch 捕获并处理异常"></a>try-catch 捕获并处理异常</h3><p>Java希望调用get函数来处理异常</p><ul><li>Catching it</li><li>Rethrowing it</li></ul><p>try块用于执行可能会抛出异常的代码。在执行过程中，一旦代码抛出异常，程序的执行流程就会立即改变。<br>catch块则是告诉 Java 当捕获到指定类型的异常时，应该执行什么样的处理逻辑。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">get</span>(<span class="hljs-number">-1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ArrayOutOfBoundsException err) &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;oh dear!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws Exception</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O-文件读写"><a href="#I-O-文件读写" class="headerlink" title="I&#x2F;O 文件读写"></a>I&#x2F;O 文件读写</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>以字节为单位进行数据读写，适用于处理所有类型的数据，如图片、音频等二进制文件。<br>InputStream（输入字节流的抽象类）和OutputStream（输出字节流的抽象类）</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>以字符为单位进行数据读写，适合处理文本数据。主要的字符流类有Reader（输入字符流的抽象类）和Writer（输出字符流的抽象类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;./src/readme&quot;</span>);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>        <span class="hljs-comment">//缓冲功能</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(line);<br>        &#125;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>MIT 6.092: Introduction To Programming In Java<br>完结撒花🎇🎆</p>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
      <tag>Exceptions</tag>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure9</title>
    <link href="/2025/02/22/Data-Structure9/"/>
    <url>/2025/02/22/Data-Structure9/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B-树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！"><a href="#Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B-树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！" class="headerlink" title="Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B+树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！"></a>Before：这一章，我们要进入一种新的数据结构类型——树🌲🌳🌴🎄。lz早就听闻各种神奇的树（二叉树、平衡树、红黑树、线段树、B树、B+树…）😇😭😥，今天中午和学长吃饭得知他红黑树调了1个月找不出bug只好重构的事迹，已经开始害怕了😰咱们还是快开始吧！</h5><h1 id="Data-Structure-9-树"><a href="#Data-Structure-9-树" class="headerlink" title="Data Structure 9 树"></a>Data Structure 9 树</h1><p>为了满足一下某人的好奇心，决定先贴一张树的归纳总结的图，作为开端（自己宠自己）<br><img src="/img/%E6%A0%91%E5%A4%A7%E5%85%A8.png" alt="树的总结"></p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>首先，回顾一下树状结构的特点：只有一个直接前驱（除根结点外），但可以有多个直接后继。</p><p>树的递归定义：有n个结点的有限集合，或者是空集。拥有1个根结点，其余结点可分成m个互不相交的集合，这些集合本质上也是树，称作根节点的子树。<br>下面是树的一些基本术语：</p><ul><li>根节点  叶节点（没有直接后继的结点） 内部结点（除根叶结点外）</li><li>结点的度（一个结点的直接后继数目）  树的度（所有结点的度的最大值）</li><li>子结点（结点的直接后继结点） 父结点（结点的直接前驱） 祖先节点（每个结点通向根结点的唯一路径上的所有结点） 子孙结点（该结点所有子树中的全部结点）</li><li>兄弟结点（同一个结点的子结点互为兄弟结点）</li><li>结点层次（相当于家谱中的第几代） 树的高度（结点的最大层次） 结点高度（以该结点为根的子树高度）</li><li>有序树（把树中每个结点的子树看成自左向右有序的）</li><li>森林（M棵互不相交的树的集合）</li></ul><h2 id="树的基本运算"><a href="#树的基本运算" class="headerlink" title="树的基本运算"></a>树的基本运算</h2><p>（1）create() 创建空树<br>（2）clear() 清除树中所有结点<br>（3）isEmpty() 判别空树<br>（4）root() 找到根结点的值<br>（5）parent(x) 找到结点x的父结点值<br>（6）child(x,i) 找结点x的第i个子结点值<br>（7）remove(x,i) 删除结点i的第i棵子树<br>（8）traverse() 访问树上每一个结点<br>还是老样子，给出树的抽象类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tree</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//flag是结点不存在时的返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">child</span><span class="hljs-params">(T x,<span class="hljs-type">int</span> i,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T x,<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树-binary-tree"><a href="#二叉树-binary-tree" class="headerlink" title="二叉树 binary tree"></a>二叉树 binary tree</h2><p>放在第一个，那自然是因为它《简单且应用广泛》</p><p>二叉树是结点的有限集合，它或者为空，或者由一个根结点及两棵互不相交的左右子树构成，而其左、右子树又都是二叉树。<strong>注意：二叉树是有序树，必须严格区分左右子树。</strong>即使只有一棵子树，也要说明它是左子树还是右子树。</p><p>二叉树有5种基本形态：<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BD%A2%E6%80%81.png" alt="二叉树的5种基本形态"></p><p>满二叉树：一棵二叉树中任意一层结点数量都达到了最大值<br>完全二叉树：在满二叉树的最底层自右向左依次去掉若干个结点（不能跳过任何一个结点）。即满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。</p><p>下面是二叉树的一些常用性质：<br>1.一棵二叉树第i层最多有2^(i - 1)个结点<br>2.一棵高度为k的二叉树上，最多有2^k - 1 个结点<br>3.对于一棵非空二叉树，如果叶子结点数为n_0，度为2的结点数为n_2，则有n_0 &#x3D; n_2 + 1<br>证明：设二叉树中度数为1的结点数量为n_1，结点总数为n，那么自然有：<br>n &#x3D; n_0 + n_1 + n_2<br>再看树枝数量B，二叉树中每个结点（除根结点外）都有一根指向他们的树枝，所以有：<br>B &#x3D; n - 1<br>这些树枝都是由度为1、2的结点发出的，所以<br>n_1 + 2 * n_2 &#x3D; n - 1<br>所以<br>n_0 &#x3D; n_2 + 1<br>4.具有n个结点的完全二叉树高度为[log_2 n] + 1<br>5.如果对一棵有n个结点的完全二叉树中的结点按层自上而下，每一层按自左至右依次编号，若设根结点的编号为1，则对任一编号为i的结点，有：<br>（1）若i &#x3D; 1，则为根结点；若i&gt;1，则父结点编号为[i&#x2F;2]<br>（2）如果2i&gt;n，则编号为i的结点为叶子结点，没有儿子；否则，其左儿子的编号为2i<br>（3）如果2i + 1&gt;n，则编号为i的结点无右儿子；否则，其右儿子的编号为2i + 1</p><h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><p>（1）create() 创建空二叉树<br>（2）clear() 清除二叉树中所有结点<br>（3）isEmpty() 判别空二叉树<br>（4）root() 找到二叉树根结点的值<br>（5）parent(x) 找到结点x的父结点值<br>（6）lchild(x) 找结点x的左结点值<br>（7）rchild(x) 找结点x的右结点值<br>（8）deLeft(x) 删除结点x的左子树<br>（9）deRight(x) 删除结点x的右子树<br>（10）traverse() 访问二叉树上每一个结点<br>对于最后一个操作——traverse()，我们有以下几种方式实现遍历：</p><ul><li>前序遍历（先根遍历）：先访问根结点，然后前序遍历左子树，然后前序遍历右子树</li><li>中序遍历（中根遍历）：先中序遍历左子树，然后访问根结点，然后中序遍历右子树<br><img src="/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="二叉树中序遍历"></li><li>后序遍历（后根遍历）：先后序遍历左子树，然后后序遍历右子树，最后访问根结点</li><li>层次遍历：在访问了第k层的所有结点后，再按从左到右的次序访问第k+1层</li></ul><p>前序遍历+中序遍历可以确定一棵二叉树（通过前序遍历找到根结点，然后得到左子树右子树，下面就是递归了），同理，后序遍历+中序遍历也可以确定一棵二叉树，但前序遍历+后序遍历无法确定一棵二叉树（易举反例）</p><p>下面是二叉树的抽象类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bTree</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">Root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= O;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">lchild</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">rchild</span><span class="hljs-params">(T x,T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">preOreder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的顺序实现"><a href="#二叉树的顺序实现" class="headerlink" title="二叉树的顺序实现"></a>二叉树的顺序实现</h2><p>与线性结构一样，所谓的顺序存储就是将数据元素存放在一个<strong>数组</strong>中<br>若是完全二叉树，那显然用数组实现将会非常简单，结点的存储位置可以直接反应出结点的存储关系。</p><p>但如果需要存储的二叉树不是完全二叉树，情况就会比较不同。父子间数量关系（性质5）并不成立。可能的解决方案是在残缺位置上添加“虚结点”使之变成一棵完全二叉树。<br>如下图所示：<br><img src="/img/%E8%99%9A%E7%BB%93%E7%82%B9%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="虚结点二叉树"></p><h2 id="二叉树的链接实现"><a href="#二叉树的链接实现" class="headerlink" title="二叉树的链接实现"></a>二叉树的链接实现</h2><h3 id="标准存储方式——二叉链表"><a href="#标准存储方式——二叉链表" class="headerlink" title="标准存储方式——二叉链表"></a>标准存储方式——二叉链表</h3><p>在二叉链表中，每个存储结点由3个字段组成，存储数据元素值的数据字段以及指向左、右儿子的指针字段。如下所示：<br>| left | data | right | </p><p>下面是二叉链表存储示例：</p><p><img src="/img/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8.png" alt="二叉链表存储"></p><h3 id="广义标准存储方式——三叉链表"><a href="#广义标准存储方式——三叉链表" class="headerlink" title="广义标准存储方式——三叉链表"></a>广义标准存储方式——三叉链表</h3><p>在标准存储结构的基础上，再增加一个指向其父亲结点的指针，这就是广义标准存储方式<br>| data | left | parent | right |</p><p>下面是三叉链表存储示例：</p><p><img src="/img/%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8.png" alt="三叉链表存储"></p><h3 id="Conclude"><a href="#Conclude" class="headerlink" title="Conclude"></a>Conclude</h3><p>由于二叉链表的简洁，且查找父亲的操作较为少见，所以我们更为常用的还是<strong>二叉链表</strong></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.pdai.tech/md/algorithm/alg-basic-tree.html">https://www.pdai.tech/md/algorithm/alg-basic-tree.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic1</title>
    <link href="/2025/02/21/Mathematical-Logic1/"/>
    <url>/2025/02/21/Mathematical-Logic1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-数理逻辑CS2950是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是Yin-Qiang，Yijia-Chen的学生。后续会更新这门“抽象”的课的Lecture-Notes❤️">Before: 数理逻辑<a href="https://wiki.pdy.app:8443/s/96e05898-1739-424b-8a49-85de7c83ebec">CS2950</a>是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是<a href="https://cs.sjtu.edu.cn/~qyin/">Yin Qiang</a>，<a href="https://basics.sjtu.edu.cn/~chen/">Yijia Chen</a>的学生。后续会更新这门“抽象”的课的Lecture Notes❤️</h5><h1>Methematical Logic 1 Introduction &amp; The Syntax of First-order Logic</h1><h2 id="Course-Introduction">Course Introduction</h2><p>Four Problems mainly</p><ul class="lvl-0"><li class="lvl-2">What is a mathematical proof</li><li class="lvl-2">What makes a proof correct</li><li class="lvl-2">Is there a boundary of provability</li><li class="lvl-2">Can computers find proofs</li></ul><h3 id="Q1-What-is-a-mathematical-proof">Q1.What is a mathematical proof</h3><p>Based on first-order logic</p><h3 id="Q2-What-makes-a-proof-correct">Q2.What makes a proof correct</h3><p>Gödel Completeness Theorem</p><h3 id="Q3-Is-there-a-boundary-of-provability"><a href="http://Q3.Is">Q3.Is</a> there a boundary of provability</h3><p>Gödel’s First Incompleteness Theorem</p><h3 id="Q4-Can-computers-find-proofs">Q4.Can computers find proofs</h3><p>Any computer program cannot decide whether an arbitrary input mathematical statement has a proof.<br>Turing’s undecidability of the halting problem.(图灵停机问题不可判定)</p><p>Below is A Proof of Q4:<br>φP,x has a proof | P will eventually halt on input x<br>1.construct the mathematical statement φx,x<br>2.call the program T on input φx,x<br>3.if T(φx,x) = yes then run forever else halt</p><p>Then we can get that H(H) haltss iff H(H) does not halt.(Using what we know up)</p><h2 id="The-Syntax-of-First-order-Logic-一阶逻辑语法">The Syntax of First-order Logic 一阶逻辑语法</h2><h3 id="Alphabets-字母表">Alphabets 字母表</h3><p>an nonempty set of symbols 非空符号的集合</p><h3 id="Word-词">Word 词</h3><p>A word w over A(an Alphabet) is a finite sequence of symbols in A,i.e,<br>$$<br>w = w_1w_2…w_n<br>$$<br>$<br>w_i \in A<br>$<br>$A^*$ denotes the set of all words over A</p><h3 id="Countable-Set">Countable Set</h3><p>There exists an injective function(单射) α from N onto M<br>At most countable: if M is either finite or countable</p><p>Two lemmas<br>1.These three equivalent:<br>(1)M is at most countable<br>(2)an surjective function f:N -&gt; M<br>(3)an injective function f:M -&gt; N<br>2.A is most countable,then $A^*$ is countable.</p><h3 id="Terms-项">Terms 项</h3><p>Variable Constant are both S-terms.<br>And if f is a n-ary function symbol in S,then f(S-terms) is also a S-term.</p><h3 id="Formula-公式">Formula 公式</h3><p>The set $L^S$ of S-formulas contains precisely those words in $A^∗_S$ which can be obtained by applying the following rules finitely many times.<br><img src="/img/Formula.png" alt="Formula Rules"></p><h3 id="Variables-变量">Variables 变量</h3><p>Let t be a S-term, then var(t) is the set of variables in t.</p><h3 id="Free-Variables-自由变元">Free Variables 自由变元</h3><p>We say that an occurrence of x in φ is free if it is not in the scope of any ∀x or ∃x.<br>只有出现在约束范围内的变量才算是约束出现的</p><h3 id="Sentence-句子">Sentence 句子</h3><p>If free(φ) is ∅,then it’s a sentence. 没有自由变元<br>Reflect Mathematical characteristics.<br>$L_N^S$:= {φ | φ an S-formula with free(φ) ⊆ {v0, . . . , vn−1}}.</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure8</title>
    <link href="/2025/02/20/Data-Structure8/"/>
    <url>/2025/02/20/Data-Structure8/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：字符串是琴弦，想弹琴了🎸🎹🪕"><a href="#Before：字符串是琴弦，想弹琴了🎸🎹🪕" class="headerlink" title="Before：字符串是琴弦，想弹琴了🎸🎹🪕"></a>Before：字符串是琴弦，想弹琴了🎸🎹🪕</h5><h1 id="Data-Structure-8-字符串"><a href="#Data-Structure-8-字符串" class="headerlink" title="Data Structure 8 字符串"></a>Data Structure 8 字符串</h1><h2 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h2><p>字符串是由若干个字符按照一定顺序组合而成，如果把单个字符看作一个元素，则可把字符串看成是一个字符类型的线性表。但区别在于，线性表中的个体大多相互独立，强调的是对表中某个元素的操作，而字符串更强调的是整体的操作，是对多个字符串的同时操作。关于字符串的基本操作有以下几种：<br>1.求字符串中元素个数length(s)<br>2.字符串输出disp(s)<br>3.判断两个字符串相等equal(s1,s2)、大于greater(s1,s2)大于等greaterEqual(s1, s2)、小于less(s1,s2)小于等于lessEqual(s1,s2)，按字母序判断两个字符串的大小，返回true或者false<br>4.字符串赋值copy(s1,s2)，将字符串s2赋值给另一个字符串s1。如t的值“SHANGHAI”,s的值是“UNIVERSITY”，执行copy(t,s)后，t的值变为“UNIVERSITY”。<br>5.字符串连接cat(s1,s2)，将字符串s2中的字符序列连接到字符串s1的字符序列之后。<br>6.取子串substr(s,start,len)，在字符串 s 中从start开始取长度为len的子串。<br>7.字符串插入insert(s1, start, s2)<br>8.删除子串remove(s, start, len)<br>9.查找子串search(s1,s2)</p><h2 id="字符串的顺序实现"><a href="#字符串的顺序实现" class="headerlink" title="字符串的顺序实现"></a>字符串的顺序实现</h2><p>字符串本质上是一个线性表，因而可以采用顺序存储。我们要做的是创建一个字符类型的数组。我们常说C风格字符串和C++字符串，那么C语言和C++在字符串这一数据结构的处理上有何区别呢？</p><p><img src="/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E6%AF%94.png" alt="C风格字符串与C++字符串对比"></p><p>而更为底层的区别在于，C语言的字符串是采用静态的顺序存储，使用一个以null(‘\0’)字符结尾的字符数组来保存字符串，而C++中则把字符串封装成了一种数据类型string，采用动态的顺序存储，并用运算符重载实现了赋值、连接、比较等操作，使字符串类型的变量能与整型、实型等内置类型的变量一样用运算符操作。</p><p>那么顺序串的存储实现采用一个动态的字符数组（一个动态数组自然需要一个指向数组首地址的指针和数组的大小两个量），但由于C++字符串必须以’\0’结尾，故不管该字符数组后面还有多少元素，一旦遇到’\0’，即终止，故字符串类的动态字符数组不需要记录数组的大小。</p><h2 id="字符串类的顺序实现"><a href="#字符串类的顺序实现" class="headerlink" title="字符串类的顺序实现"></a>字符串类的顺序实现</h2><p>在上代码前，让我们先明晰一下，字符串类的实现要点：</p><p>1.构造函数：接受一个字符串常量作为参数。构造函数会动态分配一个数组来存储这个字符串。<br>2.拷贝构造函数和析构函数：由于使用了动态内存分配，需要定义拷贝构造函数来正确处理对象的拷贝，以及析构函数来释放分配的内存。（<strong>回顾《程序设计思想与方法》</strong>，存在动态内存分配时，简单的浅拷贝（按位复制）会导致多个对象共享同一块内存。这可能导致析构时多次释放同一内存（double free），引发未定义行为。）<br>3.运算符的重载（字符串操作包含很多运算符运算）：输出、赋值、比较、输出。（<strong>回顾《程序设计思想与方法》</strong>，运算符重载通常定义为友元函数，出于对称性的考虑，即如果其中一个操作数不是类的对象，重载为成员函数可能会导致不对称性；也出于自然语法中输入输出运算符的左操作数通常是流对象，而不是自定义类的对象。）</p><p>下面给出字符串类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqString</span>&#123;<br>    <span class="hljs-keyword">friend</span> seqString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> seqString &amp;s1,<span class="hljs-type">const</span> seqString &amp;s2);<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ofstream &amp;os,<span class="hljs-type">const</span> seqString &amp;s);<br><br>    <span class="hljs-type">char</span> *data;<br>    <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> seqString &amp;other);<br>        ~<span class="hljs-built_in">seqString</span>();<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-comment">// 补充说明一下这里添加const的原因：</span><br>        <span class="hljs-comment">//  保证函数不会修改对象；允许在常量对象上调用</span><br>        seqString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> seqString&amp;other);<br>        <span class="hljs-function">seqString <span class="hljs-title">subStr</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">const</span> seqString &amp;s)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>** 有趣的是，这里字符串类居然没有使用类模板？！不会是因为elemType都是char吧🤣🤣🤣</p><p>接下来就是字符串类的具体实现了，话不多说，上代码！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">seqString::seqString(<span class="hljs-keyword">const</span> char*s)&#123;<br>    int i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    len = i;<br>    <span class="hljs-keyword">data</span> = new char[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt;= len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = s[i];<br>    &#125;<br>&#125;<br><br>seqString::seqString(<span class="hljs-keyword">const</span> seqString &amp;other)&#123;<br>    <span class="hljs-keyword">data</span> = new char[other.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt;= other.len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = other.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    len = other.len;<br>&#125;<br><br>seqString::~seqString()&#123;<br>    delete []<span class="hljs-keyword">data</span>;<br>&#125;<br><br>int seqString::length() <span class="hljs-keyword">const</span>&#123;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br>seqString &amp;seqString::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> seqString&amp;other)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    delete []<span class="hljs-keyword">data</span>;<br>    len = other.len;<br>    <span class="hljs-keyword">data</span> = new char[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt;= len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = other.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>seqString seqString::substr(int start,int num)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    seqString s;<br>    <span class="hljs-keyword">if</span>(start + num &gt; len)&#123;<br>        s.len = len - start;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        s.len = num;<br>    &#125;<br>    delete []s.<span class="hljs-keyword">data</span>;<br>    s.<span class="hljs-keyword">data</span> = new char[s.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; s.len;i ++)&#123;<br>        s.<span class="hljs-keyword">data</span>[i] = <span class="hljs-keyword">data</span>[start + i];<br>    &#125;<br>    s.<span class="hljs-keyword">data</span>[s.len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br>void seqString::insert(int start,<span class="hljs-keyword">const</span> seqString &amp;s)&#123;<br>    char *tmp = <span class="hljs-keyword">data</span>;<br>    <span class="hljs-keyword">if</span>(start &gt; len || start &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    len += s.len;<br>    <span class="hljs-keyword">data</span> = new char[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; start; i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = tmp[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = start; i &lt; start + s.len;i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = s.<span class="hljs-keyword">data</span>[i - start];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = start + s.len; i &lt;= len; i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i] = tmp[i - s.len];<br>    &#125;<br>    <br>    delete tmp;<br>&#125;<br><br>void seqString::remove(int start,int num)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(start + num &gt;= len)&#123;<br>        <span class="hljs-keyword">data</span>[start] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        len = start;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = start + num; i &lt; len; i ++)&#123;<br>        <span class="hljs-keyword">data</span>[i - num] =<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    len -= num;<br>    <span class="hljs-keyword">data</span>[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>seqString <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    seqString tmp;<br>    tmp.len = s1.len + s2.len;<br>    delete []tmp.<span class="hljs-keyword">data</span>;<br>    tmp.<span class="hljs-keyword">data</span> = new char[tmp.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; s1.len; i ++)&#123;<br>        tmp.<span class="hljs-keyword">data</span>[i] = s1.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; s2.len; i ++)&#123;<br>        tmp.<span class="hljs-keyword">data</span>[s1.len + i] = s2.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    tmp.<span class="hljs-keyword">data</span>[tmp.len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1.len != s2.len)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt;= s1.len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-keyword">data</span>[i] != s2.<span class="hljs-keyword">data</span>[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 == s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; s1.len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-keyword">data</span>[i] &gt; s2.<span class="hljs-keyword">data</span>[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-keyword">data</span>[i] &lt; s2.<span class="hljs-keyword">data</span>[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 &gt; s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s1 == s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 &gt;= s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>bool <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> seqString &amp;s1,<span class="hljs-keyword">const</span> seqString &amp;s2)&#123;<br>    <span class="hljs-keyword">if</span>(s1 &gt; s2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ofstream &amp;os,<span class="hljs-keyword">const</span> seqString &amp;s)&#123;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; s.len; i ++)&#123;<br>        os &lt;&lt; s.<span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串类的链接实现"><a href="#字符串类的链接实现" class="headerlink" title="字符串类的链接实现"></a>字符串类的链接实现</h2><p>正常的链表理应当在一个结点中存储一个字符，这种存储方式使insert和remove操作容易实现，但太浪费空间。在每个结点中，数据只占一个字节，而指针却要占多个字节。为了提高空间利用率，可使每个结点存放多个字符，称为<strong>块状链表</strong>😅😅😅😅😅流汗黄豆贴满了，应该能看出JaneZ对块状链表的无语了吧，一个差点要了我命的数据结构，《重生之JaneZ要斩了块状链表》，即将上演。</p><p>下图是一张块状链表的示意图：</p><p><img src="/img/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="块状链表存储字符串"><br>块状链表提高了空间的利用率，但插入和删除时会引起数据的大量移动.例如在上图中的字符串中删除”C”，所有结点的数据都要发生变化。数据插入也是如此。为了提高插入和删除的效率，块状链表通常允许结点有一定的空闲空间。</p><p>如在上图的字符串中删除”C”只需在第一个结点中删除”C”，其他结点保持不变。如要删除”EFGI”只需删除第2个结点，并在原第3个结点中删除”I”。当需要在”F”后插入字符串”UVXYZ”时，先形成两个新的结点”UVX”和”YZ”，然后将结点”EFG”分裂成两个结点”EF”和”G”，将两个新结点插入它们之间。为了保证块状链表不退化成单个字符的链表，检查新插入的最后一个结点和后面一个结点能否合并成一个结点。</p><p><img src="/img/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8%E8%BF%87%E7%A8%8B.png" alt="块状链表执行insert操作具体过程"></p><p>一些实现要点：链接串类的存储采用带头结点的块状链表。由于采用链接存储，在链接串类中定义了一个私有的内嵌类node，即链表中的结点类。每个结点由3部分组成：结点中的有效字符数、保存字符串的字符数组以及一个指向后继结点的指针。链接串类有 3 个数据成员：指向头结点的指针、字符串的长度以及每个结点的容量。</p><p>下面给出代码实现：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkString</span>&#123;<br>    <span class="hljs-keyword">friend</span> linkString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> linkString &amp;s1,<span class="hljs-type">const</span> linkString &amp;s2);<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ofstream &amp;os,<span class="hljs-type">const</span> linkString &amp;s);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">int</span> size;<br>        Node *next;<br>        <span class="hljs-type">char</span> *data;<br><br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>,Node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>            data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s];<br>            next = n;<br>            size = s;<br>        &#125;<br>    &#125;;<br><br>    Node *head;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span> nodeSize;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//释放块状链表的存储空间</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPos</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> &amp;pos,Node *&amp;p)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">//找到第start个字符所在的结点地址p以及在结点中的位置pos </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(Node *p,<span class="hljs-type">int</span> pos)</span></span>;<br>    <span class="hljs-comment">//split函数将指针p指向的结点以位置pos为界分裂成两个结点。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(Node *p)</span></span>;<br>    <span class="hljs-comment">//merge函数检查p指向的结点是否能与它的直接后继合并成一个结点。 </span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> linkString &amp;other);<br>        ~<span class="hljs-built_in">linkString</span>();<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        linkString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> linkString&amp;other);<br>        <span class="hljs-function">linkString <span class="hljs-title">subStr</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">const</span> linkString &amp;s)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> num)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关于块状链表的性能，研究表明（事实上好像未必），块状链表的结点容最与结点个数相同时算法的效率是最高的。所以将结点数量设为 $\sqrt{len}$ </p><p>具体实现：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs xl">linkString::linkString(const char *s = <span class="hljs-string">&quot;&quot;</span>)&#123;<br>    Node *p;<br><br>    int i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&quot;\0&quot;</span>)&#123;<br>            break;<br>        &#125;<br>    &#125;<br>    len = i;<br>    nodeSize = <span class="hljs-built_in">sqrt</span>(len);<br><br>    <span class="hljs-keyword">while</span>(*s)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(<span class="hljs-number">1</span>);<br>        <span class="hljs-function"><span class="hljs-title">for</span>( ; p -&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> &lt; nodeSize &amp;&amp; *s; p -&gt;</span> size ++,s ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span>size] = *s;<br>        &#125;<br>    &#125;<br>&#125;<br><br>linkString::linkString(const linkString &amp;other)&#123;<br>    Node *p = head = new Node(<span class="hljs-number">1</span>);<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *otherp = other.head -&gt;</span> next;<br>    <span class="hljs-keyword">while</span>(otherp)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(<span class="hljs-number">1</span>);<br>        <span class="hljs-function"><span class="hljs-title">for</span>(;p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> &lt; other.nodeSize &amp;&amp; otherp -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>];p -&gt;</span> size ++, otherp ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>] = otherp -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">otherp</span> = otherp -&gt;</span> next;<br>    &#125;<br>    len = other.len;<br>    nodeSize = other.nodeSize;<br>&#125;<br><br>void clear()&#123;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *p = head -&gt;</span> next;<br>    Node *tmp;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        tmp = p;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>        delete tmp;<br>    &#125;<br>&#125;<br><br>~linkString()&#123;<br>    clear();<br>    delete head;<br>&#125;<br><br>int linkString::length() const&#123;<br>    return len;<br>&#125;<br><br>linkString &amp;linkString::operator=(const linkString&amp;other)&#123;<br>    <span class="hljs-keyword">if</span>(other == this)&#123;<br>        return *this;<br>    &#125;<br><br>    clear();<br>    Node *p = head;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *otherp = other.head -&gt;</span> next;<br>    <span class="hljs-keyword">while</span>(otherp)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(<span class="hljs-number">1</span>);<br>        <span class="hljs-function"><span class="hljs-title">for</span>(;p-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> &lt; other.nodeSize &amp;&amp; otherp-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>];p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> ++, otherp-&gt;</span><span class="hljs-keyword">data</span> ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>] = otherp-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[p-&gt;</span>size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">otherp</span> = otherp -&gt;</span> next;<br>    &#125;<br>    len = other.len;<br>    nodeSize = other.nodeSize;<br>    return *this;<br>&#125;<br><br>void linkString::findPos(int start,int &amp;pos,Node *&amp;p) const&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        return;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">p</span> = head -&gt;</span> next;<br>    int count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(start - count &gt; p.size)&#123;<br>            count += p.size;<br>            <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pos = start - count;<br>            return;<br>        &#125;<br>    &#125;<br>&#125;<br><br>linkString linkString::subStr(int start,int num)&#123;<br>    linkString tmp;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        return tmp;<br>    &#125;<br>    Node *p;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *tmpp = tmp -&gt;</span> head;<br>    int pos;<br><br>    <span class="hljs-keyword">if</span>(start + num &gt; len)&#123;<br>        num = len - start ;<br>    &#125;<br>    findPos(start,pos,p);<br>    tmp.len = num;<br>    tmp.nodeSize = <span class="hljs-built_in">sqrt</span>(num);<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; num;)&#123;<br>        <span class="hljs-function"><span class="hljs-title">tmpp</span> = tmpp -&gt;</span> next = new Node(nodeSize);<br><br>        <span class="hljs-function"><span class="hljs-title">for</span>(;tmpp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> &lt; tmp.nodeSize &amp;&amp; i &lt; tmp.len;i ++,tmpp-&gt;</span>size ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(pos == p -&gt;</span> size)&#123;<br>                <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>                pos = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">tmpp</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[tmpp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>] = p -&gt;</span> <span class="hljs-keyword">data</span>[pos ++];<br>        &#125;<br>    &#125;<br><br>    return tmp;<br>&#125;<br><br>void linkString::split(Node *p,int pos)&#123;<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = new node(nodeSize,p -&gt;</span> next);<br><br>    <span class="hljs-function"><span class="hljs-title">for</span>(int i = pos; i &lt; p -&gt;</span> size; i ++)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[i - pos] = p -&gt;</span> next[i];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> = p -&gt;</span> size - pos ;<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> size = pos;<br>&#125;<br><br>void linkString::merge(Node *p)&#123;<br>    NO<span class="hljs-function"><span class="hljs-title">de</span> *tmp = p -&gt;</span> next;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(tmp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + p -&gt;</span> size &lt;= nodeSize)&#123;<br>        <span class="hljs-function"><span class="hljs-title">for</span>(int i = p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>; i &lt; tmp-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> + p -&gt;</span> size; i ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[i] = tmp -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[i - p -&gt;</span> size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> = tmp -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + p -&gt;</span> size;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = tmp -&gt;</span> next;<br>        delete tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐下面是比较重要的insert和remove的实现：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xl">void linkString::insert(int start,const linkString &amp;s)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span>||start &gt;= len)&#123;<br>        return;<br>    &#125;<br><br>    Node *p;<br>    Node *tmp;<br>    N<span class="hljs-function"><span class="hljs-title">ode</span> *stmp = s.head -&gt;</span> next;<br>    int pos;<br><br>    findpos(start,pos,p);<br>    split(p,pos);<br>    <span class="hljs-function"><span class="hljs-title">tmp</span> = p -&gt;</span> next;<br><br>    <span class="hljs-keyword">while</span>(stmp)&#123;<br>        <span class="hljs-function"><span class="hljs-title">for</span>(pos = 0;pos &lt; stmp -&gt;</span> size;pos ++)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(pos == p -&gt;</span> size)&#123;<br>                <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next = new Node(nodeSize);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">data</span>[p -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span>] = stmp -&gt;</span> <span class="hljs-keyword">data</span>[pos];<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> size ++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">stmp</span> = stmp -&gt;</span> next;<br>    &#125;<br><br>    len += s.len;<br>    merge(p);<br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> next = tmp;<br>&#125;<br><br>void linkString::remove(int start,int num)&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span>||start &gt;= len)&#123;<br>        return;<br>    &#125;<br>    Node *p;<br>    int pos;<br>    findPos(start,pos,p);<br>    split(p,pos);<br><br>    <span class="hljs-keyword">if</span>(start + num &gt; len)&#123;<br>        num = len - start;<br>        len = start;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        len -= num;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        N<span class="hljs-function"><span class="hljs-title">ode</span> *tmp = p -&gt;</span> next;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(num - tmp-&gt;</span>size &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-function"><span class="hljs-title">num</span> -= tmp -&gt;</span> size;<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = tmp -&gt;</span> next;<br>            delete tmp;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            split(tmp,num);<br>            <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = tmp -&gt;</span> next;<br>            delete tmp;<br>            break;<br>        &#125;<br>    &#125;<br>    merge(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>重载运算符部分与顺序实现类似，较容易，就不写了（bushi）。又一遍块状链表真是把人快搞死了😅，真难写啊呜呜呜…字符串相关算法（kmp，字符串哈希等）上学期上机课有过介绍，就不会再出现了（偷懒😋）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CSDN:<a href="https://blog.csdn.net/yf210yf/article/details/8777131">https://blog.csdn.net/yf210yf/article/details/8777131</a><br>CSDN:<a href="https://blog.csdn.net/tuolaji8/article/details/51362698">https://blog.csdn.net/tuolaji8/article/details/51362698</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构2</title>
    <link href="/2025/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"/>
    <url>/2025/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构2-线性表"><a href="#数据结构2-线性表" class="headerlink" title="数据结构2 线性表"></a>数据结构2 线性表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表的抽象类中，少了构造函数（对应create函数），多了析构函数。我们将create函数交给了具体类的构造函数。那为什么要加析构函数呢？这里的虚析构函数是为了防止派生类中出现内存泄漏。计算机看到抽象类的析构函数时，才回去找到派生类中的析构函数，防止派生类出现内存泄漏。<br><code>virtual ~list()&#123;&#125;;</code></p><h3 id="什么是顺序实现？"><a href="#什么是顺序实现？" class="headerlink" title="什么是顺序实现？"></a>什么是顺序实现？</h3><p>线性表中结点存放在存储器上一块连续的空间中，即一个<strong>数组</strong>。且这个数组一定是动态数组。借助存储空间的连续性，结点可以按照其逻辑顺序依次存放。顺序表类的定义同样不太常见，是一个类模板的继承。在实现时，我们需要注意顺序存储的容量问题，有2种解决方法，要么不执行操作（这不好吧），要么让用户觉得这是一个无限的空间，即程序员需要增设一个扩大空间的函数。<br>但顺序表同样存在一个问题，当执行insert操作时，最坏时间复杂度达到了O(N)，remove操作也同样如此，所以当执行插入删除操作次数较少时，适合用顺序实现（静态的）</p><h3 id="什么是链接实现"><a href="#什么是链接实现" class="headerlink" title="什么是链接实现"></a>什么是链接实现</h3><p>每个结点存放在独立的存储空间中，结点间的逻辑关系依靠存储单元中附加的指针给出。通常用链表实现，具体有单链表、双链表和循环链表</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>注意：struct默认成员是public，而class默认成员是private</p><p>所以，在整个单链表类中，我们将Node类定为private，但Node类内部成员均为public，这是因为我们需要在Node结构体外调用各种数据成员，但是从外部来看，class外的成员无需知晓内部实现，更无需调用Node结构体中成员变量。</p><p>执行insert操作时，可以调用一个<strong>私有的</strong>move函数，返回指向相应结点的指针。同样在remove操作时，也是调用move函数定位。</p><h2 id="双链表-循环链表"><a href="#双链表-循环链表" class="headerlink" title="双链表 循环链表"></a>双链表 循环链表</h2><p>对于：有经常要找前驱的操作</p><p>循环链表又分为单循环链表、双循环链表，单循环链表很适合解决约瑟夫环问题</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL（标准模板库）：C++中数据结构的实现，这些数据结构称为集合或容器</p><ul><li>vector: 线性表的顺序实现<br>特有操作：[]的重载，按下标访问元素</li><li>list: 线性表的双链表实现<br>特有操作：表头的插入和删除</li></ul><h2 id="迭代器操作"><a href="#迭代器操作" class="headerlink" title="迭代器操作"></a>迭代器操作</h2><p>迭代器：指向容器中元素的抽象指针<br>迭代器都被定义为对应容器的公有内嵌类，所有迭代器都有相同的名字</p><ul><li>const_iterator</li><li>iterator</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>FILO 先进后出结构<br>进栈运算在最坏情况下的时间复杂度是O(N)，这很不公平，因为很少发生doubleSpace()的情况。为了更加合理，我们提出均摊分析法，把多出的次数分摊到先前进栈、出栈操作中每个插入只多了一个复制操作，因此从平均的意义上讲，插入运算的时间复杂度还是常批的。</p><p>STL中的栈是一个容器适配器，借助vector、list、deque</p><h2 id="栈的应用（QUITE-IMPORTANT-FOR-THE-COMPILER）"><a href="#栈的应用（QUITE-IMPORTANT-FOR-THE-COMPILER）" class="headerlink" title="栈的应用（QUITE IMPORTANT FOR THE COMPILER）"></a>栈的应用（QUITE IMPORTANT FOR THE COMPILER）</h2><h3 id="递归函数的非递归实现"><a href="#递归函数的非递归实现" class="headerlink" title="递归函数的非递归实现"></a>递归函数的非递归实现</h3><p>递归函数中，每次递归调用都要花费系统时间和空间。于是我们的想法是：把递归函数变成非递归函数。</p><p>首先，我们需要知道计算机是如何进行函数调用的————栈！！！<br>栈中保存的是调用结束后回到的地址，如果递归函数调用层次过深，可能会导致Stack Over Flow(爆栈)。</p><p>为了变成一个非递归函数，我们可以考虑<strong>自己维护一个栈</strong>。<br>举个例子：快速排序<br>递归实现：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">quickSort</span>(a,low,mid-<span class="hljs-number">1</span>);<br><span class="hljs-built_in">quickSort</span>(a,mid+<span class="hljs-number">1</span>,high);<br></code></pre></td></tr></table></figure><p>非递归实现：设置一个栈，记录要做的工作（即要排序的数据段）</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">struct Node &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先将整个数组进栈，弹出一个区间，将区间分成两半，若区间长度大于2，则进栈</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> quickSort(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> size)&#123;<br>    seqStack&lt;Node&gt; st;<br>    <span class="hljs-type">int</span> mid,<span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>;<br>    Node s;<br><br>    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    s.left = <span class="hljs-number">0</span>;<br>    s.right = size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>        s = st.pop();<br>        start = s.left;<br>        end = s.right;<br>        mid = divide(a,<span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>);<br><br>        <span class="hljs-keyword">if</span>(mid - <span class="hljs-keyword">start</span> &gt; <span class="hljs-number">1</span>)&#123;<br>            s.left = <span class="hljs-keyword">start</span>;<br>            s.right = mid <span class="hljs-number">-1</span>;<br>            st.push(s);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">end</span> - mid &gt; <span class="hljs-number">1</span>)&#123;<br>            s.left = mid + <span class="hljs-number">1</span>;<br>            s.right = <span class="hljs-keyword">end</span>;<br>            st.push(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="符号平衡检查"><a href="#符号平衡检查" class="headerlink" title="符号平衡检查"></a>符号平衡检查</h3><ul><li>检查程序中括号是否匹配<br><strong>遇到右括号时，与最近遇到的、没有匹配的左括号匹配</strong><br>使用栈的思想：<br>遇到左括号，进栈，遇到右括号，将栈顶元素出栈并进行比较</li></ul><p>还有几个特殊情况：<br>当括号出现在注释、字符常量、字符串常量</p><ul><li>balance类实现<br>在balance类中，为什么用输入文件流对象ifstream而不是string类文件名？<br>读文件是通过文件流对象的，类中各种小函数可能都需要对文件进行读写，使用文件流对象会更加简洁。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">balance</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    ifstream fin;<br>    <span class="hljs-built_in">int</span> currentLines;<br>    <span class="hljs-built_in">int</span> errors;<br>    <span class="hljs-keyword">struct</span> Symbol&#123;<br>        <span class="hljs-built_in">char</span> Token;<br>        <span class="hljs-built_in">int</span> theLine;<br>    &#125;; <br>    <span class="hljs-built_in">enum</span> CommentType&#123;<br>        <span class="hljs-comment">//C++和C注释风格不一样</span><br>        SlashSlash;<br>        SlashStar;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    balance(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *s);<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">checkBalance</span>()</span>; <span class="hljs-comment">// 返回出错数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>balance类有2种执行方式：</p><ul><li>用户通过键盘输入文件名</li><li>将要检查的源文件名作为命令行参数<br>我们就可以利用main函数的参数<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h3><ul><li>中缀和后缀表达式<br>中缀表达式：运算符在2个运算数之间 a + b<br>中缀表达式的计算：运算符的优先级和结合性<br>后缀表达式：运算符在运算数后面 a b +<br>这就可以采用栈来存储最近的2个运算数了</li></ul><p>对于后缀表达式：</p><ul><li>初始化一个栈</li><li>依次读入后缀式的操作数和运算符直到结束<br>若读到的是操作数，则将其进栈<br>若读到的是运算符，则将栈顶的两个操作数出栈，后弹出的操作数为被操作数，先弹出的为操作数，将得到的操作数完成运算符所规定的运算，并将结果进栈</li><li>当栈中只剩有一个操作数时，弹出该操作数，它就是表达式的值</li></ul><p>程序员希望看到中缀表达式而不是后缀表达式<br>我们希望编译器将中缀表达式转化为后缀表达式<br><strong>遍历中缀表达式时，无法确定当前处理的运算符是否能够运算，但能确定它之前的运算符是否能运算</strong></p><ul><li>中缀转后缀算法<br>若读入的是<strong>操作数</strong>，立即输出<br>若读入的是<strong>闭括号</strong>，则将栈中的运算符依次出栈并输出，直到遇到相应的开括号，将开括号出栈<br>若读入的是<strong>开括号</strong>，则进栈<br>若读入的是<strong>运算符</strong>，如果栈顶运算符优先级<strong>高于或等于</strong>读入的运算符，则栈顶运算符出栈；直到栈顶运算符优先级低于读入的运算符为止，读入的运算符进栈<br>在读入操作结束时，将栈中所有的剩余运算符依次出栈并输出，直至栈空为止</li></ul><h3 id="简单计算器类实现"><a href="#简单计算器类实现" class="headerlink" title="简单计算器类实现"></a>简单计算器类实现</h3><p>使用方法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int main()&#123;<br>    calc.exp(<span class="hljs-string">&quot;3 * (7 + 5) / 6 - 2&quot;</span>)<span class="hljs-comment">;</span><br>    cout &lt;&lt; exp.result() &lt;&lt; endl<span class="hljs-comment">;</span><br>    <br>    exp <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3 * 7 + 5&quot;</span><span class="hljs-comment">;</span><br>    cout &lt;&lt; exp.result &lt;&lt; endl<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：增加乘法运算符，优先级最高！</strong><br>也就是说，只要出现乘方运算符，直接进栈，如果遇到其他运算符（当栈顶是乘方运算符时），乘方运算符直接出栈</p><p>关于calc类的设计，我们需要：</p><ul><li>一个字符串（保存表达式）</li><li>构造和析构函数</li><li>计算表达式结果</li><li>赋值运算符重载</li></ul><p>重点在于“计算表达式的结果”——result函数的实现</p><p>计算器中的表达式中的运算数都是常量，没有必要先转换成后缀表达式，在计算后缀表达式的值。可以将转换和计算两个步骤合并起来，边转换边计算<br><strong>在中缀转后缀时，发现某个运算符可以出栈时，则直接执行运算</strong><br>运算过程需要用到两个栈：中缀表达式转后缀表达式时的运算符栈，执行后缀表达式运算时的运算数栈 opStack dataStack</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>List</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure7</title>
    <link href="/2025/02/19/Data-Structure7/"/>
    <url>/2025/02/19/Data-Structure7/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：新学期第一篇DS！写于物理学实验绪论课上😋"><a href="#Before：新学期第一篇DS！写于物理学实验绪论课上😋" class="headerlink" title="Before：新学期第一篇DS！写于物理学实验绪论课上😋"></a>Before：新学期第一篇DS！写于物理学实验绪论课上😋</h5><h1 id="Data-Structure-7-队列"><a href="#Data-Structure-7-队列" class="headerlink" title="Data Structure 7 队列"></a>Data Structure 7 队列</h1><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><p>队列是一种特殊的<strong>线性表</strong>，插入限定在表的一端，删除限定在表的另一端；允许进行插入的一端成为<strong>队尾</strong>，允许进行删除的一端称为<strong>队头</strong>；位于队头的元素称为<strong>队头元素</strong>，位于队尾的元素称为<strong>队尾元素</strong>。因为这一性质，队列也被称为FIFO表（先进先出）。<br><img src="/img/%E9%98%9F%E5%88%97.png" alt="队列示意图"><br>队列的基本操作有如下5种：</p><ul><li>创建一个队列create()</li><li>入队enQueue(x)：将x插入队尾</li><li>出队deQueue()：删除队头元素</li><li>读队头元素getHead()</li><li>判空isEmpty()</li></ul><p>下面是队列的抽象类定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">queue</span>();<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="顺序队列的存储实现-用一维数组实现"><a href="#顺序队列的存储实现-用一维数组实现" class="headerlink" title="顺序队列的存储实现 用一维数组实现"></a>顺序队列的存储实现 用一维数组实现</h2><p>1.队头位置固定<br>如下图所示：<br><img src="/img/%E9%98%9F%E5%A4%B40.png" alt="队头固定在位置0"><br>入队、读取队头元素、判空操作的复杂度均为O(1)，而入队操作的复杂度为O(N)，其实现方式类似于vector类的实现，故在这里不做具体实现<br>2.队头位置不固定的顺序实现<br>一旦入队后，存储位置保持不变，而队头位置在变化，只需增加一个变量front，用于存储队头位置，这样一来所有操作的复杂度均为O(1)<br>如下图所示：<br><img src="/img/%E9%98%9F%E5%A4%B4%E4%B8%8D%E5%9B%BA%E5%AE%9A.png" alt="队头位置不固定"><br>但是这种做法的弊端在于空间很快会被用完，空间利用率低，于是我们有了：<br>3.循环队列 <strong>最常用方案</strong><br>我们可以将数列看作是首尾相连的，利用前面的空间，这样每次出队操作，有<code>front = (front + 1)%MaxSize;</code><br>如下图所示：<br><img src="/img/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="循环队列"><br>但是这会带来一个问题，就是队空和队满是，均有<code>front == rear</code>，两种情况无法区分。这时候我们可以联想在链表实现时我们构建的head结点，不存储元素。同样这种思想可以应用在这里，我们可以牺牲一个空间单元，规定front指向的单元不能存储元素，作为服务台，这样一来，队满的条件为：<br><code>(rear + 1)%MaxSize == front</code><br>队伍为空的条件为：<br><code>rear == front</code><br>下面给出循环队列的定义：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqQueue</span>: <span class="hljs-keyword">public</span> queue&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        elemType *elem;<br>        <span class="hljs-type">int</span> front,rear;<br>        <span class="hljs-type">int</span> MaxSize;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>);<br>        ~<span class="hljs-built_in">seqQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="循环队列的具体实现"><a href="#循环队列的具体实现" class="headerlink" title="循环队列的具体实现"></a>循环队列的具体实现</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">seqQueue</span>(<span class="hljs-title">int</span> <span class="hljs-title">size</span>)</span>&#123;<br>    elem = new elemType[size];<br>    MaxSize = size;<br>    front = <span class="hljs-number">0</span>;<br>    rear = <span class="hljs-number">0</span>;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::~<span class="hljs-title">seqQueue</span>()</span>&#123;<br>    <span class="hljs-keyword">delete</span> []elem;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">enQueue</span>(<span class="hljs-title">const</span> <span class="hljs-title">elemType</span>&amp; <span class="hljs-title">x</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>((rear + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span> == front)&#123;<br>        <span class="hljs-regexp">//</span> 队伍已满<br>        doubleSpace(); <span class="hljs-regexp">//</span>扩大空间<br>    &#125;<br>    rear = (rear + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span>;<br>    elem[rear] = <span class="hljs-keyword">x</span>;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">elemType</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">deQueue</span>()</span>&#123;<br>    <span class="hljs-keyword">if</span>(!isEmpty())&#123;<br>        front = (front + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span>;<br>        <span class="hljs-keyword">return</span> elem[front];<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">elemType</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">getHead</span>() <span class="hljs-title">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> elem[(front + <span class="hljs-number">1</span>)<span class="hljs-variable">%MaxSize</span>];<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">bool</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">isEmpty</span>() <span class="hljs-title">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> front == rear;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">seqQueue</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">doubleSpace</span>()</span>&#123;<br>    elemType *tmp = elem;<br>    elem = new elemType[<span class="hljs-number">2</span> * MaxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= MaxSize; i ++)&#123;<br>        elem[i] = tmp[(front + i)<span class="hljs-variable">%MaxSize</span>];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>    front = <span class="hljs-number">0</span>;<br>    rear = MaxSize;<br>    MaxSize *= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列的链接实现"><a href="#队列的链接实现" class="headerlink" title="队列的链接实现"></a>队列的链接实现</h2><p>和上一章节讨论的栈的链接实现类似，链接队列同样用单链表实现，将单链表的表头作为队头，表尾作为队尾（出于时间复杂度均控制在O(1)的考虑），下面是链接队列的示意图：<br><img src="/img/%E9%93%BE%E6%8E%A5%E9%98%9F%E5%88%97.png" alt="链接队列"><br>类似地，给出链接队列的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkQueue</span>: <span class="hljs-keyword">public</span> queue&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>            elem data;<br>            Node *next;<br>            <span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> elemType&amp; x,node *N = <span class="hljs-literal">nullptr</span>)&#123;<br>                data = x;<br>                next = N;<br>            &#125;<br>            <span class="hljs-built_in">Node</span>()&#123;<br>                next = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            ~<span class="hljs-built_in">Node</span>()&#123;&#125;<br>        &#125;;<br>        node *front;<br>        node *rear;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkQueue</span>();<br>        ~<span class="hljs-built_in">linkQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是具体的链接队列实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">linkQueue</span>()&#123;<br>    front = <span class="hljs-literal">null</span>ptr;<br>    rear = <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::~<span class="hljs-symbol">linkQueue</span>()&#123;<br>    Node *tmp;<br>    <span class="hljs-keyword">while</span>(front != <span class="hljs-literal">null</span>ptr)&#123;<br>        tmp = front;<br>        front = front -&gt; next;<br>        delete tmp;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">enQueue</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span>&amp; <span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(rear == <span class="hljs-literal">null</span>ptr)&#123;<br>        front = new node(x);<br>        rear =  front;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        rear -&gt; next =  new node(x);<br>        rear = rear -&gt; next;<br>    &#125;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">deQueue</span>()&#123;<br>    Node *p = front;<br>    front = front -&gt; next;<br>    <span class="hljs-keyword">if</span>(front == <span class="hljs-literal">null</span>ptr)&#123;<br>        rear = <span class="hljs-literal">null</span>ptr;<br>    &#125;<br>    elemType tmp = p -&gt; data;<br>    delete p;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">getHead</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> front -&gt; data; <br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">linkQueue</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> front == <span class="hljs-literal">null</span>ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL中的队列"><a href="#STL中的队列" class="headerlink" title="STL中的队列"></a>STL中的队列</h2><p>与栈类似，STL中的队列也是一个容器适配器，借助于list或deque实现。所以同栈一样，在使用stl::queue时，需要指明2个参数，第一个为队列元素类型，第二个为借助的底层容器，若不指明则默认为deque<br>这里是第二次出现deque这个容器了，那么就让我们来了解一下这个似乎我们不常听闻的底层容器吧😄<br>⭐deque是一个双向队列（double-ended queue），可以在队列的两端进行元素的插入和删除操作。deque是C++STL（标准模板库）中的一种容器，可以用于存储各种类型的元素。特点是可以在队列的两端进行元素的操作，并且可以高效地在队列的任意位置进行元素的插入和删除操作。<br>其成员函数有如下这些：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在队列的尾部插入元素。</span><br><span class="hljs-function"><span class="hljs-title">emplace_front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//与push_front()的作用一样 </span><br><span class="hljs-function"><span class="hljs-title">push_front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在队列的头部插入元素。</span><br><span class="hljs-function"><span class="hljs-title">emplace_back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//与push_back()的作用一样 </span><br><span class="hljs-function"><span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//删除队列尾部的元素。</span><br><span class="hljs-function"><span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//删除队列头部的元素。</span><br><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回队列尾部元素的引用。</span><br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回队列头部元素的引用。</span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><span class="hljs-comment">//清空队列中的所有元素。</span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><span class="hljs-comment">//判断队列是否为空。</span><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回队列中元素的个数。</span><br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回头位置的迭代器</span><br><span class="hljs-function"><span class="hljs-title">end</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回尾+1位置的迭代器</span><br><span class="hljs-function"><span class="hljs-title">rbegin</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回逆头位置的迭代器 </span><br><span class="hljs-function"><span class="hljs-title">rend</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回逆尾-1位置的迭代器 </span><br><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在指定位置插入元素 </span><br><span class="hljs-function"><span class="hljs-title">erase</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在指定位置删除元素 </span><br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CSDN：<a href="https://blog.csdn.net/H1727548/article/details/130959610">https://blog.csdn.net/H1727548/article/details/130959610</a></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>关于队列的应用，后续会结合上机课内容，在算法部分另开一章进行解释</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构1</title>
    <link href="/2025/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/"/>
    <url>/2025/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新"><a href="#Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新" class="headerlink" title="Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新"></a>Before：此中文版的数据结构用于整理翁阿姨课上的笔记，以周为单位更新</h5><h2 id="数据结构-1-引言"><a href="#数据结构-1-引言" class="headerlink" title="数据结构 1 引言"></a>数据结构 1 引言</h2><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>集合结构：两两无关<br>线性结构：除首尾元素外，每个元素仅有一个前驱和一个后驱<br>树形结构：除根元素外，每个元素都只有一个前驱，后驱数量不限<br>图型结构：每个元素可以有任意数量的前驱和后驱</p><h3 id="数据结构的操作"><a href="#数据结构的操作" class="headerlink" title="数据结构的操作"></a>数据结构的操作</h3><p>创建和释放：构造函数 + 析构函数<br>更新：插入 更新（修改）删除<br>查找：访问 搜索 遍历</p><h3 id="数据结构存储实现"><a href="#数据结构存储实现" class="headerlink" title="数据结构存储实现"></a>数据结构存储实现</h3><p>存储结点：每个存储结点存放一个数据元素<br>结点间的关系：比如链表中指向next结点的指针是一种链接存储；而vector类中我们使用的是数组存储；而对于集合结构这种杂乱的数据结构时，可用哈希存储，用一个哈希函数将数据元素与元素存储位置关联起来；另外还有索引存储，分别设置数据区和索引区<br>附加信息：比如链表中的头尾结点</p><h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><p>三个时间性能：</p><ul><li>最好情况下的时间复杂度</li><li>最坏情况下的时间复杂度</li><li>平均情况下的时间复杂度</li></ul><p>时间复杂度的表示一般有2种方法：<strong>大O表示法</strong>（取运行时间函数的主项）和 F（n）表示法（通常选择比较简单的函数形式）。有：O（1）&lt; O(logN)&lt; O(N)&lt; O(NlogN)&lt; O(N^2)&lt; O(N^3) ; O(2^N)&lt; O(N!)&lt; O(N^N)<br>那么时间复杂度应该如何计算呢?<br>核心在于：在整个程序中找出最复杂、运行时间最长的程序段的时间复杂度<br>空间性能：</p><ul><li>存储被处理数据所需的空间</li><li>实现操作所需的额外空间<br>空间复杂度一般按最坏情况处理，和时间复杂度一样同样使用大O表示法</li></ul><h3 id="经典举例：最大连续子序列和问题"><a href="#经典举例：最大连续子序列和问题" class="headerlink" title="经典举例：最大连续子序列和问题"></a>经典举例：<strong>最大连续子序列和问题</strong></h3><p>方法一：O(N^3)</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> MaxSum;<br>for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">n</span> ; i ++)&#123;<br>    for(<span class="hljs-built_in">int</span> j = i ; j &lt; <span class="hljs-built_in">n</span> ; j ++)&#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> k = i ; k &lt;= j ; k ++)&#123;<br>            <span class="hljs-built_in">sum</span> += a[k];<br>        &#125; <br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">sum</span> &gt; MaxSum)&#123;<br>            MaxSum = <span class="hljs-built_in">sum</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：O(N^2)</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> MaxSum = <span class="hljs-number">0</span> ;<br>for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">size</span> ; i ++)&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span> ;<br>    for(<span class="hljs-built_in">int</span> j = i ; j &lt; <span class="hljs-built_in">size</span> ; j ++)&#123;<br>        <span class="hljs-built_in">sum</span> += a[j];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &gt; MaxSum )&#123;<br>            MaxSum = <span class="hljs-built_in">sum</span>;<br>            start = i;<br>            <span class="hljs-keyword">end</span> = j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：分治法 O(NlogN)<br>共有3种情况：</p><ul><li>全部出现在前半部分，直接递归计算</li><li>全部出现在前半部分，直接递归计算</li><li>前半部分开始，后半部分结束</li></ul><p>那么方法也是相对应的：</p><ul><li>递归计算前半部分最大连续子序列和</li><li>递归计算后半部分最大连续子序列和</li><li>通过2个连续循环计算前半部分开始，后半部分结束的最大连续子序列和</li></ul><p>下面是代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> MaxSum(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right ,<span class="hljs-type">int</span> &amp;<span class="hljs-keyword">start</span>,<span class="hljs-type">int</span> &amp;<span class="hljs-keyword">end</span>)&#123;<br>    <span class="hljs-keyword">if</span>(left == right)&#123;<br>        start = left;<br>        end = right;<br>        <span class="hljs-keyword">if</span>(a[left] &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> MaxLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> MaxRight = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> MaxLeftTmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> MaxRightTmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> startL,endL,startR,endR;<br>    <span class="hljs-type">int</span> center = (left + right)/<span class="hljs-number">2</span>;<br>    MaxLeft = MaxSum(a,left,center,startL,endL);<br>    MaxRight = MaxSum(a,center + <span class="hljs-number">1</span>,right,startR,endR);<br>    <span class="hljs-type">int</span> leftSum,rightSum;<br>    start = center;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = center;i &gt;= left;i <span class="hljs-comment">--)&#123;</span><br>        leftSum += a[i];<br>        <span class="hljs-keyword">if</span>(leftSum &gt; MaxLeftTmp)&#123;<br>            MaxLeftTmp = leftSum;<br>            start = i; <br>        &#125;<br>    &#125;<br>    end = center + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = center + <span class="hljs-number">1</span>;i &lt;= right;i ++)&#123;<br>        rightSum += a[i];<br>        <span class="hljs-keyword">if</span>(rightSum &gt; MaxRightTmp)&#123;<br>            MaxRightTmp = rightSum;<br>            end = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> MaxTmp = MaxLeftTmp + MaxRightTmp;<br>    <span class="hljs-keyword">if</span>(MaxTmp &gt;= MaxLeft &amp;&amp; MaxTmp &gt;= MaxRight)&#123;<br>        <span class="hljs-keyword">return</span> MaxTmp;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(MaxLeft &gt;= MaxTmp &amp;&amp; MaxLeft &gt;= MaxRight)&#123;<br>        start = startL;<br>        end = endL;<br>        <span class="hljs-keyword">return</span> MaxLeft;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        start = startR;<br>        end = endR;<br>        <span class="hljs-keyword">return</span> MaxRight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算以下复杂度，得到T(N) &#x3D; 2T(N&#x2F;2) + N; 可以解得复杂度为O（NlogN）</p><p>方法四：穷举法的再优化 O(N)<br>通过一点逻辑判断，我们可以知道，<strong>所有与最大连续子序列毗连的连续子序列一定有负的（或0），否则会包含它们</strong>。故我们可以做出改进：当检测出一个负子序列时，可以直接让start增加到j + 1。这样一来，我们只需要：</p><p>$$<br>一个循环<br>$$</p><p>下面给出代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> MaxSumProcess(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> size)&#123;<br>    <span class="hljs-type">int</span> MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> thisSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i ++)&#123;<br>        thisSum += a[i];<br>        <span class="hljs-keyword">if</span>(thisSum &lt;= <span class="hljs-number">0</span>)&#123;<br>            thisSum = <span class="hljs-number">0</span>;<br>            MaxSum = <span class="hljs-number">0</span>;<br>            tmp = i + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thisSum &gt; MaxSum)&#123;<br>            MaxSum = thisSum;<br>            start = tmp;<br>            end = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(start == size)&#123;<br>        MaxSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这种类似于动态规划的方法，时间复杂度达到了O(N)!</p><h3 id="数据结构的实现"><a href="#数据结构的实现" class="headerlink" title="数据结构的实现"></a>数据结构的实现</h3><p>过程化程序设计 VS 面向对象程序设计：过程化程序设计通过定义一组变量进行存储实现，通过一组算法进行运算实现，但是无法将数据结构定义成一个真正的程序，程序员必须掌握每个数据结构的实现。而面向对象的程序设计将存储与运算封装为类，每个数据结构可表示为一个类模板，有利于代码的重用。<br>每种数据结构用一个抽象类描述，指出该数据结构提供的操作。而每种数据结构可以有若干种实现的方法，每种实现就是一个类（从抽象类继承）。</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Time and Space Complexity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic3</title>
    <link href="/2025/02/11/Java-Basic3/"/>
    <url>/2025/02/11/Java-Basic3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Welcome-back-to-JaneZ’s-Java-Learning"><a href="#Before：Welcome-back-to-JaneZ’s-Java-Learning" class="headerlink" title="Before：Welcome back to JaneZ’s Java Learning!"></a>Before：Welcome back to JaneZ’s Java Learning!</h5><h2 id="Java-Basic-3"><a href="#Java-Basic-3" class="headerlink" title="Java Basic 3"></a>Java Basic 3</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Public VS Private ————对于fields和methods而言<br>Public: 可以被其他对象调用  Private: 只可被类内成员调用<br>那么为什么要对访问权限进行公有和私有的区分呢？</p><ul><li>为了保护私有信息</li><li>声明其他对象应该如何调用当前类</li><li>将实现与接口分离————意味着你可以自由地修改类的内部实现，而不影响使用该类的其他代码，只要公共接口保持不变</li></ul><h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><p>在函数中定义的变量只能在该函数中进行访问，而在类中定义的变量可以在类的所有函数中进行访问<br>函数级别的变量只在函数内部有效，而类级别的变量在整个类中都有效</p><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>用于引用当前对象的实例，其作用在于：</p><ul><li>明确作用域（Clarifies scope）：<br>当类中的成员变量和方法参数同名时，使用this关键字可以明确指出要访问的是成员变量而不是参数。</li><li>表示“my object”：<br>this关键字用于引用当前对象，即调用方法的对象。</li></ul><h3 id="Java的包-Package"><a href="#Java的包-Package" class="headerlink" title="Java的包 Package"></a>Java的包 Package</h3><p>类似于C++中的namespace(名字空间)</p><ul><li>每个类都属于一个包，包是组织类的一种形式</li><li>同一包中的类具有相似的用途。例如，所有与图形用户界面相关的类可能放在一个名为 gui 的包中。</li><li>包只是目录</li><li>需要导入其他包中的类<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> com.example.data;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataModel</span> </span>&#123;<br>    // 数据模型相关的代码<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h4><p>在C++中，我们有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> myapp &#123;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace myapp</span><br></code></pre></td></tr></table></figure><p>而相应的在Java中，我们有：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package com.example.myapp; <span class="hljs-comment">// 文件路径</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义的基本格式为：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> path.to.package.foo<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="包的使用方式"><a href="#包的使用方式" class="headerlink" title="包的使用方式"></a>包的使用方式</h4><p>在C++中，我们有<code>using namespace std</code><br>而相应的在Java中，我们有：<code>import path.to.package.foo.Foo</code></p><h4 id="为什么包？（好奇怪的句子"><a href="#为什么包？（好奇怪的句子" class="headerlink" title="为什么包？（好奇怪的句子"></a>为什么包？（好奇怪的句子</h4><ul><li>组合相似功能<br>包可以用来将功能相似的类组合在一起。这样做可以提高代码的模块化，使得相关功能更加集中和易于管理。</li><li>区分相似名称<br>包还可以用来区分具有相似名称的类，以避免命名冲突。<br>例如，shopping.List 和 packing.List 这两个类虽然名称相似，但它们位于不同的包中，分别代表购物清单和打包清单。通过使用包，我们可以清楚地区分这两个类，即使它们的名称相同。</li></ul><h4 id="特殊的包"><a href="#特殊的包" class="headerlink" title="特殊的包"></a>特殊的包</h4><p>首先，同一包内的类可以互相访问。<br>其次，还有一个比较特殊的包：java.lang<br>所有位于 java.lang 包中的类都不需要显式导入就可以在任何地方使用。这是Java语言规范的一部分，java.lang 包被视为Java程序的基础包，其中包含了一些最常用的类，如 String、Math、System 等。</p><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><p>起因是在使用deepseek时看到了这样一个界面：<br><img src="/img/deepseekAPI.png" alt="deepseekAPI"><br>一直对<strong>API</strong>为何物充满了疑问，出于好奇还充了10块钱买了五百万tokens，但并不知道应该如何使用😅（最近资源紧张似乎已经买不了了🤣）<br>在看到这里时十分激动，于是立刻开始了学习！<br>首先，我先问了deepseek✌，API是什么？<br><img src="/img/APIanswer.png" alt="APIanswer"><br><strong>Application Programing Interface!</strong><br>好像也没有那么抽象嘛？我的理解是就是一种很不错的工具，通过标准化接口简化开发，提升效率，广泛应用于数据访问、服务集成和微服务架构中。而我们要讨论的Java API，其实就类似于C++&#x2F;Python中的标准库（standard library）<br>Java语言包含了大量的包（packages）和类（classes），开发者可以利用Java提供的现有类来完成特定的任务，而不需要从头开始编写代码，这样可以节省时间和努力。<br>C++中的标准模板库（STL）我们已经挺熟悉的了，那么接下来，让我们看看Java API中有什么相应的数据结构：<br>1.ArrayList<br>我们知道在C++中有std::vector，可以动态地调节数组的大小，而在Java中，有一个具有同样功能的容器————<strong>ArrayList</strong>，其用法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ArrayList&lt;Book&gt; books = <span class="hljs-keyword">new</span> ArrayList&lt;Book&gt;();<br>books.<span class="hljs-keyword">add</span>(b);<br>books.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span> , a); <span class="hljs-comment">//相当于insert</span><br>books.<span class="hljs-keyword">remove</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//相当于remove</span><br></code></pre></td></tr></table></figure><p>2.Set<br>同样的，我们知道在C++中有std::set，表示集合，而在Java中，有一个具有相似功能的容器————<strong>Set</strong>，其特点如下：</p><ul><li>集合中每个对象只存储一份，即不允许重复</li><li>集合中的对象没有索引，不能通过索引访问对象<br>下面是两种主要的Set实现：</li><li>TreeSet，对应C++中的std::set  有序</li><li>HashSet，对应C++中的std::unordered_set  无序但查找更快</li></ul><p>3.Map<br>更加同样的，我们知道在C++中有std::map，表示映射，而在Java中，有一个具有相似功能的容器————<strong>Map</strong>，其特点如下：</p><ul><li>存储的是键值对（key-value pair）</li><li>可以通过查找键（key）来获取对应的值（value）<br>下面是两种主要的Map实现：</li><li>TreeMap，对应C++中的std::map  有序</li><li>HashMap，对应C++中的std::unordered_map  无序但查找更快</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure6</title>
    <link href="/2025/02/10/Data-Structure6/"/>
    <url>/2025/02/10/Data-Structure6/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎"><a href="#Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎" class="headerlink" title="Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎"></a>Before：maybe是回校前最后一篇DS了😢浅浅立个flag：开学后成为日更博主😎</h5><h2 id="Data-Structure-6-栈的链接实现及栈的应用"><a href="#Data-Structure-6-栈的链接实现及栈的应用" class="headerlink" title="Data Structure 6 栈的链接实现及栈的应用"></a>Data Structure 6 栈的链接实现及栈的应用</h2><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>在上一章节的内容中，我们学习了顺序栈相关知识，知道顺序栈的实现本质是在维护一个动态数组，那么在本章节中要讲解的<strong>链接栈</strong>与顺序栈的实现有何区别呢？</p><h3 id="链接栈的存储实现"><a href="#链接栈的存储实现" class="headerlink" title="链接栈的存储实现"></a>链接栈的存储实现</h3><p>由于与栈相关的操作都是在栈顶进行的，所以并不需要直接前驱，使用单链表即可，也不需要头结点。下图是一个存储的图示：<br><img src="/img/%E9%93%BE%E6%8E%A5%E6%A0%88%E5%AD%98%E5%82%A8.png" alt="链接栈存储"><br>话不多说，上链接栈定义代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>            node *next;<br>            elemType data;<br>            <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>                next = n;<br>                data = x;<br>            &#125;<br>            <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>            ~<span class="hljs-built_in">node</span>();<br>        &#125;;<br><br>        node *top_p; <span class="hljs-comment">//栈顶结点</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkStack</span>();<br>        ~<span class="hljs-built_in">linkStack</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="链接栈运算实现"><a href="#链接栈运算实现" class="headerlink" title="链接栈运算实现"></a>链接栈运算实现</h3><p>构造函数&amp;析构函数：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">linkStack</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">linkStack</span>()</span>&#123;<br>    top_p = nullptr;<br>&#125;<br><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">linkStack</span>&lt;<span class="hljs-title">elemType</span>&gt;::~<span class="hljs-title">linkStack</span>()</span>&#123;<br>    node *<span class="hljs-keyword">q</span>;<br>    <span class="hljs-keyword">while</span>(t != nullptr)&#123;<br>        <span class="hljs-keyword">q</span> = top_p;<br>        top_p = top_p -&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">q</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进栈、出栈、判空、取栈顶元素：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">push</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    top_p = new node(x , top_p);<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">pop</span>()&#123;<br>    node *p = top_p;<br>    top_p = top_p -&gt; next;<br>    elemType x = p -&gt; data;<br>    delete p;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> top_p == <span class="hljs-literal">null</span>ptr;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">linkStack</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">top</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> top_p -&gt; data;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="STL中的栈"><a href="#STL中的栈" class="headerlink" title="STL中的栈"></a>STL中的栈</h3><p>在STL中，借助于其他容器存储数据的容器称作<strong>容器适配器</strong>。栈借助线性表进行存储，故属于容器适配器。栈可以借助的容器有vector、list和deque。在调用STL::stack时，如果不指定第二个参数，则默认是用deque来存储数据。<br>For example: <code>$stack&lt;int , vector&lt;int&gt;&gt;$</code> <code>$stack&lt;int , list&lt;int&gt;&gt;$</code></p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>1.递归调用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> printInt(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span> &lt; <span class="hljs-number">10</span>)&#123;<br>        cout.put(<span class="hljs-built_in">num</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        printInt(<span class="hljs-built_in">num</span>/<span class="hljs-number">10</span>);<br>        cout.put(<span class="hljs-built_in">num</span>%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是应用递归函数实现对一个正整数的打印的函数<br>2.括号配对 balance类的定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">balance</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        ifstream fin; <span class="hljs-comment">//待检测文件流</span><br>        <span class="hljs-built_in">int</span> curremtLine; <span class="hljs-comment">//当前处理的行号</span><br>        <span class="hljs-built_in">int</span> errors; <span class="hljs-comment">//现有的错误数量</span><br>    <span class="hljs-keyword">struct</span> Symbol&#123; <span class="hljs-comment">//栈元素类型</span><br>        <span class="hljs-built_in">char</span> token;<br>        <span class="hljs-built_in">int</span> TheLine; <br>    &#125;;<br>    <span class="hljs-built_in">enum</span> Slash&#123;<br>        SlashSlash; <span class="hljs-comment">//C++注释</span><br>        SlashStar; <span class="hljs-comment">//C注释</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">CheckMatch</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> Symb I, <span class="hljs-built_in">char</span> Symb2, <span class="hljs-built_in">int</span> Line I, <span class="hljs-built_in">int</span> Line2</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">char</span> <span class="hljs-title">GetNextSymbol</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PutBackChar</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> ch</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkipComment</span>(<span class="hljs-params"><span class="hljs-built_in">enum</span> CommentType type</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkipQuote</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> type</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">char</span> <span class="hljs-title">NextChar</span>()</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        balance(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *s);<br>        <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">CheckBalance</span>()</span>; <span class="hljs-comment">//检查括号是否匹配</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">noFile</span>&#123;&#125;; <span class="hljs-comment">//若检查文件不存在，抛出此异常</span><br></code></pre></td></tr></table></figure><p>具体实现就不给出了（还是太懒了😢😢😢）</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次交流</title>
    <link href="/2025/02/09/%E4%B8%80%E6%AC%A1%E4%BA%A4%E6%B5%81/"/>
    <url>/2025/02/09/%E4%B8%80%E6%AC%A1%E4%BA%A4%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。"><a href="#Before-今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。" class="headerlink" title="Before: 今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。"></a>Before: 今天（20250209）晚上和爸妈进行了一次交流，下面是对这次交流做的一些整理，希望能从中获得一些启发，在下学期的学习中做出改变。</h5><p>🦈🐬🦭🐳🐋🐟🐠🐡🦐🦑🐙🦞🦀🐚🪸🪼</p><h1 id="大一上学期"><a href="#大一上学期" class="headerlink" title="大一上学期"></a>大一上学期</h1><h2 id="收获-🎖️"><a href="#收获-🎖️" class="headerlink" title="收获 🎖️"></a>收获 🎖️</h2><h3 id="学习层面"><a href="#学习层面" class="headerlink" title="学习层面"></a>学习层面</h3><ul><li>新鲜的知识 ———— 数分 线代 程设</li><li>从未接触过的知识体系</li><li>新的看待科学的眼光</li><li>各类工具的使用</li></ul><h3 id="同学交往"><a href="#同学交往" class="headerlink" title="同学交往"></a>同学交往</h3><ul><li>一些玩的很好的朋友</li><li>一些大佬请教问题</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>学会了一些chore ———— 很多事情只能靠自己，不做不行</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>渐渐地在从高中生思维走出来，慢慢适应大学生活 </p><h2 id="遗憾-😢"><a href="#遗憾-😢" class="headerlink" title="遗憾 😢"></a>遗憾 😢</h2><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间分配很不合理，缺少规划意识</p><h3 id="急于求成"><a href="#急于求成" class="headerlink" title="急于求成"></a>急于求成</h3><p>学习浮躁，喜欢和他人作比较，经常莫名其妙地焦虑</p><h2 id="针对性措施"><a href="#针对性措施" class="headerlink" title="针对性措施"></a>针对性措施</h2><h3 id="时间管理-1"><a href="#时间管理-1" class="headerlink" title="时间管理"></a>时间管理</h3><ul><li>列 todoList</li><li>每天最后可以以日记的形式对一天进行复盘</li></ul><h3 id="急于求成-1"><a href="#急于求成-1" class="headerlink" title="急于求成"></a>急于求成</h3><ul><li>“榜样的力量” 找到一个比自己优秀的人，像TA看齐 ————目标意识</li><li>学业上稳扎稳打，不要一味追求速度，重视完成的质量</li></ul><h1 id="新学期（大一下学期）"><a href="#新学期（大一下学期）" class="headerlink" title="新学期（大一下学期）"></a>新学期（大一下学期）</h1><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="做出改变"><a href="#做出改变" class="headerlink" title="做出改变"></a>做出改变</h3><ul><li>减少无意义的社交</li><li>对问题进行更加深入的思考 ————深度思考</li></ul><h3 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h3><ul><li>反思旧学期存在的问题</li><li>为新学期指定可执行性强的计划</li></ul><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><ul><li>多与老师、学长、同学进行交流</li><li>一个问题想3遍</li></ul><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><h3 id="每天11-30睡"><a href="#每天11-30睡" class="headerlink" title="每天11:30睡"></a>每天11:30睡</h3><p>😴😴😴</p><h3 id="每天6-30-7-00起床"><a href="#每天6-30-7-00起床" class="headerlink" title="每天6:30 - 7:00起床"></a>每天6:30 - 7:00起床</h3><p>🛏️🛏️🛏️</p><h3 id="（无特殊情况）图书馆待到10-30"><a href="#（无特殊情况）图书馆待到10-30" class="headerlink" title="（无特殊情况）图书馆待到10:30"></a>（无特殊情况）图书馆待到10:30</h3><p>🧑‍💻👨‍💻👩‍💻</p><h3 id="尽量少点外卖，多去食堂"><a href="#尽量少点外卖，多去食堂" class="headerlink" title="尽量少点外卖，多去食堂"></a>尽量少点外卖，多去食堂</h3><p>🍚🍛🍙</p><h3 id="（由于身体原因）禁止任何含咖啡因的食物"><a href="#（由于身体原因）禁止任何含咖啡因的食物" class="headerlink" title="（由于身体原因）禁止任何含咖啡因的食物"></a>（由于身体原因）禁止任何含咖啡因的食物</h3><p>❌❌❌</p><h3 id="按时服用药物"><a href="#按时服用药物" class="headerlink" title="按时服用药物"></a>按时服用药物</h3><p>💊💊💊</p><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><h3 id="“立志”"><a href="#“立志”" class="headerlink" title="“立志”"></a>“立志”</h3><p>种下一个梦想，为之奋斗<br>追逐心中的那束光</p><h3 id="“正能量”"><a href="#“正能量”" class="headerlink" title="“正能量”"></a>“正能量”</h3><p>做一个快乐、正面、积极、幸福、知足的人❤️</p>]]></content>
    
    
    
    <tags>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic2</title>
    <link href="/2025/02/09/Java-Basic2/"/>
    <url>/2025/02/09/Java-Basic2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：快开学了（-还没玩够呢呜呜呜😢-）"><a href="#Before：快开学了（-还没玩够呢呜呜呜😢-）" class="headerlink" title="Before：快开学了（ 还没玩够呢呜呜呜😢 ）"></a>Before：快开学了（ 还没玩够呢呜呜呜😢 ）</h5><p>下面是一点碎碎念吧：<br>昨天和fz学弟吃饭，震惊于学弟对物竞的执着，想必是没法把学弟骗来泥交了吧🤣🤣🤣。想起了3年前的自己对数竞也是一样的痴迷，励志要把一生都献给纯数研究。当时应该还在学物竞，尝试着数物双修。还是在寒假后放弃了物理，选了数学，当然最后也只以高二的省一草草收场。有时候想，如果当时跟大多数人一样学了物理，大概至少也有个国一吧。经常嘴上说自己物理差数学好，其实细想自己还是挺喜欢物竞的。下学期也是终于有物理课了，希望能借此找到以前对物理的热爱❤️</p><h2 id="Java-Basic-2"><a href="#Java-Basic-2" class="headerlink" title="Java Basic 2"></a>Java Basic 2</h2><h3 id="Good-Programing-Style-代码风格"><a href="#Good-Programing-Style-代码风格" class="headerlink" title="Good Programing Style 代码风格"></a><strong>Good Programing Style 代码风格</strong></h3><ul><li>Rule 1 : 使用好的&#x2F;有意义的变量名</li><li>Rule 2 : 正确的缩进  Ctrl + shift + F 可自动调节缩进</li><li>Rule 3 : 空格 （特别是在复杂的表达式中） 空行 增强可读性</li><li>Rule 4 : 不要重复测试 可能存在多个条件判断中不必要的重复检查等问题，使得代码不够简洁和高效。</li></ul><h3 id="循环-Loops"><a href="#循环-Loops" class="headerlink" title="循环 Loops"></a>循环 Loops</h3><p>Java中有几个循环语句，与C ++ 中几乎一致</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">( condition )</span></span>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(initialization; condition ; updata)</span></span>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="break-continue"><a href="#break-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h4><p>与C ++ 中用法一致</p><h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 Arrays"></a>数组 Arrays</h3><p>与C ++ 同样都是 0 ~ base - 1</p><h4 id="Arrays-的定义"><a href="#Arrays-的定义" class="headerlink" title="Arrays 的定义"></a>Arrays 的定义</h4><p>int[] values;  &#x2F;&#x2F;整型一维数组<br>int[][] values; &#x2F;&#x2F;整型二维数组<br>如果想创建一个固定大小的数组，使用运算符 new<br>int[] values &#x3D; new int[5];</p><h4 id="Arrays-初始化"><a href="#Arrays-初始化" class="headerlink" title="Arrays 初始化"></a>Arrays 初始化</h4><p>注意：这种方法只能在声明变量时使用：<br>int[] values &#x3D; {12 , 24 , -23 , 47};</p><h4 id="Arrays-访问"><a href="#Arrays-访问" class="headerlink" title="Arrays 访问"></a>Arrays 访问</h4><p>同样是下标访问  values[index]</p><h4 id="length-变量"><a href="#length-变量" class="headerlink" title="length 变量"></a>length 变量</h4><p>Java数组在这里与C++数组存在一点区别：<br>C++中length变量只存在于STL容器中，普通数组并不具备这一变量，但Java中则存在<br>For example:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span>[] <span class="hljs-keyword">values</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">12</span>];<br><span class="hljs-type">int</span> size = <span class="hljs-keyword">values</span>.length;<br></code></pre></td></tr></table></figure><h4 id="String-Array"><a href="#String-Array" class="headerlink" title="String Array"></a>String Array</h4><p>Java中允许字符串数组（C ++ 中并不允许string数组）</p><h3 id="Object-Oriented-Programing-面向对象编程"><a href="#Object-Oriented-Programing-面向对象编程" class="headerlink" title="Object Oriented Programing 面向对象编程"></a>Object Oriented Programing 面向对象编程</h3><h4 id="Why-use-classes"><a href="#Why-use-classes" class="headerlink" title="Why use classes ?"></a>Why use classes ?</h4><p><img src="/img/whyclasses1.png" alt="Why use classes"><br><img src="/img/whyclasses2.png" alt="Why use classes"></p><h4 id="Class-Definition"><a href="#Class-Definition" class="headerlink" title="Class Definition"></a>Class Definition</h4><p><code>Baby myBaby = new Baby();</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baby</span></span>&#123;<br>    fields<br>    methods<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数-constructer"><a href="#构造函数-constructer" class="headerlink" title="构造函数 constructer"></a>构造函数 constructer</h4><ul><li>函数名即为类名</li><li>没有返回值</li><li>通常初始化fields</li><li>每个类至少需要一个构造函数<br>For example:<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span>&#123;<br>    <span class="hljs-type">String</span> name;<br>    <span class="hljs-type">boolean</span> isMale;<br>    <span class="hljs-built_in">Baby</span>(<span class="hljs-type">String</span> myname , <span class="hljs-type">boolean</span> malebaby)&#123;<br>        name = myname;<br>        isMale = malebaby;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="调用类"><a href="#调用类" class="headerlink" title="调用类"></a>调用类</h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">Baby</span> <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">Baby</span> <span class="hljs-type">Jane</span> = new <span class="hljs-type">Baby</span>(<span class="hljs-string">&quot;JaneZ&quot;</span> , <span class="hljs-literal">false</span> );<br><span class="hljs-type">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">Jane</span>.name);<br><span class="hljs-type">Jane</span>.sayhi();<br></code></pre></td></tr></table></figure><h3 id="基本数据类型-VS-引用数据类型"><a href="#基本数据类型-VS-引用数据类型" class="headerlink" title="基本数据类型 VS 引用数据类型"></a>基本数据类型 VS 引用数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>包括 int（整数）、long（长整数）、double（双精度浮点数）、boolean（布尔值）、char（字符）、short（短整数）、byte（字节）、float（单精度浮点数）</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>数组和对象<br>所占的空间比基本数据类型要大的多</p><h3 id="Java-对Object-的存储——引用！"><a href="#Java-对Object-的存储——引用！" class="headerlink" title="Java 对Object 的存储——引用！"></a>Java 对Object 的存储——引用！</h3><p><strong>Reference</strong>: Object的存储位置<br>遵循对对象的引用 &lt;-&gt; 按照指示前往一所房子<br>改变对象中的字段 &lt;-&gt; 挪动房子里的家具</p><h3 id="静态数据类型和函数"><a href="#静态数据类型和函数" class="headerlink" title="静态数据类型和函数"></a>静态数据类型和函数</h3><p>静态字段或函数是为类声明（class declaration）而定义的<br>也就是说，它们属于类本身，而不是类的某个具体实例</p><h4 id="Why-public-static-void-main-String-arguments"><a href="#Why-public-static-void-main-String-arguments" class="headerlink" title="Why public static void main(String[] arguments)"></a>Why <code>public static void main(String[] arguments)</code></h4><ul><li>无需实例化：程序启动时，Java 虚拟机（JVM）需要直接调用 main 方法来执行程序。如果 main 方法不是 static，JVM 就需要先实例化一个类的对象，然后才能调用 main 方法，但在程序启动初期，没有合适的机制来创建对象，所以将 main 声明为 static，JVM 可以直接通过类名调用它，无需创建类的实例。</li><li>内存和性能考虑：静态方法在类加载时就已经绑定到类上，调用时不需要额外的对象创建开销，这有助于提高程序启动的效率，并且在程序启动阶段也更符合内存管理和性能优化的需求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure5</title>
    <link href="/2025/02/09/Data-Structure5/"/>
    <url>/2025/02/09/Data-Structure5/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：JaneZ今天更新频率有点高啊😎😎😎（-这么良心的up还不快三连一下🤣🤣🤣-）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（-应该坐完了永初路——福建路这一段-），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（-nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕"><a href="#Before：JaneZ今天更新频率有点高啊😎😎😎（-这么良心的up还不快三连一下🤣🤣🤣-）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（-应该坐完了永初路——福建路这一段-），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（-nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕" class="headerlink" title="Before：JaneZ今天更新频率有点高啊😎😎😎（ 这么良心的up还不快三连一下🤣🤣🤣 ）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（ 应该坐完了永初路——福建路这一段 ），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（ nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕"></a>Before：JaneZ今天更新频率有点高啊😎😎😎（ 这么良心的up还不快三连一下🤣🤣🤣 ）南京几个月前新开通了7号线，作为资深轨道交通爱好者的JaneZ也是在回到南京的第二天光速打卡了（ 应该坐完了永初路——福建路这一段 ），比较熟悉的几个站点就是中胜、大士茶亭、草场门、古平岗还有福建路（ nsfz校车！）吧。前2天去省人民看病，顺带打卡了7号线网红站点——清凉山！真的好看！地下6层是真的厉害！附上图片一张💕💕💕</h5><p><img src="/img/Metro.png" alt="清凉山地铁站"></p><h2 id="Data-Structure-5-栈"><a href="#Data-Structure-5-栈" class="headerlink" title="Data Structure 5 栈"></a>Data Structure 5 栈</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ul><li>一种特殊的线性表，插入删除运算限定在表的某一端进行</li><li>允许进行插入删除操作的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong></li><li>处于栈顶位置中的数据元素称为<strong>栈顶元素</strong>，若栈中没有元素，则称为<strong>空栈</strong></li><li>LIFO表（后进先出表）</li></ul><h3 id="栈的抽象类"><a href="#栈的抽象类" class="headerlink" title="栈的抽象类"></a>栈的抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">stack</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//判栈空</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//进栈</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//出栈</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//取栈顶元素</span><br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">stack</span>(); <span class="hljs-comment">//虚析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="栈的顺序实现"><a href="#栈的顺序实现" class="headerlink" title="栈的顺序实现"></a>栈的顺序实现</h3><p>栈的顺序实现称为<strong>顺序栈</strong><br>顺序栈的实现需要3个变量：</p><ul><li>一个指向栈元素类型的指针（指向动态数组的首地址）</li><li>一个表示数组规模的整型数</li><li>一个表示栈顶位置的整型数<br><img src="/img/%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%AD%98%E5%82%A8.png" alt="顺序栈存储"></li></ul><h4 id="下面是一个顺序栈类的定义"><a href="#下面是一个顺序栈类的定义" class="headerlink" title="下面是一个顺序栈类的定义"></a>下面是一个顺序栈类的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqStack</span> : <span class="hljs-keyword">public</span> stack&lt;elemType&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        elemType *elem;<br>        <span class="hljs-type">int</span> top_p;<br>        <span class="hljs-type">int</span> maxSize;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);<br>        ~<span class="hljs-built_in">seqStack</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">bool</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">isEmpty</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> top_p == <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">push</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span> &amp;<span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(top_p == maxSize <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">double</span>Space();<br>    &#125;<br>    top_p ++;<br>    elem[top_p] == x;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">pop</span>()&#123;<br>    top_p --;<br>    <span class="hljs-keyword">return</span> elem[top_p + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">top</span>() <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> elem[top_p];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">seqList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">doubleSpace</span>()</span>&#123;<br>    elemType *tmp = elem;<br>    elem = new elemType[<span class="hljs-number">2</span> * maxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSize ; i ++)&#123;<br>        elem[i] = tmp[i];<br>    &#125;<br>    maxSize *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure4</title>
    <link href="/2025/02/07/Data-Structure4/"/>
    <url>/2025/02/07/Data-Structure4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：JaneZ换了一家咖啡店，人在Manner-Coffee-身后10米有一只孔雀（附上图片🥶🥶🥶-）"><a href="#Before：JaneZ换了一家咖啡店，人在Manner-Coffee-身后10米有一只孔雀（附上图片🥶🥶🥶-）" class="headerlink" title="Before：JaneZ换了一家咖啡店，人在Manner Coffee ,身后10米有一只孔雀（附上图片🥶🥶🥶 ）"></a>Before：JaneZ换了一家咖啡店，人在Manner Coffee ,身后10米有一只孔雀（附上图片🥶🥶🥶 ）</h5><p><img src="/img/%E5%AD%94%E9%9B%80.png" alt="孔雀"></p><h2 id="Data-Structure-4-约瑟夫环-动态内存分配"><a href="#Data-Structure-4-约瑟夫环-动态内存分配" class="headerlink" title="Data Structure 4 约瑟夫环 动态内存分配"></a>Data Structure 4 约瑟夫环 动态内存分配</h2><h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><p>约瑟夫环是一个很经典的循环链表问题，初次见于OJ上一道经典的题——春樱对决（ ACMOJ1088 ）<br>下面给出约瑟夫环问题一个最简单的例子（报到3倍数击毙）</p><h4 id="构建循环链表"><a href="#构建循环链表" class="headerlink" title="构建循环链表"></a>构建循环链表</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">head</span> <span class="hljs-operator">=</span> p  new node(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>for(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">; i &lt; n ; i ++)&#123;</span><br>    p <span class="hljs-operator">=</span> p -&gt; next <span class="hljs-operator">=</span> new node(i)<span class="hljs-comment">;</span><br>&#125;<br>p -&gt; next <span class="hljs-operator">=</span> head<span class="hljs-comment">; //首尾相连</span><br></code></pre></td></tr></table></figure><h4 id="删除结点（也就是击毙的操作）"><a href="#删除结点（也就是击毙的操作）" class="headerlink" title="删除结点（也就是击毙的操作）"></a>删除结点（也就是击毙的操作）</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">q = head;<br><span class="hljs-function"><span class="hljs-title">while</span>(q -&gt;</span> next != q)&#123;<br>    <span class="hljs-function"><span class="hljs-title">p</span> = q -&gt;</span> next;<br>    <span class="hljs-function"><span class="hljs-title">q</span> = p -&gt;</span> next;<br>    <span class="hljs-comment">//删除q</span><br>    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = q -&gt;</span> next;<br>    delete q;<br>    <span class="hljs-function"><span class="hljs-title">q</span> = p -&gt;</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><h4 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h4><ul><li>存储在内存中一个被称为<strong>堆</strong>的区域中，由一个堆管理器进行管理</li><li>new 操作时分配一块空间，delete 操作时回收一块空间<br>但是不断的 new delete 操作会导致内存空间的碎片化，应该如何管理这些内存片段呢？😢</li></ul><h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><ul><li>所有的空闲片段形成一个集合，按地址顺序排列就得到了线性表，故堆空间的管理实际上就是在<strong>维护一个线性表</strong></li><li>由于该线性表经常需要删除操作（就是 new ）,并且delete操作时可能需要把一些潜在的相邻的闲置空间进行合并，所以用双链表比较合适</li></ul><h4 id="模拟动态内存管理的memory类（感觉这种理解很有意思）"><a href="#模拟动态内存管理的memory类（感觉这种理解很有意思）" class="headerlink" title="模拟动态内存管理的memory类（感觉这种理解很有意思）"></a>模拟动态内存管理的memory类（感觉这种理解很有意思）</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class memory&#123;<br>    struct <span class="hljs-keyword">node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">        int</span> <span class="hljs-literal">start</span>; //起始地址<br>        int end; //终止地址<br>        <span class="hljs-keyword">node</span> <span class="hljs-title">*prev</span>; <br>        <span class="hljs-keyword">node</span> <span class="hljs-title">*next</span>;<br>        <span class="hljs-keyword">node</span><span class="hljs-title">(int</span> s, int e,<span class="hljs-keyword">node</span> <span class="hljs-title">*p</span> = nullptr,<span class="hljs-keyword">node</span> <span class="hljs-title">*n</span> = nullptr)&#123;<br>            <span class="hljs-literal">start</span> = s;<br>            end = e;<br>            prev = p;<br>            next = n;<br>        &#125;<br>        <span class="hljs-keyword">node</span><span class="hljs-title">()&#123;</span><br><span class="hljs-title">            prev</span> = nullptr;<br>            next = nullptr;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*head</span>;<br>    <span class="hljs-keyword">node</span> <span class="hljs-title">*tail</span>;<br><br>    public:<br>        memory(int capacity);<br>        int malloc(int size); //申请一块大小为size的空间，返回起始地址<br>        void free(int <span class="hljs-literal">start</span>,int size); //释放从<span class="hljs-literal">start</span>开始、大小为size的空间<br>        ~memory();<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xquery">memory::memory(int capacity)&#123;<br>   <span class="hljs-built_in"> head</span> = new <span class="hljs-type">node</span>;<br>   <span class="hljs-built_in"> head</span> -&gt; <span class="hljs-keyword">next</span> = new <span class="hljs-type">node</span>(<span class="hljs-number">0</span> , capacity - <span class="hljs-number">1</span>,<span class="hljs-built_in"> head</span>);<br>   <span class="hljs-built_in"> head</span> -&gt; <span class="hljs-keyword">next</span> -&gt; <span class="hljs-keyword">next</span> =<span class="hljs-built_in"> tail</span> = new <span class="hljs-type">node</span>;<br>   <span class="hljs-built_in"> tail</span> -&gt; prev =<span class="hljs-built_in"> head</span> -&gt; <span class="hljs-keyword">next</span>;<br>&#125;<br><br>memory::~memory()&#123;<br>    <span class="hljs-type">node</span> *p =<span class="hljs-built_in"> head</span>;<br>    <span class="hljs-type">node</span> *q;<br>    while(p != nullpter)&#123;<br>        q = p -&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">int malloc(int size)&#123;<br>    <span class="hljs-function"><span class="hljs-title">node</span> *p = head -&gt;</span> next;<br>    int returnValue;<br>    <span class="hljs-function"><span class="hljs-title">while</span>(p != tail &amp;&amp; p -&gt;</span> <span class="hljs-function"><span class="hljs-title">end</span> - p -&gt;</span> start + <span class="hljs-number">1</span> &lt; size)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p == tail)&#123;<br>        return -<span class="hljs-number">1</span>; <span class="hljs-comment">//没有找到</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">returnValue</span> = p -&gt;</span> start;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(p -&gt;</span> <span class="hljs-function"><span class="hljs-title">end</span> - p -&gt;</span> start + <span class="hljs-number">1</span> == size)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">prev</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = p -&gt;</span> next;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">prev</span> = p -&gt;</span> prev;<br>        delete p;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> start += size;<br>    &#125;<br>    return returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xl">void memory::free(int start, int size)&#123;<br>    <span class="hljs-function"><span class="hljs-title">node</span> *p = head -&gt;</span> next;<br>    node *np;<br>    <span class="hljs-function"><span class="hljs-title">while</span>(p != tail &amp;&amp; p -&gt;</span> start &lt; start)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(p != tail &amp;&amp; start + size == p -&gt;</span> start)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> start = start;<br>        np = p;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-function"><span class="hljs-title">np</span> = new node(start , start + size - 1 ,p -&gt;</span> prev, p );<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">prev</span> -&gt;</span> next = np;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> prev = np;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">p</span> = np -&gt;</span> prev;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(p -&gt;</span> <span class="hljs-function"><span class="hljs-title">end</span> + 1 == np -&gt;</span> start)&#123;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span> = np -&gt;</span> next;<br>        <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> end == start + size - <span class="hljs-number">1</span>;<br>        delete np;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure3</title>
    <link href="/2025/02/07/Data-Structure3/"/>
    <url>/2025/02/07/Data-Structure3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-最近装了个虚拟机（-为了Games101配的环境-），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（-打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了-）"><a href="#Before-最近装了个虚拟机（-为了Games101配的环境-），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（-打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了-）" class="headerlink" title="Before: 最近装了个虚拟机（ 为了Games101配的环境 ），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（ 打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了 ）"></a>Before: 最近装了个虚拟机（ 为了Games101配的环境 ），结果很不幸出了一点小小的问题，使得正宫WSL用不了辣（正在紧急维修中）。但是DS的学习是不可中断的！冲！（ 打下这段文字时JaneZ正坐在拥挤的省人民医院诊室门口的地上，脚都麻了 ）</h5><h2 id="Data-Structure-3-双链表-容器-迭代器"><a href="#Data-Structure-3-双链表-容器-迭代器" class="headerlink" title="Data Structure 3 双链表 容器 迭代器"></a>Data Structure 3 双链表 容器 迭代器</h2><p>在上一节中，我们非常详细地实现了一个单链表类（算是对上学期所学进行了一个复习），我个人认为，双链表与单链表并不存在多么显著的区别。所以本章节中关于双链表的部分会相对比较简洁。</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul><li>定义：（和单链表不同的地方）每个结点既保存直接后继结点的地址，也保存直接前驱结点的地址（单链表只保存直接后继结点的地址）</li><li>拥有直接前驱结点的地址实际上意味着双链表可以从后向前访问</li><li>双链表中既包含了一个头结点head ,还包含了一个尾结点tail；保存一个双链表事实上就是保存头尾两个结点的地址<br>下面是一个双链表类的定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dLinkList</span>: <span class="hljs-keyword">public</span> list &lt;elemType&gt;&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>        elemType data;<br>        node *prev;<br>        node *next;<br><br>        <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType&amp; x ,node *p = <span class="hljs-literal">nullptr</span>, node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>            data = x;<br>            prev = p;<br>            next = n;<br>        &#125;<br>        <span class="hljs-built_in">node</span>():<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>node *head;<br>node *tail;<br><span class="hljs-type">int</span> currentLength;<br><span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">dLinkList</span>();<br>    ~<span class="hljs-built_in">dLinkList</span>()&#123;<br>        <span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">delete</span> head;<br>        <span class="hljs-keyword">delete</span> tail;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h3><ul><li>本质上我们所说的数据结构，就是在<strong>保存一组相互之间具有某种关系的数据元素</strong>。而C++把每个数据结构的实现称为<strong>一个容器</strong></li><li>在设计容器时，我们通常为每种容器定义一个相应的表示其中对象位置的类型，称作<strong>迭代器</strong>，相当于指向容器中对象的指针</li><li>设计一个迭代器包括2个部分:<br>(1) 如何标识容器中某一对象的位置<br>(2) 如何实现迭代器的操作</li><li>为了方便用户使用，STL将迭代器类（iterator , const_iterator）定义成相应容器类的公有内嵌类</li><li>注意：iterator类可通过迭代器修改指向元素的值，而const_iterator只可以通过迭代器读取指向元素的值</li></ul><h4 id="下面是一些迭代器自身的常见操作："><a href="#下面是一些迭代器自身的常见操作：" class="headerlink" title="下面是一些迭代器自身的常见操作："></a>下面是一些迭代器自身的常见操作：</h4><p><img src="/img/%E8%BF%AD%E4%BB%A3%E5%99%A8.png" alt="迭代器自身操作"></p><h4 id="这是我手搓的STL-list类中内嵌iterator类（-const-iterator类几乎同理，只是const版本🤣🤣🤣-）的实现："><a href="#这是我手搓的STL-list类中内嵌iterator类（-const-iterator类几乎同理，只是const版本🤣🤣🤣-）的实现：" class="headerlink" title="这是我手搓的STL list类中内嵌iterator类（ const_iterator类几乎同理，只是const版本🤣🤣🤣 ）的实现："></a>这是我手搓的STL list类中内嵌iterator类（ const_iterator类几乎同理，只是const版本🤣🤣🤣 ）的实现：</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        node* ptr;<br>    <span class="hljs-keyword">public</span>:<br>        iterator(node* p = nullptr) : ptr(p) &#123;&#125;<br><br>        iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            ptr = ptr-&gt;next;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        iterator&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>            ptr = ptr-&gt;prev;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>++(int) &#123;<br>            iterator tmp = *<span class="hljs-keyword">this</span>;<br>            ++(*<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>--(int) &#123;<br>            iterator tmp = *<span class="hljs-keyword">this</span>;<br>            --(*<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> noexcept &#123;<br>            <span class="hljs-keyword">return</span> ptr-&gt;<span class="hljs-keyword">data</span>;<br>        &#125;<br><br>        T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> noexcept &#123;<br>            <span class="hljs-keyword">return</span> &amp;(ptr-&gt;<span class="hljs-keyword">data</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* A operator to check whether two iterators are same (pointing to the same memory) */</span><br>        friend bool <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> iterator&amp; a, <span class="hljs-keyword">const</span> iterator&amp; b) &#123;<br>           <span class="hljs-keyword">return</span> (a.ptr == b.ptr);<br>        &#125;<br><br>        friend bool <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> iterator&amp; a, <span class="hljs-keyword">const</span> iterator&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> (a.ptr != b.ptr);<br>        &#125;<br><br>        friend <span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="以线性表为例"><a href="#以线性表为例" class="headerlink" title="以线性表为例"></a>以线性表为例</h3><h4 id="下面是一些list类和vector类中的迭代器相关操作："><a href="#下面是一些list类和vector类中的迭代器相关操作：" class="headerlink" title="下面是一些list类和vector类中的迭代器相关操作："></a>下面是一些list类和vector类中的迭代器相关操作：</h4><p><img src="/img/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.png" alt="迭代器相关操作"></p><h4 id="这是我手搓的STL-list类中与迭代器相关的一些操作的实现🫡🫡🫡："><a href="#这是我手搓的STL-list类中与迭代器相关的一些操作的实现🫡🫡🫡：" class="headerlink" title="这是我手搓的STL list类中与迭代器相关的一些操作的实现🫡🫡🫡："></a>这是我手搓的STL list类中与迭代器相关的一些操作的实现🫡🫡🫡：</h4><p>注：其实存在一些问题（ 因为我的实现并没有考虑模板类型T 不具有默认构造函数的情况 😢 ）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Return an iterator pointing to the first element. */</span><br>iterator <span class="hljs-built_in">begin</span>() noexcept &#123;<br>    return <span class="hljs-built_in">iterator</span>(head-&gt;next);<br>&#125;<br><br>const_iterator <span class="hljs-built_in">cbegin</span>() const noexcept &#123;<br>    return <span class="hljs-built_in">const_iterator</span>(head-&gt;next);<br>&#125;<br><br><span class="hljs-comment">/* Return an iterator pointing to one past the last element. */</span><br>iterator <span class="hljs-built_in">end</span>() noexcept &#123;<br>    return <span class="hljs-built_in">iterator</span>(tail);<br>&#125;<br><br>const_iterator <span class="hljs-built_in">cend</span>() const noexcept &#123;<br>    return <span class="hljs-built_in">const_iterator</span>(tail);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">iterator</span> insert(<span class="hljs-keyword">iterator</span> pos, <span class="hljs-keyword">const</span> T&amp; value) &#123;<br>    node* n = new node(value, pos.<span class="hljs-keyword">ptr</span>-&gt;prev, pos.<span class="hljs-keyword">ptr</span>);<br>    pos.<span class="hljs-keyword">ptr</span>-&gt;prev-&gt;next = n;<br>    pos.<span class="hljs-keyword">ptr</span>-&gt;prev = n;<br>    ++ currentLength;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">iterator</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xl">iterator erase(iterator pos) noexcept &#123;<br>    <span class="hljs-keyword">if</span> (pos == end()) &#123;<br>        return end();<br>    &#125;<br>    node* tmp = pos.ptr;<br>    <span class="hljs-function"><span class="hljs-title">iterator</span> it(tmp-&gt;</span>next);<br>    <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = tmp-&gt;</span>next;<br>    <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prev</span> = tmp-&gt;</span>prev;<br>    delete tmp;<br>    -- currentLength;<br>    return it;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maths-Analysis2</title>
    <link href="/2025/02/05/Maths-Analysis2/"/>
    <url>/2025/02/05/Maths-Analysis2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-好的，又来水文章了。今天要讲的是："><a href="#Before-好的，又来水文章了。今天要讲的是：" class="headerlink" title="Before: 好的，又来水文章了。今天要讲的是："></a>Before: 好的，又来水文章了。今天要讲的是：</h5><h2 id="Maths-Analysis-2-一致收敛判别法"><a href="#Maths-Analysis-2-一致收敛判别法" class="headerlink" title="Maths Analysis 2 一致收敛判别法"></a>Maths Analysis 2 一致收敛判别法</h2><h3 id="第一种：比较判别法"><a href="#第一种：比较判别法" class="headerlink" title="第一种：比较判别法"></a>第一种：比较判别法</h3><p><img src="/img/%E6%AF%94%E8%BE%83%E5%88%A4%E5%88%AB.png" alt="比较判别法"></p><h3 id="第二种：Dirichlet判别法"><a href="#第二种：Dirichlet判别法" class="headerlink" title="第二种：Dirichlet判别法"></a>第二种：Dirichlet判别法</h3><p><img src="/img/%E8%BF%AA%E5%88%A9%E5%85%8B%E9%9B%B7%E5%88%A4%E5%88%AB.png" alt="Dirichlet判别法"></p><h3 id="第三种：Abel判别法"><a href="#第三种：Abel判别法" class="headerlink" title="第三种：Abel判别法"></a>第三种：Abel判别法</h3><p><img src="/img/%E9%98%BF%E8%B4%9D%E5%B0%94%E5%88%A4%E5%88%AB.png" alt="Abel判别法"></p><h3 id="总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些"><a href="#总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些" class="headerlink" title="总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些"></a>总结一下：这三种判别法跟上学期所学的反常积分敛散性判别法和级数敛散性的判别法是很相似的，甚至还更为简洁一些</h3><ul><li>收敛 &lt;-&gt; 一致收敛</li><li>有界 &lt;-&gt; 一致有界</li><li>其实今天仔细一想，对于函数列的问题，好像就应该讨论一致收敛而不是普通的收敛。主要是我觉得吧，普通收敛引入了一个很麻烦的x 😅😅😅</li></ul>]]></content>
    
    
    <categories>
      
      <category>Maths Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic1</title>
    <link href="/2025/02/03/Java-Basic1/"/>
    <url>/2025/02/03/Java-Basic1/</url>
    
    <content type="html"><![CDATA[<h5 id="JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）"><a href="#JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）" class="headerlink" title="JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）"></a>JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）</h5><h4 id="Before-我选择了MIT-6-092-Introduction-To-Programming-In-Java作为Java的入门，目标是快速上手Java"><a href="#Before-我选择了MIT-6-092-Introduction-To-Programming-In-Java作为Java的入门，目标是快速上手Java" class="headerlink" title="Before: 我选择了MIT 6.092: Introduction To Programming In Java作为Java的入门，目标是快速上手Java"></a>Before: 我选择了MIT 6.092: Introduction To Programming In Java作为Java的入门，目标是快速上手Java</h4><h2 id="Java-Basic-1"><a href="#Java-Basic-1" class="headerlink" title="Java Basic 1"></a>Java Basic 1</h2><h3 id="Compiling-Java"><a href="#Compiling-Java" class="headerlink" title="Compiling Java"></a>Compiling Java</h3><p>Source Code(.java) -&gt; javac -&gt; Byte Code -&gt; java</p><h3 id="Java版的Hello-world"><a href="#Java版的Hello-world" class="headerlink" title="Java版的Hello world"></a>Java版的Hello world</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] <span class="hljs-variable language_">arguments</span></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>,<span class="hljs-title function_">printIn</span>(<span class="hljs-string">&quot;Hello world.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Program-Structure"><a href="#Program-Structure" class="headerlink" title="Program Structure"></a>Program Structure</h3><p>class <strong>CLASSNAME</strong>{<br>    public static void main(String[] arguments){<br>        <strong>STATEMENTS</strong><br>    }<br>}</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>System.out.printIn(some String)<br>Example:</p><ul><li>System.output.printIn(“output”);</li><li>Console: output</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>boolean 相当于C&#x2F;C++中的bool<br>int 相当于C&#x2F;C++中的int<br>double 相当于C&#x2F;C++中的double<br>String 相当于C&#x2F;C++中的string<br><strong>注意：Java要求数据类型必须正确匹配</strong><br>如：String five &#x3D; 5; &#x2F;&#x2F; ERROR</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Form:<br>Type Name;</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用 &#x3D;  与C&#x2F;C++相同<br>Example:<br>String foo;<br>foo &#x3D; “IAP 6.092”;<br>double badPi &#x3D; 3.14;</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>与C&#x2F;C++完全一致<br>&#x3D; + - * &#x2F;(整数进行&#x2F;时同样是向下取整)<br><strong>注意： double b &#x3D; 5&#x2F;2; &#x2F;&#x2F; b &#x3D; 2.0</strong><br>优先级：括号 &gt; 乘除法 &gt; 加减法<br>也支持 +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; 等复合运算符</p><h3 id="字符串加法"><a href="#字符串加法" class="headerlink" title="字符串加法"></a>字符串加法</h3><p>String text &#x3D; “hello” + “world”;<br>text &#x3D; text + “number” + 5;<br>&#x2F;&#x2F; text &#x3D; “helloworldnumber5”;</p><h3 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h3><ul><li>强制类型转换 ： int a &#x3D; (int)18.7;</li><li>隐式类型转换 ：double a &#x3D; 2;&#x2F;&#x2F;2.0</li></ul><h3 id="Java的函数——Method"><a href="#Java的函数——Method" class="headerlink" title="Java的函数——Method"></a>Java的函数——Method</h3><p>Example:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NAME</span>()</span>&#123;<br>    STATEMENTS<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：NAME();</p><h4 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">NewLine</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newLine</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">threeLines</span>()</span>&#123;<br>        newLine();<br>        newLine();<br>        newLine();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] arguments</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;Line 1&quot;</span>);<br>        threeLines();<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;Line 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数参数Parameter"><a href="#函数参数Parameter" class="headerlink" title="函数参数Parameter"></a>函数参数Parameter</h4><p>Example:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-keyword">NAME</span>(<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    STATEMENTS</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>调用：<br>NAME(EXPRESSION);<br>Another Example:<br>多个参数</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-keyword">NAME</span>(<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>,<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    STATEMENTS</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Return-Values-返回值"><a href="#Return-Values-返回值" class="headerlink" title="Return Values 返回值"></a>Return Values 返回值</h4><p>Example：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TYPE <span class="hljs-title">NAME</span>()</span>&#123;<br>    STATEMENTS<br>    <span class="hljs-keyword">return</span> EXPRESSION;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IF-ELSE语句"><a href="#IF-ELSE语句" class="headerlink" title="IF ELSE语句"></a>IF ELSE语句</h3><p>Example:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(CONDITION)</span></span>&#123;<br>    STATEMENTS<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(CONDITION)&#123;<br>    STATEMENTS<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    STATEMENTS<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>x &gt; y  x &lt; y  x &gt;&#x3D; y x &lt;&#x3D; y  x&#x3D;&#x3D; y</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;&amp; ||</p>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maths-Analysis1</title>
    <link href="/2025/02/02/Maths-Analysis1/"/>
    <url>/2025/02/02/Maths-Analysis1/</url>
    
    <content type="html"><![CDATA[<h5 id="好消息：JaneZ开始学习数分了！-坏消息：JaneZ的数分要丸辣"><a href="#好消息：JaneZ开始学习数分了！-坏消息：JaneZ的数分要丸辣" class="headerlink" title="好消息：JaneZ开始学习数分了！ 坏消息：JaneZ的数分要丸辣"></a>好消息：JaneZ开始学习数分了！ 坏消息：JaneZ的数分要丸辣</h5><h2 id="Maths-Analysis-1-函数列与一致收敛性"><a href="#Maths-Analysis-1-函数列与一致收敛性" class="headerlink" title="Maths Analysis 1  函数列与一致收敛性"></a>Maths Analysis 1  函数列与一致收敛性</h2><h3 id="首先，给出函数列定义！"><a href="#首先，给出函数列定义！" class="headerlink" title="首先，给出函数列定义！"></a>首先，给出函数列定义！</h3><p><img src="/img/%E5%87%BD%E6%95%B0%E5%88%97%E5%AE%9A%E4%B9%89.png" alt="函数列定义"></p><h4 id="是不是很简单？让我们来看一个例子——经典-x-n"><a href="#是不是很简单？让我们来看一个例子——经典-x-n" class="headerlink" title="是不是很简单？让我们来看一个例子——经典 $x^n$"></a>是不是很简单？让我们来看一个例子——经典 $x^n$</h4><p><img src="/img/%E5%87%BD%E6%95%B0%E5%88%97%E4%BE%8B%E5%AD%90.png" alt="函数列例子"></p><h3 id="接着隆重推出：《一致收敛》"><a href="#接着隆重推出：《一致收敛》" class="headerlink" title="接着隆重推出：《一致收敛》"></a>接着隆重推出：《一致收敛》</h3><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%AE%9A%E4%B9%89.png" alt="一致收敛定义"></p><h4 id="看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白"><a href="#看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白" class="headerlink" title="看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白"></a>看上去有点绕啊？这跟函数列收敛有何区别？（鼠鼠菜菜不明白</h4><h4 id="哦菜菜鼠鼠似乎明白了些什么"><a href="#哦菜菜鼠鼠似乎明白了些什么" class="headerlink" title="哦菜菜鼠鼠似乎明白了些什么"></a>哦菜菜鼠鼠似乎明白了些什么</h4><h3 id="函数列收敛的-epsilon-N语言中，N与-epsilon-和x的取值皆有关，而一致收敛中的N只和-epsilon-有关-（回忆一下连续与一致连续）"><a href="#函数列收敛的-epsilon-N语言中，N与-epsilon-和x的取值皆有关，而一致收敛中的N只和-epsilon-有关-（回忆一下连续与一致连续）" class="headerlink" title="函数列收敛的$\epsilon$-N语言中，N与$\epsilon$和x的取值皆有关，而一致收敛中的N只和$\epsilon$有关 （回忆一下连续与一致连续）"></a>函数列收敛的$\epsilon$-N语言中，N与$\epsilon$和x的取值皆有关，而一致收敛中的N只和$\epsilon$有关 （回忆一下连续与一致连续）</h3><h4 id="接下来从几何上看看一致收敛"><a href="#接下来从几何上看看一致收敛" class="headerlink" title="接下来从几何上看看一致收敛"></a>接下来从几何上看看一致收敛</h4><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" alt="一致收敛几何意义"></p><h3 id="将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上"><a href="#将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上" class="headerlink" title="将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上"></a>将收敛自然绕不开柯西收敛准则，Cauchy依然可以推广到函数列一致收敛性上</h3><p><img src="/img/%E6%9F%AF%E8%A5%BF%E6%94%B6%E6%95%9B%E5%87%86%E5%88%99.png" alt="柯西收敛准则"></p><h4 id="证明还是很简单的"><a href="#证明还是很简单的" class="headerlink" title="证明还是很简单的"></a>证明还是很简单的</h4><h3 id="接下来看一个和上确界相关的定理及推论吧"><a href="#接下来看一个和上确界相关的定理及推论吧" class="headerlink" title="接下来看一个和上确界相关的定理及推论吧"></a>接下来看一个和上确界相关的定理及推论吧</h3><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%AE%9A%E7%90%86%E5%8F%8A%E6%8E%A8%E8%AE%BA.png" alt="一致收敛定理及推论"></p><h4 id="And-An-Example"><a href="#And-An-Example" class="headerlink" title="And An Example~"></a>And An Example~</h4><p><img src="/img/%E4%B8%80%E8%87%B4%E6%94%B6%E6%95%9B%E5%AE%9A%E7%90%86%E4%BE%8B%E5%AD%90.png" alt="一致收敛定理例子"></p><h5 id="JaneZ要做回数分皇帝😎😎😎（口嗨中）"><a href="#JaneZ要做回数分皇帝😎😎😎（口嗨中）" class="headerlink" title="JaneZ要做回数分皇帝😎😎😎（口嗨中）"></a>JaneZ要做回数分皇帝😎😎😎（口嗨中）</h5>]]></content>
    
    
    <categories>
      
      <category>Maths Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure2</title>
    <link href="/2025/02/01/Data-Structure2/"/>
    <url>/2025/02/01/Data-Structure2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-JaneZ非常讨厌LinkList，but-厌即是恋（-过年精神状态真是越来越好了，喝点儿中药吧-）"><a href="#Before-JaneZ非常讨厌LinkList，but-厌即是恋（-过年精神状态真是越来越好了，喝点儿中药吧-）" class="headerlink" title="Before: JaneZ非常讨厌LinkList，but: 厌即是恋（ 过年精神状态真是越来越好了，喝点儿中药吧 ）"></a>Before: JaneZ非常讨厌LinkList，but: 厌即是恋（ 过年精神状态真是越来越好了，喝点儿中药吧 ）</h5><h2 id="Data-Structure-2-链表-LinkList"><a href="#Data-Structure-2-链表-LinkList" class="headerlink" title="Data Structure 2 链表 LinkList"></a>Data Structure 2 链表 LinkList</h2><h3 id="线性链表的链接存储"><a href="#线性链表的链接存储" class="headerlink" title="线性链表的链接存储"></a>线性链表的链接存储</h3><ul><li>链接存储通过让每个结点保存与它有关系的结点的地址来保存结点之间的关系</li><li>线性表的链接存储是指将每个数据元素存放在一个独立的数据存储单元（结点）中</li><li>链表不需要事先准备空间，一般采用动态存储的方法</li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ul><li>每个结点存储一个数据元素和一个后继指针<br><img src="/img/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="单链表"></li><li>为防止忘记处理特殊情况，可以引入一个不存放数据的特殊结点——头结点（一种优化）<br><img src="/img/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="带头结点单链表"></li></ul><h4 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sLinkList</span>: <span class="hljs-keyword">public</span> list &lt;elemType&gt;&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>        elemType data;<br>        node *next;<br><br>        <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType&amp; x , node *n = <span class="hljs-literal">nullptr</span>)&#123;<br>            data = x;<br>            next = n;<br>        &#125;<br>        <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>node *head;<br><span class="hljs-type">int</span> currentLength;<br><span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sLinkList</span>();<br>    ~<span class="hljs-built_in">sLinkList</span>()&#123;<br>        <span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">delete</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单链表的运算实现"><a href="#单链表的运算实现" class="headerlink" title="单链表的运算实现"></a>单链表的运算实现</h4><ul><li>私有成员函数move的实现<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">node</span> *<span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">move</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>) <span class="hljs-symbol">const</span>&#123;<br>    node *p = head;<br>    <span class="hljs-keyword">while</span>( i -- &gt;= <span class="hljs-number">0</span>)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表构造函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">sLinkList</span>()</span>&#123;<br>    head = new node;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表清空函数<br><img src="/img/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B8%85%E7%A9%BA.png" alt="单链表清空操作"><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">clear</span>()</span>&#123;<br>    node *p = head-&gt;<span class="hljs-keyword">next</span>;<br>    node *<span class="hljs-keyword">q</span>;<br>    head -&gt; <span class="hljs-keyword">next</span> = nullptr;<br>    <span class="hljs-keyword">while</span>(p != nullptr)&#123;<br>        <span class="hljs-keyword">q</span> = p -&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = <span class="hljs-keyword">q</span>;<br>    &#125;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表插入删除函数<br><img src="/img/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.png" alt="单链表删除操作"><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">insert</span>(<span class="hljs-title">int</span> <span class="hljs-title">i</span> ,<span class="hljs-title">const</span> <span class="hljs-title">elemType</span> &amp;<span class="hljs-title">x</span>)</span>&#123;<br>    node *<span class="hljs-keyword">pos</span>;<br>    <span class="hljs-keyword">pos</span> = move(i - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span> = new node(<span class="hljs-keyword">x</span> ,<span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span>);<br>    ++ currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">remove</span>(<span class="hljs-title">int</span> <span class="hljs-title">i</span>)</span>&#123;<br>    node *<span class="hljs-keyword">pos</span>;<br>    node *delp;<br>    <span class="hljs-keyword">pos</span> = move(i - <span class="hljs-number">1</span>);<br>    delp = <span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span>;<br>    <span class="hljs-keyword">pos</span> -&gt; <span class="hljs-keyword">next</span> = delp -&gt; <span class="hljs-keyword">next</span>;<br>    <span class="hljs-keyword">delete</span> delp;<br>    -- currentLength;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单链表search visit traverse函数的实现<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">search</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span> &amp;<span class="hljs-symbol">x</span>) <span class="hljs-symbol">const</span>&#123;<br>    node *p = head -&gt; next;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>ptr &amp;&amp; p -&gt; data != x)&#123;<br>        p = p -&gt; next;<br>        ++ i;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">null</span>ptr)&#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">sLinkList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">visit</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>) <span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> move(i) -&gt; data;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sLinkList</span>&lt;<span class="hljs-title">elemType</span>&gt;::<span class="hljs-title">traverse</span>() <span class="hljs-title">const</span></span>&#123;<br>    node *p = head -&gt; <span class="hljs-keyword">next</span>;<br>    <span class="hljs-keyword">while</span>(p != nullptr)&#123;<br>        cout &lt;&lt; p -&gt; data &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p = p -&gt; <span class="hljs-keyword">next</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="JaneZ发烧了，各位注意身体啊"><a href="#JaneZ发烧了，各位注意身体啊" class="headerlink" title="JaneZ发烧了，各位注意身体啊!"></a>JaneZ发烧了，各位注意身体啊!</h5>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure1</title>
    <link href="/2025/01/29/Data-Structure1/"/>
    <url>/2025/01/29/Data-Structure1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS-启动！"><a href="#Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS-启动！" class="headerlink" title="Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS , 启动！"></a>Before：JaneZ决定早点开始DS的学习（虽然可能已经不算早了呜呜呜），所以：DS , 启动！</h5><h2 id="Data-Structure-1-线性表List"><a href="#Data-Structure-1-线性表List" class="headerlink" title="Data Structure 1 线性表List"></a>Data Structure 1 线性表List</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><ul><li>线性结构的定义：所有结点按一对一的邻接关系构成的整体就是线性结构</li><li>线性表是处理线性结构的数据结构</li><li>线性表中数据元素的个数称为线性表的长度</li></ul><h4 id="线性表的基本运算："><a href="#线性表的基本运算：" class="headerlink" title="线性表的基本运算："></a>线性表的基本运算：</h4><ul><li>创建空线性表 create</li><li>删除线性表中所有数据元素 clear</li><li>求长度 length</li><li>插入元素 insert</li><li>删除元素 remove</li><li>搜索元素 search</li><li>返回特定位置元素值 visit</li><li>按序访问每一数据元素 traverse</li></ul><h4 id="线性表的抽象类"><a href="#线性表的抽象类" class="headerlink" title="线性表的抽象类"></a>线性表的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span> ; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span> <span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>; <br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp;x)</span><span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">list</span>()&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="线性表的顺序实现"><a href="#线性表的顺序实现" class="headerlink" title="线性表的顺序实现"></a>线性表的顺序实现</h3><ul><li>将线性表的数据元素存储在一块连续的空间里，用存储位置反映数据元素间的关系<br><img src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="顺序表存储结构"></li></ul><h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><ul><li>从线性表的抽象类list公有派生<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqList</span>: <span class="hljs-keyword">public</span> list &lt;elemType&gt;&#123;<br><br>    <span class="hljs-keyword">private</span>:<br><br>        elemType *data;<br>        <span class="hljs-type">int</span> currentLength;<br>        <span class="hljs-type">int</span> maxSize;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br><br>        <span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);<br>        ~<span class="hljs-built_in">seqList</span>();<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">const</span> elemType&amp; x)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType&amp; x)</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="顺序表实现"><a href="#顺序表实现" class="headerlink" title="顺序表实现"></a>顺序表实现</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">seqList</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">initsize</span>)&#123;<br>    data = new elemType[initsize];<br>    maxsize = initsize;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elemType</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">seqList</span>&lt;<span class="hljs-title">elemType</span>&gt;::~<span class="hljs-title">seqList</span>()</span>&#123;<br>    <span class="hljs-keyword">delete</span> []data;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">clear</span>()&#123;<br>    currentLength = <span class="hljs-number">0</span>;<br>&#125;<br>(是个伪清除)<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">length</span>()&#123;<br>    <span class="hljs-keyword">return</span> currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">int</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">search</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">elemType</span>&amp;<span class="hljs-symbol">x</span>)<span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; currentLength &amp;&amp; data[i] != x; i ++);<br>    <span class="hljs-keyword">if</span>(i == currentLength)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> i; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">elemType</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">visit</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>)<span class="hljs-symbol">const</span>&#123;<br>    <span class="hljs-keyword">return</span> data[i];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">traverse</span>()<span class="hljs-symbol">const</span>&#123;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; currentLength; i ++)&#123;<br>        cout &lt;&lt; data[i]&lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单独讨论插入删除函数"><a href="#单独讨论插入删除函数" class="headerlink" title="单独讨论插入删除函数"></a>单独讨论插入删除函数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">doubleSpace</span>()&#123;<br>    elemType *tmp = data;<br>    maxSize *= <span class="hljs-number">2</span>;<br>    data = new elemType[maxSize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; currentLength; i ++)&#123;<br>        data[i] = tmp[i];<br>    &#125;<br>    delete []tmp;<br>&#125;<br><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">insert</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i,<span class="hljs-symbol">const</span></span> <span class="hljs-symbol">elemType</span>&amp; <span class="hljs-symbol">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(currentLength == maxSize)&#123;<br>        <span class="hljs-built_in">double</span>Space();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = currentLength; j &gt; i ; j --)&#123;<br>        data[j] = data[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    data[i] = x;<br>    ++ currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">elemType</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">seqList</span>&lt;<span class="hljs-symbol">elemType</span>&gt;::<span class="hljs-symbol">remove</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">i</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i;j &lt; currentLength - <span class="hljs-number">1</span>; j ++)&#123;<br>        data[j] = data[j + <span class="hljs-number">1</span>];<br>    &#125;<br>    -- currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Before Everything</title>
    <link href="/2025/01/21/Before-Everything/"/>
    <url>/2025/01/21/Before-Everything/</url>
    
    <content type="html"><![CDATA[<h1>Before Everything 前言</h1><p>By JaneZ,2025.1.21,M Stand Coffee,Nanjing<br>Well, hello world ! This is the owner of this crazy blog ! My name is JaneZ , a student from <a href="https://www.sjtu.edu.cn/">Shanghai Jiaotong University</a>.I major in <strong>Computer Science</strong> of the <a href="https://acm.sjtu.edu.cn/home">ACM Class</a>.I’m an ENFJer or INFJer, so I really want to know more people with the same interests.<br><strong>Why I start this blog ?</strong><br>Well, partly motivated by my high school classmate <a href="https://github.com/xiyuanyang-code">Xiyuan Yang</a>, who majors in <a href="https://soai.sjtu.edu.cn/">Artificial Intelligence</a> also in SJTU( thanks for the help). I think it’s mainly because that after a whole semester learning in the ACM class , I didn’t actually adapt to university life that well .<br>So I hope to be more proactive in my learning through this blog.</p><p>My blog (personal homepage) uses the <a href="https://hexo.io/zh-cn/">Hexo</a> Fluid theme, where I mainly share notes from my daily studies, learning insights, and some beautiful quotes.Welcome to my blog if you’re interested in <strong>Maths,Physics,Artificial Intelligence,Computer Graphics and so on</strong>! If you have any questions about configuring or deploying a Hexo blog, feel free to ask me. I’ve encountered some pitfalls myself, and I hope no one else has to fall into them.<br>Any way,let’s get started.<br>Attach a picture of this wonderful coffee shop!<br><img src="/img/MStandCoffee.png" alt="M Stand Coffee"></p><p>Can’t live without coffee … ？<br>Upd: Something bad happens.Bye Coffee😢</p>]]></content>
    
    
    
    <tags>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
