<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JaneZ&#39;s Arch and Compiler</title>
    <link href="/2025/08/05/Arch-Compiler/"/>
    <url>/2025/08/05/Arch-Compiler/</url>
    
    <content type="html"><![CDATA[<h1>Arch &amp; Compiler</h1><p>此楼用于记录JaneZ 在暑假学期7-10周Arch课程和Compiler项目的学习，Arch课程的学习资料已开源，可参考。战Arch，战编译，启动！</p><h3 id="8-4-Day-0">8-4 Day 0</h3><ul><li>学习了SJTU 编译原理Lecture2-3，Compiler Pipeline 逐渐清晰，大概知道了Semantic需要做哪些事</li><li>重开了Arch w1d2</li></ul><h3 id="8-5-Day-1">8-5 Day 1</h3><ul><li>学了超前进位加法器，写了但没写完，对这个东西比较焦虑😇</li><li>对compiler处于一种无从下手的状态，一切都是如此莫名其妙，对这个东西也比较焦虑😇</li><li>对Arch课进度感到焦虑😇</li></ul><p>一天唯一的解压方式或许是晚上听xjq 骂造她黄谣的人 😅</p><h3 id="8-6-Day-2">8-6 Day 2</h3><ul><li>开始了compiler，Go for it!</li><li>写完C-Python FFI</li></ul><h3 id="8-7-Day-3">8-7 Day 3</h3><ul><li>今天大概只能做完tokenize了，下午讨论了一下，也了解了一下kotlin，最后还是决定用cpp写了，感觉还是挺好写的，cpp唯一的缺点应该在手动内存管理上，又是头疼的leak环节</li><li>对系统课产生了极大的怀疑，不理解这门课的教学方式和培养计划，很多东西还是靠自己学比较好</li><li>渐渐进入了学习状态</li></ul><h3 id="8-8-Day-4">8-8 Day 4</h3><ul><li>效率还可以的一天，lexer 写了一部分，争取这周末开始parser，享受写编译器的过程</li><li>Parsifal 回家前的最后一天，明天将开启为期两周的异地😢 希望他玩得开心，好好放松一下🥰</li><li>玉川是唯一的神，捞到满绩了✋😭✋ 我们拥护这个大主教</li></ul><h3 id="8-9-Day-5">8-9 Day 5</h3><ul><li>lexer很有进展，明天应该能搞定，希望能快速调完进入parser，唉又是个心腹大患</li><li>送Parsifal 回长沙，感觉现在每两周就要去一次虹桥🤣 他在高铁上喝果酒看电影，我在寝室喝无糖苏打水敲代码😅</li><li>去深夜食堂吃了晚饭，鹅肝和没沾酱油的三文鱼都有点腻，茶泡饭第一次尝试，有点儿酸（？）不过代价是明天中午吃沙拉晚上吃空气</li></ul><h3 id="8-10-Day-6">8-10 Day 6</h3><ul><li>狂写lexer，确实差不多了，放弃用正则表达式匹配，选择字符串暴力匹配</li><li>换了几个地方自习，发现还是寝室效率高，喜欢阴暗coding</li><li>和npy又聊了聊盖茨比，想了一些以前没想过的事，挺好</li></ul><h3 id="8-11-Day-7">8-11 Day 7</h3><ul><li>lexer搞定，一天又怒写500行代码，拿几个简单的程序调了调，开始构思parser了，进度慢慢的，but 感觉或许来得及😢</li><li>晚上吃的魔芋，油醋汁加多了，没吃几口扔了，又啃了一块鸡胸，喝了点牛奶，感觉今天热量还是超标了，明天可能需要液断一下（</li><li>得知下一届泥A来了6个学妹，还有这种好事😋 摆子学姐已经开始约寝室掼蛋局了</li><li>昨天电话打到很晚，导致早上起迟了，不知是否和blueglass有关，今天一天都头疼，像是细菌感染了，看明天身体状况吧</li></ul><h3 id="8-12-Day-8">8-12 Day 8</h3><ul><li>看了看SJTU 编译原理相关章节，学习ing</li></ul><h3 id="8-13-Day-9">8-13 Day 9</h3><ul><li>看Pratt Parsing 知乎文章，搞懂了Parser</li><li>构建了所有ASTNode的框架，堆屎山，具体内容一点没有</li></ul><h3 id="8-14-Day-10">8-14 Day 10</h3><ul><li>继续working on Parser，很不理解这一切😇😇😇</li><li>讨论了一下，大概知道了一切，但是依然不知何从下手，面向对象学的太差导致的😇😇😇</li></ul><h3 id="8-15-Day-11">8-15 Day 11</h3><ul><li>效率很低很低，越着急越写不出来，感觉这不是很难写的东西😇</li></ul><h3 id="8-16-Day-12">8-16 Day 12</h3><ul><li>Jessica 来上海，接待她老人家，吃两顿高热量的饭，下周要绝食了</li><li>包图还是挺适合学习的，就是偶遇了Juh（</li></ul><h3 id="8-17-Day-13">8-17 Day 13</h3><ul><li>中午又和Jessica 吃了一顿，热量炸，晚上又不吃饭了（）</li><li>包图赶Compiler，偏头痛发作，快死了，真的是濒死体验（</li></ul><h3 id="8-18-Day-14">8-18 Day 14</h3><ul><li>进度还行，主图学习，继续顶着头痛赶进度…</li></ul><h3 id="8-19-Day-15">8-19 Day 15</h3><ul><li>效率蛮不错的一天，parser进展不错，估计周五前能全搞定开始semantic check</li></ul><h3 id="8-20-Day-16">8-20 Day 16</h3><ul><li>Parser进度很不错，但真可惜的一点在于，parser估计要这周末才能结束了😇 函数参数列表的解析是真恶心，写了一整个晚上</li><li>早起有早起的好处🥰 我要天天早起！</li></ul><h3 id="8-21-Day-17">8-21 Day 17</h3><ul><li>基本写完了递归下降parser，明天开始Pratt Parsing，效率挺好，一切都在往好的方向发展（吗）</li><li>我觉得有必要写写东西。今天他问我，是什么时候开始觉得他对我有意思的。我当时的答复并不是很满意，缺一点诚心和逻辑，有些说法并不准确。都是理工科的学生，都喜欢严谨的逻辑论证，所以打算晚上写点东西，让这段感情有一个明白的开始。我觉得和他的相处越来越走向正轨，有了很多两个人共同work &amp; study 的时间。受过往感情经历的影响，我觉得拥有一段健康的关系是我一直期待的。后面可能也会在楼里讲一讲高中的事情吧。一直觉得文字是一种特别好的表达方式。</li><li>下周二生日，那天晚上出血1500，请Alice.Emptyterrian.Guitarhero.Granthy 四个人米其林去🥰</li></ul><p>推歌：白羊 ————徐秉龙、沈以诚  今天下午一直在单曲循环，想到2024.12.31，Rico 和小猫玛奇朵唱的这首歌。转眼已是大半年。<br>多热烈的白羊 多善良多抽象 多完美的她呀 却是下落不详 心好空荡 都快要失去形状<br>青春一记荒唐 亦然学着疯狂 这声色太张扬 这欢愉太理想 先熄灭心跳 才能拥抱</p><p>如果我写了一段我认为满意的答案，我会把答案贴在楼里，留下一点今生今世的证据</p><h3 id="8-22-Day-18">8-22 Day 18</h3><ul><li>又读了一遍知乎文章，开始了Pratt Parser，感觉还好，似乎可以战胜（吗）</li><li>出现了一点小问题，也没有想过会是这个问题，因为前两段感情并没有类似的经历。和几个close friends聊了一下这件事，最后决定跟他把话说开了，效果很好。具体什么问题后面可能会写写，这两天比较忙没空了（）</li></ul><h3 id="8-23-Day-19">8-23 Day 19</h3><ul><li>Perfect Day! 推进很不错，ci也搞好了，单元测试脚本还没写，不过不急</li><li>明天一起去看电影（虽然是动画片😆</li><li>有些事情说明白了，后面的相处就会好很多。这是过往教会我的，我把经验用在当下。</li></ul><h3 id="8-24-Day-20">8-24 Day 20</h3><ul><li>坏蛋联盟还挺好看的（</li><li>娃娃机这个东西天生就克我😅</li></ul><h3 id="8-25-Day-21">8-25 Day 21</h3><ul><li>出现了一些误会和矛盾，但还是解决了</li><li>写了一点东西，犹豫一下要不要哈希一下放上来😆</li></ul><h3 id="8-26-Day-22-🎂🎂🎂">8-26 Day 22 🎂🎂🎂</h3><ul><li>生日！！！</li><li>逸道还是很好吃的，服务也不错，就是不如新荣记的菜品介绍，也没那么精致，还是喜欢新荣记😇😇😇</li><li>和几个朋友在夜晚没什么人的黄浦街头压马路，随手拍了个背影，总觉得是我想象中的young and freedom</li><li>人生中第一枚属于自己的戒指（以前戴的属于谁显而易见）❤️❤️❤️ Love is all you need.</li><li>Rico送了1989专辑，当晚Taylor就订婚了😭😭😭😭😭</li></ul><p>Can’t you see that I’m the one who understands you<br>Been here all along, so why can’t you see?<br>You belong with me<br>Standing by and waiting at your back door<br>All this time, how could you not know, baby?<br>You belong with me, you belong with me</p><h3 id="8-27-Day-23">8-27 Day 23</h3><ul><li>写代码，parser基本结束了，估计不会开始semantic check了</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PerlinNoise</title>
    <link href="/2025/07/19/PerlinNoise/"/>
    <url>/2025/07/19/PerlinNoise/</url>
    
    <content type="html"><![CDATA[<h1>Perlin Noise</h1><h2 id="起因">起因</h2><p>隔壁班PPCA的小作业，感觉挺有意思，遂玩玩。室友说很无聊，全是调参，且渲染对电脑配置有一定要求，X1 carbon的不好之处在dht并发爆炸后越来越明显，且我忘了我把MC下在C盘哪里了，故选择不写，但可以学习一下。</p><h2 id="柏林噪声">柏林噪声</h2><p>为所有整数点随机生成一个梯度，每个采样点的噪声值即为所有相邻角点的梯度向量与指向向量的点积之和</p><p><img src="/img/Perlin.png" alt="Perlin Noise"></p><p>的确保证了采样点<strong>变化的连续性</strong>和<strong>随机性</strong></p><h2 id="Naive-平滑地形生成">Naive: 平滑地形生成</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">BlockState <span class="hljs-title">getBlock</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x,<span class="hljs-built_in">int</span> y,<span class="hljs-built_in">int</span> z</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> surfaceY = <span class="hljs-number">100</span> + noise.sample2d(x,z) * <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">return</span> (y &lt; surfaceY) ? STONE:AIR;<br>&#125;<br></code></pre></td></tr></table></figure><p>加入随机性的方法：地形叠加 octaves</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">final int octaves <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-comment">;</span><br>PerlinNoise noise <span class="hljs-operator">=</span> new PerlinNode(octaves)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="Continentalness-大陆性">Continentalness 大陆性</h2><ul><li>负值(-1,0)：生成更多的海洋，陆地面积减少，形成更多分散的岛屿。</li><li>正值(0,1)：生成更大的陆地块，海洋面积减少，世界看起来更像一个或几个巨大的大陆。</li></ul><p>我们构建一个柏林噪声到Continentalness值的映射，由于在Naive中我们讨论了柏林噪声可以保证地形的平滑性，所以这里到Continentalness的映射可以采用线性映射来保序（如归一化）</p><h2 id="Terrian-Height">Terrian Height</h2><p>构建一个Continentalness到Terrian Height的映射</p><p>可以不断指定更多点的具体值，不断调参。</p><p>函数的返回值可以是一个函数！生成三个独立的噪声，上一层噪声值决定下一层中，噪声转为（函数/高度）的函数</p><h2 id="三维噪声">三维噪声</h2><p>比如一种思想：如果把噪声值作为“ 密度 ” 。当密度为负，设为空气，否则设为石头</p><p><strong>我们得到了一个带有中空的，奶酪似的世界地形！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>PPCA</tag>
      
      <tag>Perlin Noise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proxy</title>
    <link href="/2025/07/15/Proxy/"/>
    <url>/2025/07/15/Proxy/</url>
    
    <content type="html"><![CDATA[<h1>Proxy Server 代理服务器</h1><h2 id="Basic">Basic</h2><ul><li>Define：代理服务器是位于客户端和目标服务器之间的中间服务器。</li><li>Func：隐藏真实IP、加速访问、访问限制内容、过滤内容</li></ul><h2 id="Socket-Secure-5">Socket Secure 5</h2><ul><li>Socks5 是一个万能的中间人代理协议，可以绕过防火墙、隐藏 IP、访问受限内容，并支持更广泛的网络应用</li><li>支持 TCP 和 UDP，比 HTTP 代理更强大</li><li>TCP：传输控制协议（可靠但慢）三次握手协议 ACK数据确认 belike 打电话</li><li>UDP：用户数据报协议（快但不可靠）不建立连接，直接“扔包” belike 发短信</li><li>本协议旨在为基于 TCP 和 UDP 的客户端-服务器应用程序提供一种方便且安全地使用防火墙服务的机制</li><li>介于应用层与传输层之间的“中间层”</li></ul><h2 id="代理客户端">代理客户端</h2><p>在我们的简单代理服务器中, 用户请求的所有流量都会直接从服务器所在的机器发出:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">+---------+   +--------------+   +----------+<br>| <span class="hljs-type">User</span> -&gt;-+---+-&gt; <span class="hljs-type">Proxy</span> <span class="hljs-number">1</span> -&gt;-+---+-&gt; <span class="hljs-type">Server</span> |<br>+---------+   +--------------+   +----------+<br></code></pre></td></tr></table></figure><p>你也可以让流量经过另一台 socks5 代理服务器:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">+---------+   +--------------+   +--------------+   +----------+<br>| <span class="hljs-type">User</span> -&gt;-+---+-&gt; <span class="hljs-type">Proxy</span> <span class="hljs-number">1</span> -&gt;-+---+-&gt; <span class="hljs-type">Proxy</span> <span class="hljs-number">2</span> -&gt;-+---+-&gt; <span class="hljs-type">Server</span> |<br>+---------+   +--------------+   +--------------+   +----------+<br></code></pre></td></tr></table></figure><p>为此, 你需要在 Proxy 1 上实现一个 socks5 代理客户端。这个客户端会将 socks5 请求重新包装成 socks5 请求并发送给 Proxy 2。</p><h2 id="Procedure-for-TCP-based-Clients">Procedure for TCP-based Clients</h2><p>当一个基于 TCP 的客户端希望建立连接，而目标对象只能通过防火墙访问（具体如何判断由实现决定），它必须向 SOCKS 服务器的指定端口（默认是 TCP 端口 1080）建立一个 TCP 连接。</p><p>如果连接成功，客户端接下来将发起 认证方法协商，完成认证过程后发送中继请求。SOCKS 服务器评估请求，然后决定是否建立连接或拒绝请求。</p><p>客户端首先向服务器发送一个“版本标识/方法选择”报文：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>----------<span class="hljs-code">+----------+</span><br><span class="hljs-section">|VER | NMETHODS | METHODS  |</span><br><span class="hljs-section">+----+----------+----------+</span><br>| 1  |    1     | 1 到 255 |<br></code></pre></td></tr></table></figure><p>rmk:这是字节数</p><ul><li>VER：设置为 X’05’，表示协议版本 5；</li><li>NMETHODS：表示 METHODS 字段中包含的认证方法数量；</li><li>METHODS：列出客户端支持的认证方法。</li></ul><p>服务器收到后，从 METHODS 中选择一种方法，并返回如下回应：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>--------+<br><span class="hljs-section">|VER | METHOD |</span><br><span class="hljs-section">+----+--------+</span><br>| 1  |   1    |<br></code></pre></td></tr></table></figure><h2 id="请求格式">请求格式</h2><p>一旦方法协商完成，客户端发送具体请求。若认证方法提供完整性校验或加密功能，请求数据需使用该方法进行封装<br>SOCKS 请求报文格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-----+-------+------+----------+----------+<br>|<span class="hljs-string">VER </span>|<span class="hljs-string"> CMD </span>|<span class="hljs-string">  RSV  </span>|<span class="hljs-string"> ATYP </span>|<span class="hljs-string"> DST.ADDR </span>|<span class="hljs-string"> DST.PORT </span>|<br>+----+-----+-------+------+----------+----------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string">  1  </span>|<span class="hljs-string">  X&#x27;00&#x27;</span>|<span class="hljs-string">  1   </span>|<span class="hljs-string"> Variable </span>|<span class="hljs-string">    2     </span>|<br></code></pre></td></tr></table></figure><ul><li>VER：协议版本，固定为 X’05’</li><li>CMD：命令类型</li><li>RSV：保留字段，必须为 X’00’</li><li>ATYP：目标地址类型</li><li>DST.ADDR：目标地址（根据 ATYP 类型解析）</li><li>DST.PORT：目标端口（2 字节，网络字节序）</li></ul><h2 id="Addressing">Addressing</h2><p>ATYP 字段</p><ul><li>X’01’：IPv4 地址（长度为 4 字节）</li><li>X’03’：域名（首字节为长度，后面为域名字符串）</li><li>X’04’：IPv6 地址（长度为 16 字节）</li></ul><h2 id="Replies">Replies</h2><p>客户端发送完请求并完成认证后，服务器评估请求并返回回复报文：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+-----+-------+------+----------+----------+<br>|<span class="hljs-string">VER </span>|<span class="hljs-string"> REP </span>|<span class="hljs-string">  RSV  </span>|<span class="hljs-string"> ATYP </span>|<span class="hljs-string"> BND.ADDR </span>|<span class="hljs-string"> BND.PORT </span>|<br>+----+-----+-------+------+----------+----------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string">  1  </span>|<span class="hljs-string"> X&#x27;00&#x27; </span>|<span class="hljs-string">  1   </span>|<span class="hljs-string"> Variable </span>|<span class="hljs-string">    2     </span>|<br></code></pre></td></tr></table></figure><ul><li>VER：协议版本（X’05’）</li><li>REP：回复状态码</li><li>RSV：保留字段，必须为 X’00’</li><li>ATYP：BND.ADDR 的类型</li><li>BND.ADDR：服务器绑定的地址</li><li>BND.PORT：服务器绑定的端口</li></ul><h2 id="Procedure-for-UDP-based-clients">Procedure for UDP-based clients</h2><p>原本的UDP 协议并不会对数据进行封装，而是选择发一包就走。Socks协议为了穿越防火墙，就会对这些数据进行封装</p><p>基于 UDP 的客户端必须将数据发送至 UDP <strong>中继服务器</strong>（UDP relay server），目标端口即为前面 UDP ASSOCIATE 请求的回复中所返回的 BND.PORT</p><p>UDP 数据报请求头格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----+------+------+----------+----------+----------+<br>|<span class="hljs-string">RSV </span>|<span class="hljs-string"> FRAG </span>|<span class="hljs-string"> ATYP </span>|<span class="hljs-string"> DST.ADDR </span>|<span class="hljs-string"> DST.PORT </span>|<span class="hljs-string">   DATA   </span>|<br>+----+------+------+----------+----------+----------+<br>|<span class="hljs-string">  2 </span>|<span class="hljs-string">   1  </span>|<span class="hljs-string">  1   </span>|<span class="hljs-string"> Variable </span>|<span class="hljs-string">    2     </span>|<span class="hljs-string"> Variable </span>|<br></code></pre></td></tr></table></figure><ul><li>RSV（2 字节）：保留字段，必须为 0x0000</li><li>FRAG（1 字节）：分片编号（fragment number）</li><li>ATYP（1 字节）：地址类型</li><li>DST.ADDR：目标地址（根据 ATYP 类型变化）</li><li>DST.PORT：目标端口（2 字节，网络字节序）</li><li>DATA：用户数据</li></ul><p><strong>中继服务器的行为：</strong></p><ul><li>当 UDP 中继服务器决定转发一个datagram时，它不会通知客户端；</li><li>无法转发的datagram将被静默丢弃；</li><li>服务器从远程主机收到回复datagram时，必须使用以上格式封装datagram并返回客户端；</li><li>中继服务器必须事先知道客户端的 IP 地址（通过 TCP 控制连接获得）；</li><li>对于任何非预期来源（即 IP 地址不匹配的客户端）发送的 UDP datagram，必须丢弃。</li></ul><p><strong>关于FRAG：</strong></p><ul><li>FRAG 字段用于表示该数据报是否是分片序列的一部分；</li><li>0x00 表示 非分片独立数据报；</li><li>值在 1 到 127 之间表示在一个分片序列中的位置；</li><li>实现必须有一个重组队列（reassembly queue）和重组计时器（reassembly timer）来处理分片；</li><li>一旦超时或收到更早序号的分片，则必须丢弃当前所有分片；</li><li>重组计时器的最小时间为5秒；</li><li>建议尽量避免使用分片；</li><li>如果不支持分片，收到 FRAG != 0x00 的数据报必须直接丢弃。</li></ul><p><strong>关于缓冲区空间报告：</strong><br>SOCKS 协议中对 UDP 报文进行封装，因此可用的应用层缓冲区比实际系统缓冲区要小：</p><ul><li>ATYP 是 0x01（IPv4） ⇒ 少 10+认证封装 字节；</li><li>ATYP 是 0x03（域名） ⇒ 少 262+认证封装 字节；</li><li>ATYP 是 0x04（IPv6） ⇒ 少 20+认证封装 字节。</li></ul><p>也就是说，应用程序可用的 UDP 空间 小于系统提供的实际空间，必须预留封装用头部空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PPCA</tag>
      
      <tag>Proxy</tag>
      
      <tag>Network</tag>
      
      <tag>TCP</tag>
      
      <tag>UDP</tag>
      
      <tag>Socks5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JaneZ&#39;s PPCA</title>
    <link href="/2025/06/23/JaneZ-s-PPCA/"/>
    <url>/2025/06/23/JaneZ-s-PPCA/</url>
    
    <content type="html"><![CDATA[<h1>JaneZ’s PPCA</h1><h3 id="开一个楼-，用于记录PPCA每天的多线程，消解没有暑假的哀愁😢">开一个楼 ，用于记录PPCA每天的多线程，消解没有暑假的哀愁😢</h3><h3 id="6-23-Day-0">6-23 Day 0</h3><ul><li>选了DHT(Distributed Hash Table)，也是很早之前就计划好的，虽然早上差一点被Raft动摇了，但还是决定写一个比较top-level的东西</li><li>PPCA的好处就是可以戴耳机写代码，0人管你，爽听6小时歌😆 又爱上我霉了🥰 吉他调音成功！</li><li>主要的进展是学习了Go基本语法，goroutine并发编程，RPC 远程过程调用，指路：<a href="https://go.dev/tour/list">A Tour of Go</a>，<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-06-goroutine.html">Goroutine</a>，<a href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">RPC</a>，并发真是一个很妙的东西</li></ul><p>看到隔壁Rico在推歌，也推一首今天听的最多的歌吧：<a href="https://y.qq.com/n/ryqq/songDetail/0013TCdl37SVzP">Cruel Summer -Taylor Swift</a></p><h3 id="6-24-Day-1">6-24 Day 1</h3><ul><li>RPC 又学习了一遍，感觉跨语言那块并没有搞懂😢 不过目前看上去并不会用到？</li><li>node.go 代码看完，真的很naive了😆</li><li>读了一个佬的<a href="https://luyuhuang.tech/2020/03/06/dht-and-p2p.html">blog</a>，搞明白了P2P和传统中央处理器的区别😁</li><li>研究了很久Chord 的想法和实现，<a href="https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf">Paper</a>看晕了，但发现<a href="https://zhuanlan.zhihu.com/p/53711866">知乎小文章</a>讲的还挺清楚。</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/001Au6Iw15kRp6">exile -Taylor Swift</a><br>感觉Go是目前学过所有语言中最有意思的了</p><h3 id="6-25-Day-2">6-25 Day 2</h3><ul><li>继续写chord，有点被RPC绕晕了😵 好绕啊</li><li>机考5小时！汇编还是太有意思了，虽然很唐的被格式问题卡了1小时🤣 然后不得不半小时狂砍10万分</li><li>机考听了5个小时霉，快听晕了，下次机考绝对不只听一个歌手的歌了</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/003BabiX0xmJoB">California -Lana Del Rey</a></p><h3 id="6-26-Day-3">6-26 Day 3</h3><ul><li>狂写chord，太有意思了（虽然still have a long way to go），摸索了很久才终于理清楚逻辑😇 但感觉写完会收获很大🤩</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/000yWJw73DGoep">When You’re Gone -Avril Lavigne</a></p><h3 id="6-27-Day-4">6-27 Day 4</h3><ul><li>chord充满了进展，快写完了，还差一点“ 优雅地quit ”和备份数据的更新（这是真有点儿不会了😅）Anyway，感觉上手了，写起来还是很有意思的</li><li>和学长聊天，才发现原来并不是DHT有多好写，而是本组捐购太多😨</li><li>数分出分，估计确定要资格审查了吧😆 果然期中再高也救不了炸了的期末😢 来人救我绩点吧😇 虽然说已经看淡分数了（）</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/001Bbywq2gicae">搁浅 -Jay Chou</a> 一听搁浅就破防，所有人都要move on💪</p><h3 id="6-28-Day-5">6-28 Day 5</h3><ul><li>Weekend finally comes! 点了青青糯山强迫自己早起，感觉没有传说中那么恶心？（可能是因为我点什么都不另外加糖？</li><li>又战了一天chord，写完！开始艰难but funny的debug环节（第一次用log debug，太酷辣）感谢学长解决了一个困扰了我几个小时的问题🥰</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/0047VaRJ4Ov6LR">I DO -911</a></p><h3 id="6-29-Day-6">6-29 Day 6</h3><ul><li>调chord，感觉逐渐摸索清除了log 调试的机制，比我想象中要好调一些（真的吗）</li><li>分似乎出完了？相较于上学期也算是稳定进步了吧（）虽然感觉期末运气很不好，几门课的分数都低于预期，某些科目存在不小的遗憾（比如ML，MA 和 DS）但至少人是在进步的吧🥰 感觉这个学期本就不是很利于我，遇到了2门我很不擅长（甚至于说很不喜欢）的课，时间也没有all in GPA，而是投入到了一些更感兴趣的方向的探索和一些热爱的事物上，总的来讲这学期过的还是很开心的！也非常感谢这学期让我坚定了绝不做TCS的信念🤣 有空可能会出一期学期小结吧（等yyu先布置）</li><li>Anyway，让我们庆祝在ACM班完整地活过了一年！</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/0043EX2e2F6JCA">STAY -The Kid LAROI /Justin Bieber</a></p><h3 id="6-30-Day-7">6-30 Day 7</h3><ul><li>（早些时候）问了学长一些问题，终于弄清楚了之前的一些困惑，Awesome！学长tql🥰</li><li>调chord出现了较大的进展，从跑不动到error rate 0.3669😅 目前怀疑可能是Quit写挂了，再议吧（）你最好明天乖乖过😡</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/000BiCA30oX60t">Maps - Maroon 5/Big Sean</a></p><h3 id="7-1-Day-8">7-1 Day 8</h3><ul><li>依然在de chord，出现了（严重的）死锁😅 调的很崩溃，目前虽然过了Basic Test，但处于一个薛定谔的能过（）</li><li>xhs 清空粉丝计划正在有条不紊地进行😋</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/004bEn504X4i8M">Yesterday -The Beatles</a><br>另附：Starbucks 巧克力星冰乐就是史</p><h3 id="7-2-Day-9">7-2 Day 9</h3><ul><li>过了chord，早上2点左右de出来了一个读写锁问题，10点多de出来了一个前驱未更新，DHT Half</li><li>我恨CTF，什么鬼东西，很难评了，ADHD根本看不下去字😅 跟tm猜谜一样，我真的不懂也不想懂那些很奇怪的cpp用法😅</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/0048kYDG2y3yJ9">Lucky Strike -Maroon 5</a></p><h3 id="7-3-Day-10">7-3 Day 10</h3><ul><li>读了一上午Kademlia的文献，感觉这两篇比较明白：<a href="https://luyuhuang.tech/2020/03/06/dht-and-p2p.html#kademlia-%E7%AE%97%E6%B3%95">某个神的blog</a>、<a href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">Kademlia 论文</a></li><li>开始写Kademlia了，感觉实现比较简单（和上学期写的不少数据结构有很多共同点），并发涉及的也不多（？）争取明天冲完，周末结束，然后开新项目！（目前考虑的是socks5 和Raytracing（这是为了Rust））</li><li>决定周末去天街看Jurassic，虽然看了预告就觉得是史但还是义无反顾地为寡姐买票🥰</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/003VHaBb0wCHop">Blank Space -Taylor Swift</a><br>另附：瑞幸羽衣甘蓝茶出乎意料地还行（能让我这种完全不能接受羽衣甘蓝的人喝下去😋）最近狂喝轻体了</p><h3 id="7-4-Day-11">7-4 Day 11</h3><ul><li>没什么好说的，就是写Kademlia，对Data的处理存在一些疑惑（还没想）是好玩的</li><li>不看Jurassic了，不应该在不能给我提供对等情绪价值的事物上花费时间和金钱，只有coding、music、photography能给我刺激。（这不会显得我很p吧，我是j人）不过吧我觉得这个决定可能还有待更新，毕竟是在一个不太好的情绪状态下做出的决定。</li><li>一天都处在low mood的状态. D*mn Blue Friday.</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/004ZJPWo4bZTXN">Everglow -Coldplay</a></p><h3 id="7-5-Day-12">7-5 Day 12</h3><ul><li>Kademlia Data的处理大概想出来了，快写快写！还是很好写的。当然不排除我双链表写挂…</li><li>发现宝格丽留香太烂了，还得是祖玛珑，在考虑要不要买100ml，但感觉味道会很单调，再议。</li><li>得知要从627搬到516了，贴一段代码。本来想这个暑假机身镜头一起换的，这下米要花在搬家公司上了。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Zhiyuan.RemoteCall(JaneZ,<span class="hljs-string">&quot;Girls.MoveDormitoryTo5thFloor&quot;</span>,<span class="hljs-number">2</span>weeksLater,<span class="hljs-keyword">new</span>(<span class="hljs-built_in">bool</span>))<br>Zhiyuan.RemoteCall(xujiaqi,<span class="hljs-string">&quot;Girls.MoveDormitoryTo5thFloor&quot;</span>,<span class="hljs-number">2</span>weeksLater,<span class="hljs-keyword">new</span>(<span class="hljs-built_in">bool</span>))<br>Zhiyuan.RemoteCall(emptyterrain,<span class="hljs-string">&quot;Girls.MoveDormitoryTo5thFloor&quot;</span>,<span class="hljs-number">2</span>weeksLater,<span class="hljs-keyword">new</span>(<span class="hljs-built_in">bool</span>))<br></code></pre></td></tr></table></figure><p>敲完后发现，这哪里是P2P网络，纯纯CS网络罢了（并非敲完后</p><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/000W8TPy1246YN">Beautiful People -Ed Sheeran /Khalid</a></p><h3 id="7-6-Day-13">7-6 Day 13</h3><ul><li>Kademlia 差不多写完了，还差点定期维护吧，反正应该快了（）</li><li>水源上说有今晚有火烧云，于是去拍，结果去的稍晚，而且也没有传说中的大烧，效果没那么理想，但感觉学服无论哪个机位哪个时间点都很好看🥰 看心情贴图吧，暂时先不放图了（因为懒）不过我真的要换相机，只是时间问题而已</li><li>很美很美的一天了，就像镜头记录下的一样，迎接小学期Week3 🥰 坐牢进度 2/10</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/003VRFq60linmL">Paris -The Chainsmokers</a> 很喜欢这首🥰</p><h3 id="7-7-Day-14">7-7 Day 14</h3><ul><li>Kademlia 写完了，debug中，比chord好调不少，渐渐摸清楚了一些log调试的方法。码量也小一些。希望明天能过。</li><li>和同组的人搓（修改）了一个测delete的程序，将用在下一届DHT组的代码上😈 以及决定实现一下Kademlia的delete，有一个很漂亮的想法，但是否足够好有待验证</li><li>很想出去玩儿了，但约不到人，先把手上事情做完再说吧（</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/004JILAu2HwhPP">三人游 -方大同</a></p><h3 id="7-8-Day-15">7-8 Day 15</h3><ul><li>调，WSL炸，继续调，WSL炸，C盘炸，删log，调，WSL不炸，C盘不炸，没调出来，死</li><li>很难想象这是毫无进展的一天，患上了一种只有调出来kademlia才能治好的玉玉症；以及我可能需要一些睡眠</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/002sYTMz2RmyL1">Not Angry -ChrisJames</a> 蹭一下CJ中国巡演的热度</p><h3 id="7-9-Day-16">7-9 Day 16</h3><ul><li>简直小丑，K桶调小点就过了，虽然error rate有些不满意，Anyway 可以明天再说，DHT基本测试过！Still have application.</li><li>很有意思的机考，最后一题有点遗憾吧，被下发文件误导了，感觉还能多拿很多分（</li><li>被安利了几部剧，决定看看，很久没看美剧了，还挺怀念以前三天一季的日子的😋🥰</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/0026eePV1Kl2Uc">Coastline -Hollow Coves</a></p><h3 id="7-10-Day-17">7-10 Day 17</h3><ul><li>Working on 一个BTcommunity，狂写代码ing，写完会很漂亮（吗）。总想尽力把一件事做好，但力不从心是人生常态吧</li><li>怪奇物语好看🥰 连看2集，感觉这周能看完第一季（那真的很能摆了）一看美剧就停不下来</li><li>周日将闪击南京看牙，快疼死了😭 人一生的痛苦真的是恒定的吗？命好苦…10点到，18点走，极限速通🫠 年轻就是禁得起折腾😇</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/002MXZNu1GToOk">不能说的秘密 -Jay Chou</a></p><h3 id="7-11-Day-18">7-11 Day 18</h3><ul><li>继续application，孩子们这并不好笑🫠</li><li>避雷自由之水，喷一下熏一天，白女味受不了，鉴于我再也不想喷了，想试香的可以来找我，我送你好了（</li><li>摆一下午，床上看剧，四点半才下去，skip dinner（疼的相似什么都吃不了），喜欢下班后的幸福生活🥰</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/003x5xTj20cLPX">茉莉雨 -JJ Lin</a> Be感太强，听碎了</p><h3 id="7-12-Day-19">7-12 Day 19</h3><ul><li>写完了application，先不调了，后面再做改动吧，能量太低了（xm顾老板被富婆包养的日子</li><li>无聊捞人聊天，从摄影聊到了别的，in fact现在讲这些事已经无感了，也不想多说。他比我在感情问题上理智成熟一些吧，和他聊聊也挺开心。</li><li>觉得要开始学习一下《编译原理》，找点事做吧</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/004HAF5J0HxEZk">What Do You Mean? -Justin Bieber</a></p><h3 id="7-13-Day-20">7-13 Day 20</h3><ul><li>回南京，消炎，得知下下周要回去拔掉，孩子真的怕了😨</li><li>在nsfz门口绕了一圈，全是《某某》书粉在打卡，感慨一下母校也逐渐沦为网红打卡地😮‍💨</li><li>没咋学，高铁上随便看看代码调调</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/003jjoM94WLiTf">倒数 -GEM</a></p><h3 id="7-14-Day-21">7-14 Day 21</h3><ul><li>调了一下bonus，发现节点运行没开goroutine，所以一直negative wg，大抵是能跑了，就不动了（</li><li>学了socks5简单代理服务器，大概知道怎么写了，抽空写一下，看的是<a href="https://www.rfc-editor.org/rfc/rfc1928">RFC1928</a></li><li>抢到了孙燕姿南京场的票</li><li>得知下学期的课程安排，压力，很多东西要学但不知道从什么开始或者说学什么，再摸索吧</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/004RtkMi3gchvr">风衣 -孙燕姿</a></p><h3 id="7-15-Day-22">7-15 Day 22</h3><ul><li>写了简单代理服务器，有趣，但不继续了</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/000jXGDn1lSsNS">Young Beautiful -Lana Del Rey</a> Mid July🥰</p><h3 id="7-16-Day-23">7-16 Day 23</h3><ul><li>试图正向做T1，交了40发but failed，以为试答案会炸，结果不会，很荒谬了（ T2是有趣的，但不知为何只抄了样例</li><li>早上写doc，回看了一下代码，明天cr 😢</li></ul><p>今天没听歌，好忙好累好想死🫠</p><h3 id="7-17-Day-24">7-17 Day 24</h3><ul><li>学习LLVM，看晕了，感觉大概懂了zwx写在黑板上的那些名词吧（）</li><li>cr，最红温的一集，为什么会2对1）</li><li>bonus在cr的时候被嘲讽了，不服气遂回去调，终于调出来了，至此，DHT彻底完结撒花！🥳🥳🥳</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/001KKIbk3vD39M">LA Girls -Charlie Puth</a></p><h3 id="7-18-Day-25">7-18 Day 25</h3><ul><li>又看了看socks5，听Network组pre听的（tls singbox 还是太有意思了</li><li>有一种好日子到头的感觉，周末要搬宿舍又没空学or玩了，下周发verilog小作业和cpu模拟，CSAPP的课，生存难度地狱级别</li><li>真的很疑惑，现在到底要做什么🫠</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/000FTTrx4g7UrH">The Scientist -Coldplay</a></p><h3 id="7-19-Day-26">7-19 Day 26</h3><ul><li>早上监工顺带看看verilog文档，气的是干服务业的竟敢对消费者指手画脚，lz已经很客气了，让擦门说的是“麻烦阿姨了不好意思”，还tm不情不愿的😅；只知道东19不知道D19，还把我和室友骂了一顿说我们没写清楚，真nm看我们是大学生好欺负是吧😅</li><li>体力劳动</li></ul><p>（反向）推歌：<a href="https://y.qq.com/n/ryqq/songDetail/000uWmzS4WjkPQ">开始懂了 -单依纯</a> 听着憋屈，差了一口气，缺点儿东西，更多的是炫技。说实话除了《想你时风起》和《给电影人的情书》，我并不对她的歌有什么很高的评价（</p><h3 id="7-20-Day-27">7-20 Day 27</h3><ul><li>一点体力劳动，基本收官</li><li>研究了一会儿服务器，在考虑买个VPS玩玩，再说</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/0002kI4i1KS8eh">Shivers -Ed Sheeran</a></p><h3 id="7-21-Day-28">7-21 Day 28</h3><ul><li>学习verilog，感觉已经成为了verilog大神（划掉划掉），水完了verilog小作业</li><li>听学长讲RISC-V 听的似懂非懂😇 晚上的时间就留给它了（</li><li>至少现在生活变得充实了起来🥰 而非前几天的无所事事</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/001P7cxr472zCa">DAISIES -Justin Bieber</a></p><h3 id="7-22-Day-29">7-22 Day 29</h3><ul><li>我想我或许明白了（？）争取先把naive写完吧，今天辛苦一下</li><li>Arch课有意思，但No Electronic Devices &amp; 强制性全员出勤多少有点吓人😢</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/000qbTA82dVNIt">Christmas List -Anson Seabra</a></p><h3 id="7-23-Day-30">7-23 Day 30</h3><ul><li>机考真炸，《论提问的艺术》；Simulator真难写。。。</li><li>久违的捞，虽然没吃几口，但聊的很开心</li><li>感谢Parsifal老师帮我de了一晚上bug，简直是神，伟大无需多言</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/002Ql1753e7CJn">Welcome to Wonderland -Anson Seabra</a></p><h3 id="7-24-Day-31">7-24 Day 31</h3><ul><li>很好Arch课，让我对写编译器充满了信心🥰（吗）</li><li>会赢吗？会的会的（u’d better.）至少今天写了很多代码（</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/002AmO7Q2KQiub">Beautiful World -Westlife</a></p><h3 id="7-25-Day-32">7-25 Day 32</h3><ul><li>终于建立起了一个完备的完全时序逻辑的Tomasulo架构，但是在写的时候还是遇到了重重阻碍</li><li>再次感谢 Parsifal 耐心解答我对于架构上的诸多问题，教我陪我到很晚很晚😭</li></ul><p>狂写代码，没听歌</p><h3 id="7-26-Day-33">7-26 Day 33</h3><ul><li>我觉得我完全理解了Tomasulo的一切，虽然可能Simulator还存在一些放到硬件上可能会出现的问题，但感觉已经模拟地挺到位的了</li><li>写着写着就发现无论是时序逻辑reg的tick，还是各个元件间wire的数据传输，都是很有规律的，写上手了好像也并不难，还是要理解+设计，心态上也从昨天的觉得完全无法战胜转变到有信心能完成它，只差接线了！进度还行🥳</li><li>又是和 Parsifal 的一天🥰 不过真的很xm他一整天的无所事事 😈</li></ul><p>狂写代码，没听歌</p><h3 id="7-27-Day-34">7-27 Day 34</h3><ul><li>写完了simulator，开始痛苦艰难地debug环节</li><li>去了淮海中路Nikon直营店，Z30 18140 get！可以出去爽拍了🥰</li><li>Another day with Parsifal，这个人终于开始work了🤣</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/00251jeI1ekZao">I Like Me Better -Lauv</a></p><h3 id="7-28-Day-35">7-28 Day 35</h3><ul><li>开始了simulator的调试工作，边调边发现了一些问题，又加了很多代码</li><li>此生最后一次机考结束！！！</li><li>散步到很晚很晚，好像什么都想开了</li></ul><p>狂写代码，没听歌</p><h3 id="7-29-Day-36">7-29 Day 36</h3><ul><li>可以说debug出现了不小的进展吧，调到很晚很晚（具体多晚不便透露</li><li>有点累了，感觉周末需要休息一下</li></ul><p>推歌：<a href="https://y.qq.com/n/ryqq/songDetail/0041L5z44F7h5q">Every Breath You Take -The Police</a></p><h3 id="7-30-Day-37">7-30 Day 37</h3><ul><li>debug debug debug ，能过个别点了</li><li>Good night in the library.</li></ul><p>狂调代码，没听歌</p><h3 id="7-31-Day-38">7-31 Day 38</h3><ul><li>调了一整天，发现了一点逻辑架构问题和唐氏错误，8.1 凌晨4点过了！</li><li>Well played !</li></ul><p>狂调代码，没听歌</p><h3 id="8-1-Day-39">8-1 Day 39</h3><ul><li>cr 完美收官！PPCA完结撒花！（其实还差一个carried ripple adder，不过这是好写的</li><li>一起看了了不起的盖茨比</li></ul><h3 id="Conclusion">Conclusion</h3><p>PPCA结束！写了很多很多代码，学到了很多东西，玩的很开心，希望接下来四周的compiler 和arch 一切顺利，也希望能够维持一段健康成熟的恋爱关系🥰</p><p>此楼正式锁楼！</p><p>尽情期待JaneZ’s Arch &amp; Compiler!</p>]]></content>
    
    
    <categories>
      
      <category>PPCA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
      <tag>PPCA</tag>
      
      <tag>DHT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>State Spaces &amp; Uninformed Search</title>
    <link href="/2025/06/11/CS188-1/"/>
    <url>/2025/06/11/CS188-1/</url>
    
    <content type="html"><![CDATA[<h1>CS-188 Lecture 2</h1><h1>State Spaces and Search Problems</h1><p>Given our agent’s <strong>current state</strong>,how can we arrive at a <strong>new state</strong> that satisfies its goals in the best possible way?</p><p><strong>Elements of a search problem:</strong></p><ul><li>A state space (all possible states)</li><li>Available actions in each state</li><li>A <strong>transition model</strong>(Output the next state when an action is taken st current state)</li><li>An action cost</li><li>A start state</li><li>A goal test(A function that takes a state as input, and determines whether it is a goal state)</li></ul><h2 id="Difference-between-World-State-Search-State">Difference between World State &amp; Search State</h2><ul><li>World State: All information</li><li>Search State: Information necessary for planning</li></ul><h3 id="Pacman-Example">Pacman Example</h3><p><img src="/img/Pacman.png" alt="Pacman Game"></p><ul><li>Target: Pathing</li><li>Target: Eat all dots</li></ul><h2 id="State-Space-Size">State Space Size</h2><p><strong>Fundamental Counting Principle</strong><br>n variable objects which can take on x1,…,xn different values respectively</p><p>Then the total number of states is x1·x2·…·xn</p><h3 id="Configuration-of-Pacman">Configuration of Pacman</h3><p>Pacman has 120 postions、4 directions、2 ghosts in 12positions、30 food pellets（can be eaten or not），total space size is 120⋅4⋅12<sup>2⋅2</sup>30</p><h2 id="State-Space-Graphs-and-Search-Trees">State Space Graphs and Search Trees</h2><h3 id="State-Space-Graphs">State Space Graphs</h3><ul><li>Nodes: states</li><li>Edges: actions</li><li>Edge Weight: action cost</li></ul><p>Too large to store in memory due to the large State Space Size.</p><p><strong>each state is represented exactly once</strong></p><h3 id="Search-Tree-typically-used">Search Tree(typically used)</h3><p><strong>have no such restriction on the number of times a state can appear</strong></p><p>Also too large.</p><h3 id="Sol">Sol</h3><p>We only store states we’re immediately working with.</p><h2 id="Uninformed-Search">Uninformed Search</h2><p>The pseudocode:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function TREE-SEARCH(problem, frontier) returns a solution <span class="hljs-keyword">or</span> failure <br>    frontier ← INSERT(MAKE-<span class="hljs-keyword">NODE</span><span class="hljs-title">(INITIAL-STATE</span>[problem]), frontier) <br>    while not IS-EMPTY(frontier) do <br>        <span class="hljs-keyword">node</span> <span class="hljs-title">← POP</span>(frontier) <br>        if problem.IS-GOAL(node.STATE) then <br>            return <span class="hljs-keyword">node</span> <br>        <span class="hljs-title">for</span> each child-<span class="hljs-keyword">node</span> <span class="hljs-title">in</span> EXPAND(problem, <span class="hljs-keyword">node</span><span class="hljs-title">) do</span> <br>            add child-<span class="hljs-keyword">node</span> <span class="hljs-title">to</span> frontier <br>    return failure <br><br>function EXPAND(problem, <span class="hljs-keyword">node</span><span class="hljs-title">) yields</span> nodes <br>    s ← node.STATE <br>    for each action <span class="hljs-keyword">in</span> problem.ACTIONS(s) do <br>        s&#x27; ← problem.RESULT(s, action) <br>        yield <span class="hljs-keyword">NODE</span><span class="hljs-title">(STATE</span>=s&#x27;, <span class="hljs-attr">PARENT=</span><span class="hljs-keyword">node</span><span class="hljs-title">, ACTION</span>=action) <br></code></pre></td></tr></table></figure><p>Judgements:</p><ul><li>Completeness</li><li>Optimality</li><li>Branching factor</li><li>The maximun depth m</li><li>The depth of the shallowest solution s</li></ul><h3 id="DFS">DFS</h3><p>“Leftmost” Solution</p><h3 id="BFS">BFS</h3><p>Shallowest Solution</p><h3 id="UCS-–-Uniform-Cost-Search">UCS – Uniform Cost Search</h3><p>Select the lowest cost frontier node from the start node</p><p>The same thought of <a href="https://janezair.site/2025/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412/#%E5%8A%A0%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-Dijkstra%E7%AE%97%E6%B3%95">Dijkstra</a></p><p>If all the costs are not negative,then UCS can always find the lowest-cost solution.(If not then Bellman-Ford)</p>]]></content>
    
    
    <categories>
      
      <category>CS188_Introduction to AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph Algorithm</title>
    <link href="/2025/05/23/AlgorithmOfDS5/"/>
    <url>/2025/05/23/AlgorithmOfDS5/</url>
    
    <content type="html"><![CDATA[<h1>Graph Algorithms</h1><h4 id="ps-上机课是05-18上的，算法是05-23学的🤣（评价是这周事还是太多了）perhaps和这节上机课量巨大也有关系吧😢">ps: 上机课是05.18上的，算法是05.23学的🤣（评价是这周事还是太多了）perhaps和这节上机课量巨大也有关系吧😢</h4><h2 id="术语回顾">术语回顾</h2><ul><li>DAG 有向无环图</li><li>点度 = 入度 + 出度</li><li>SPT 最短路径树</li></ul><h2 id="最短路-单源-多源">最短路 单源/多源</h2><p>Q：给出一个加权图和图上的一个节点s，找出s到图中每一节点的最短路径</p><h3 id="Dijkstra-算法">Dijkstra 算法</h3><p>Core:<br><strong>v=argmin_u∈SPT,(u,v)∈E,v∉SPT{d(s,u)+w(u,v)}</strong></p><p>代码实现（使用pq进行优化）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;queue&gt;</span><br>struct edge&#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct ver&#123;<br>    edge *head;<br>&#125;;<br>ver G[<span class="hljs-number">200005</span>];<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)&#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = w;<br>    <span class="hljs-keyword">current</span>-&gt;next = G[u].head;<br>    G[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">bool</span> known[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> distance[<span class="hljs-number">200005</span>];<br>struct Pair&#123;<br>    <span class="hljs-type">int</span> dis;<br>    <span class="hljs-type">int</span> u;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(const Pair &amp;a)const&#123;<br><span class="hljs-keyword">return</span> dis &gt; a.dis;<br>    &#125;<br>&#125;;<br>priority_queue&lt;Pair&gt; pq;<br><span class="hljs-type">int</span> main()&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin &gt;&gt; <span class="hljs-keyword">start</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++)&#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; <br>        add_edge(u,v,w);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        known[i] = <span class="hljs-keyword">false</span>;<br>        distance[i] = <span class="hljs-number">1e9</span>;<br>    &#125;<br>    distance[<span class="hljs-keyword">start</span>] = <span class="hljs-number">0</span>;<br>    pq.push(&#123;<span class="hljs-number">0</span>,<span class="hljs-keyword">start</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.empty())&#123;<br>        Pair top = pq.top();<br>        pq.pop();<br>        <span class="hljs-keyword">if</span>(known[top.u])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        known[top.u] = <span class="hljs-keyword">true</span>;<br>        edge *<span class="hljs-keyword">current</span> = G[top.u].head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>            <span class="hljs-keyword">if</span>(dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] &gt; dis[top.u] + <span class="hljs-keyword">current</span>-&gt;weight)&#123;<br>                dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = dis[top.u] + <span class="hljs-keyword">current</span>-&gt;weight;<br>                pq.push(&#123;dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>],<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>upd：改了一下Dijkstra的板子（某个🤡机考的时候Dijkstra板子写成了修改前的错误版本导致痛失70分😭😭😭）。<br>总结：板子写错最为致命🫠🫠🫠 逆天机考至少有170分的😅😅😅</p><h3 id="Bellman-Ford-算法">Bellman-Ford 算法</h3><p><strong>用于处理存在负边的图</strong><br>update操作的正确性毋庸置疑<br>于是，假设d(s,v)最短路经过k个点，那么在经过(k-1)个点的最短路都被确定的前提下，一次update操作保证了d(s,v)的正确性</p><p>代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br>struct edge&#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct ver&#123;<br>    edge *head;<br>&#125;;<br>ver G[<span class="hljs-number">200005</span>];<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)&#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = w;<br>    <span class="hljs-keyword">current</span>-&gt;next = G[u].head;<br>    G[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> distance[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> main()&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin &gt;&gt; <span class="hljs-keyword">start</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++)&#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; <br>        add_edge(u,v,w);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        known[i] = <span class="hljs-keyword">false</span>;<br>        distance[i] = <span class="hljs-number">1e9</span>;<br>    &#125;<br>    distance[<span class="hljs-keyword">start</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        flag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(dis[<span class="hljs-keyword">current</span>] == <span class="hljs-number">1e9</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            edge *<span class="hljs-keyword">current</span> = G[j].head;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>                <span class="hljs-keyword">if</span>(dis[curent-&gt;<span class="hljs-keyword">end</span>] &gt; dis[j] + <span class="hljs-keyword">current</span>-&gt;weight)&#123;<br>                    dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = dis[j] + <span class="hljs-keyword">current</span>-&gt;weight;<br>                    flag = <span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)&#123;<br>            break;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag)&#123;<br>        std::cout &lt;&lt; <span class="hljs-number">-1</span>;//存在负权环<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SPFA-算法-（已经死了）">SPFA 算法 （已经死了）</h3><p><sub>虽然可以构造数据把BF的队列优化卡掉，</sub>但还是学习一下这种优化吧，毕竟笔者刚做小作业时，第一遍BF 大T特T，第二遍SPFA 被卡了一个点，最后进行了SPFA + SLF优化才过。</p><p>首先是SPFA的队列优化</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">bool visit[<span class="hljs-number">25005</span>];<span class="hljs-comment">//用于维护结点是否上次被松驰过，因为只有上一次被松弛过的结点才会对下一轮循环产生影响</span><br>queue&lt;int&gt; q;<br><br><span class="hljs-keyword">while</span>(!q.empty())&#123;<br>    int u = q.front();<br>    q.pop();<br>    visit[u] = <span class="hljs-literal">false</span>;<br>    edge *current = G[u].head;<br>    <span class="hljs-keyword">while</span>(current)&#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(dis[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] &gt; dis[u] + current-&gt;</span>weight)&#123;<br>            <span class="hljs-function"><span class="hljs-title">dis</span>[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] = dis[u] + current-&gt;</span>weight;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!visit[current-&gt;</span>end])&#123;<br>                <span class="hljs-function"><span class="hljs-title">visit</span>[current-&gt;</span>end] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-function"><span class="hljs-title">q</span>.push(current-&gt;</span>end);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">current</span> = current-&gt;</span>next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续观察，还可以发现，如果松驰后的顶点的dis越小，那么对后续产生的影响越大，可以往前放，于是我们首先想到是否可以用pq解决</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">dis[s] = <span class="hljs-number">0</span>;<br>priority_queue&lt;int&gt; q;<br>q.push(s);<br><span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>    int u = q.top();<br>    q.pop();<br>    visit[u] = <span class="hljs-literal">false</span>;<br>    edge *current = G[u].head;<br>    <span class="hljs-keyword">while</span> (current) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(dis[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] &gt; dis[u] + current-&gt;</span>weight) &#123;<br>            <span class="hljs-function"><span class="hljs-title">dis</span>[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] = dis[u] + current-&gt;</span>weight;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!visit[current-&gt;</span>end]) &#123;<br>                <span class="hljs-function"><span class="hljs-title">q</span>.push(current-&gt;</span>end);<br>                <span class="hljs-function"><span class="hljs-title">visit</span>[current-&gt;</span>end] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">current</span> = current-&gt;</span>next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>确实优化了，但依然被助教卡了，主要还是因为pq凭空多了调整的logN级复杂度，那么还能怎么优化呢？</p><p>男明星：deque！双端队列使插入删除变为O(1)的复杂度，很好了🥰</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xl">dis[s] = <span class="hljs-number">0</span>;<br>deque&lt;int&gt; q;<br>q.push_front(s);<br><span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>    int u = q.front();<br>    q.pop_front();<br>    visit[u] = <span class="hljs-literal">false</span>;<br>    edge *current = G[u].head;<br>    <span class="hljs-keyword">while</span> (current) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(dis[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] &gt; dis[u] + current-&gt;</span>weight) &#123;<br>            <span class="hljs-function"><span class="hljs-title">dis</span>[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] = dis[u] + current-&gt;</span>weight;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!visit[current-&gt;</span>end]) &#123;<br>                <span class="hljs-function"><span class="hljs-title">visit</span>[current-&gt;</span>end] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-function"><span class="hljs-title">if</span>(!q.empty() &amp;&amp; dis[current-&gt;</span>end] &lt; dis[q.front()])&#123;<br>                    <span class="hljs-function"><span class="hljs-title">q</span>.push_front(current-&gt;</span>end);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-function"><span class="hljs-title">q</span>.push_back(current-&gt;</span>end);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">current</span> = current-&gt;</span>next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也就是传说中的 SPFA + SLF优化！妙啊！（使我不用写Dijkstra + 连通分量的正解了XD）</p><h3 id="Floyd-算法">Floyd 算法</h3><p><strong>用于多元最短路问题</strong>（求任意两个结点之间最短路）<br>复杂度较高但常数小</p><p>类似BF的dp思路，维护一个三维数组 d[k,u,v]，表示只允许经过 1-k 的顶点，结点u到结点v 的最短路长度</p><p>状态转移方程为：<br>d[k,u,v] = min{d[k-1,u,v], d[k-1,u,k] + d[k-1,k,v]}</p><p><strong>从 u 到 v 经过 k 或者不经过 k</strong></p><p>代码实现：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for(int k = 1;k &lt;= n;k ++)&#123;<br>    for(int u = 1;u &lt;= n;u ++)&#123;<br>        for(int v = 1;v &lt;= n;v ++)&#123;<br>            f<span class="hljs-comment">[k]</span><span class="hljs-comment">[u]</span><span class="hljs-comment">[v]</span> = min(f<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[u]</span><span class="hljs-comment">[v]</span>,f<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[u]</span><span class="hljs-comment">[k]</span> + f<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[k]</span><span class="hljs-comment">[v]</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题">例题</h3><p>贴个题: <a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1196">裂点</a></p><p>省流：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> 个点 m 条有向边，边有正边权，可以免费走 k 条边，边权视为 <span class="hljs-number">0</span>，求 s 到 <span class="hljs-built_in">t</span> 的最短路<br></code></pre></td></tr></table></figure><p>想法：<br>点集取为(v,f)，f 为免费次数</p><p>则(u,f) -&gt; (v,f) 边权w<br>(u,f) -&gt; (v,f - 1) 0</p><p>用Dijkstra即可</p><h2 id="连通分量">连通分量</h2><h3 id="Concept-Recall">Concept Recall</h3><ul><li>连通性是二元等价关系（自反性、对称性、传递性）</li><li>有向图中，弱连通：转向无向图后连通；<br>强连通：任意两点间相互可达</li><li>强连通分量（SCC）是等价类，将点集划分成若干个内部强连通的部分</li></ul><h3 id="强连通分量算法">强连通分量算法</h3><hr><h3 id="Kosaraju-算法">Kosaraju 算法</h3><ul><li>从任意结点开始对有向图进行深度优先搜索，得到一个深度优先森林</li><li>将节点遍历：按照生成树的次序 + 对每一棵树上的节点进行后序遍历</li><li>将图 G 逆向得到Gr</li><li>从编号最大的节点开始深度优先搜索，得到的森林就是原图的强联通分量。</li></ul><p>代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;vector&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>struct edge &#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct ver &#123;<br>    edge *head;<br>&#125;;<br>ver G1[<span class="hljs-number">25005</span>];//正向图<br>ver G2[<span class="hljs-number">25005</span>];//反图<br><span class="hljs-type">void</span> add_edge1(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> c) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = c;<br>    <span class="hljs-keyword">current</span>-&gt;next = G1[u].head;<br>    G1[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">void</span> add_edge2(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> c) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = c;<br>    <span class="hljs-keyword">current</span>-&gt;next = G2[u].head;<br>    G2[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">bool</span> visit[<span class="hljs-number">25005</span>];<br><span class="hljs-type">bool</span> colored[<span class="hljs-number">25005</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-type">int</span> SCCcnt;<br><span class="hljs-type">void</span> dfs1(<span class="hljs-type">int</span> u)&#123;<br>    visit[u] = <span class="hljs-keyword">true</span>;<br>    edge *<span class="hljs-keyword">current</span> = G1[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!visit[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            dfs1(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    s.push_back(u);<br>&#125;<br><span class="hljs-type">void</span> dfs2(<span class="hljs-type">int</span> u)&#123;<br>    colored[u] = SCCcnt;<br>    edge *<span class="hljs-keyword">current</span> = G2[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!colored[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            dfs2(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> main()&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++)&#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        add_edge1(u,v,w);<br>        add_edge2(v,u,w);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!visit[i])&#123;<br>            dfs1(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i <span class="hljs-comment">--)&#123;</span><br>        //从栈顶开始向前回溯<br>        <span class="hljs-keyword">if</span>(!colored[s[i]])&#123; //还未被分配到任何SCC中<br>            ++ SCCcnt;<br>            dfs2(s[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Tarjan-算法">Tarjan 算法</h3><p>在DFS过程中，按照生成的顺序会生成一颗结构良好的DFS树。DFS得到的序列（DFS序并不能保证相邻节点一定有边相连），但是DFS树的节点一定都是图中的节点，换句话说，DFS树在本质上就是一个在中序遍历上完全等价的树。<br><img src="/img/DFS%E6%A0%91.png" alt="DFS Tree"></p><p>但是很显然，一颗DFS树上的顶点不代表联通。我们需要考虑不在DFS树上的边，例如这里的：</p><ul><li>反向边</li><li>前向边</li><li>交叉边（横向边）</li></ul><p><strong>Lemma: SCC 中 dfn 最小的结点是该 SCC 中所有节点在 DFS 树上的祖先（也就是所谓最远能到达的祖先）</strong></p><h4 id="Tarjan-算法实现">Tarjan 算法实现</h4><p>用一个栈表示没有全部访问的 SCC<br>记录 DFS 序 dfn[v] 和最远能走到的栈中节点 low[v]<br>要求：从 v 到 low[v] 的路径中最多一条非树边</p><p><img src="/img/Tarjan%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt="Tarjan 实现"></p><p>一个点的所有边访问结束之后，若 dfn[v ] = low[v ] ，则 v 及其子树的一部分构成一个 SCC<br><strong>Lemma: dfn[v] = low[v] 的点是其所在 SCC 中 dfn 最小的点</strong><br>若不是，则 v 到达之要经过非树边，v 必然能通过仅一条非树边到达dfn更小的点</p><p>Tarjan算法的原理是笔者学过所有算法中最恶心最绕的😅，但它的实现还是挺容易的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> dfn[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> low[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> dfnCnt;<br><span class="hljs-type">int</span> Stack[<span class="hljs-number">200005</span>];//一个栈，用于跟踪当前正在进行 DFS 遍历的路径上的节点。节点在被发现时入栈，在找到一个强连通分量时出栈<br><span class="hljs-type">bool</span> inStack[<span class="hljs-number">200005</span>];//是否在栈中<br><span class="hljs-type">int</span> top;//栈顶指针<br><span class="hljs-type">int</span> scc[<span class="hljs-number">200005</span>];//结点i所在强连通分量编号<br><span class="hljs-type">int</span> sccCnt;//强连通分量个数计数器<br><span class="hljs-type">int</span> sz[<span class="hljs-number">200005</span>];//强连通大小<br><br><span class="hljs-type">void</span> Tarjan(<span class="hljs-type">int</span> u)&#123;<br>    low[u] = dfn[u] = ++dfnCnt;<br>    Stack[++ top] = u;<br>    inStack[u] = <span class="hljs-keyword">true</span>;<br>    edge *<span class="hljs-keyword">current</span> = G[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            Tarjan(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>            low[u] = min(low[u],low[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inStack[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            low[u] = min(low[u],dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u] == low[u])&#123;<br>        //找到SCC祖先结点<br>        ++sccCnt;<br>        <span class="hljs-keyword">do</span>&#123;<br>            scc[STACK[top]] = sccCnt;<br>            sz[sccCnt] ++;<br>            inStack[Stack[top]] = <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">while</span>(Stack[top <span class="hljs-comment">--] != u);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!dfn[i])&#123;<br>            Tarjan(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一道很棒的Tarjan例题（算是自己做出来的一道蓝题吧）">一道很棒的Tarjan例题（算是自己做出来的一道蓝题吧）</h4><p>老规矩，贴题，<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1197">ATM</a></p><p>相当综合的一题，把笔者今天学的近乎所有图算法都用了一遍🤣🤣🤣<br>想法是缩点，也就是求所有强连通分量（Tarjan板子），看成一张新的图（此图是DAG），于是使用SPFA求最长路径。特别要注意的是，不可以用Dijkstra，因为贪心的思想放在最长的情况下并不正确！！！（笔者在AC后尝试用Dijkstra WA 了2个点）</p><p>贴个AC代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;queue&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> s,p;<br><span class="hljs-type">int</span> sccCnt;<br><span class="hljs-type">int</span> SCC[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> Stack[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> top;<br><span class="hljs-type">int</span> dfn[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> dfnCnt;<br><span class="hljs-type">int</span> low[<span class="hljs-number">500005</span>];<br><span class="hljs-type">bool</span> inStack[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> <span class="hljs-type">Money</span>[<span class="hljs-number">500005</span>];//每个路口的钱<br><span class="hljs-type">int</span> sccMoney[<span class="hljs-number">500005</span>];//每个强连通分量中抢到钱的总数<br><span class="hljs-type">bool</span> sccPub[<span class="hljs-number">500005</span>];//每个强连通分量中是否有pub<br><span class="hljs-type">bool</span> pub[<span class="hljs-number">500005</span>];//酒吧位置<br>struct edge &#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>&#125;;<br>struct ver &#123;<br>    edge *head;<br>&#125;;<br>ver G[<span class="hljs-number">500005</span>];<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;next = G[u].head;<br>    G[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">void</span> tarjan(<span class="hljs-type">int</span> u) &#123;<br>    low[u] = dfn[u] = ++dfnCnt;<br>    inStack[u] = <span class="hljs-keyword">true</span>;<br>    Stack[++top] = u;<br>    edge *<span class="hljs-keyword">current</span> = G[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>            tarjan(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>            low[u] = min(low[u],low[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inStack[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>            low[u] = min(low[u],dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u] == low[u]) &#123;<br>        ++sccCnt;<br>        <span class="hljs-keyword">do</span> &#123;<br>            inStack[Stack[top]] = <span class="hljs-keyword">false</span>;<br>            SCC[Stack[top]] = sccCnt;<br>            sccMoney[sccCnt] += <span class="hljs-type">Money</span>[Stack[top]];<br>            <span class="hljs-keyword">if</span>(pub[Stack[top]]) &#123;<br>                sccPub[sccCnt] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (Stack[top <span class="hljs-comment">--] != u);</span><br>    &#125;<br>&#125;<br>ver newG[<span class="hljs-number">500005</span>];<br><span class="hljs-type">void</span> add_edgeNEW(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;next = newG[u].head;<br>    newG[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> dis[<span class="hljs-number">500005</span>];<br><span class="hljs-type">bool</span> visit[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        <span class="hljs-type">int</span> u,v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        add_edge(u,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; <span class="hljs-type">Money</span>[i];<br>    &#125;<br>    cin &gt;&gt; s &gt;&gt; p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= p;i ++) &#123;<br>        <span class="hljs-type">int</span> pos;<br>        cin &gt;&gt; pos;<br>        pub[pos] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(!dfn[i]) &#123;<br>            tarjan(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        edge *<span class="hljs-keyword">current</span> = G[i].head;<br>        <span class="hljs-type">int</span> nCurrent = SCC[i];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>) &#123;<br>            <span class="hljs-type">int</span> nEnd = SCC[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>];<br>            <span class="hljs-keyword">if</span>(nEnd != nCurrent)&#123;<br>                add_edgeNEW(nCurrent,nEnd);<br>            &#125;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> start = SCC[s];//起始强连通分量<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.push(<span class="hljs-keyword">start</span>);<br>    dis[<span class="hljs-keyword">start</span>] = sccMoney[<span class="hljs-keyword">start</span>];<br>    <span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>        <span class="hljs-type">int</span> top = q.front();<br>        q.pop();<br>        visit[top] = <span class="hljs-keyword">false</span>;<br>        edge *<span class="hljs-keyword">current</span> = newG[top].head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>) &#123;<br>            <span class="hljs-keyword">if</span>(dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] &lt; dis[top] + sccMoney[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>                dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = dis[top] + sccMoney[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!visit[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>                visit[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = <span class="hljs-keyword">true</span>;<br>                q.push(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>            &#125;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> MaxMoney = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= sccCnt;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(sccPub[i]) &#123;<br>            <span class="hljs-keyword">if</span>(dis[i] &gt; MaxMoney) &#123;<br>                MaxMoney = dis[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; MaxMoney;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><p>Thanks so much:</p><ul><li>Alan Liang &amp; baihua’s slides</li><li><a href="https://xiyuanyang-code.github.io/posts/DataStructure-Graph-SCC/">Xiyuan Yang’s SCC Notes</a></li></ul><h2 id="Final-Words">Final Words</h2><p>做完了最后一次小作业的最后一题，再加上周四已经通过的火车票管理系统，数据结构CS1951 的所有课程内容都基本完成了（还有个机考😭）。感觉一学期下来代码能力得到了不小的提升（虽然这学期好像也没写什么代码🤣）。有一点怅然若失，每天写学算法、写小作业、debug大作业的日子就这样过去了，但想到未来还会学更多有趣的东西，又觉得很兴奋。或许一年前的我，还在为差一点点就能去清北，而质疑自己的选择，但我想我不会后悔我做的每一个决定。也有人问我家那么富为什么要来学cs😅，但我对钱真的不感兴趣呢。一直认为自己物欲很低（室友锐评：清心寡欲），没什么特别想要的，花钱很少，觉得钱没那么重要，也不想靠父母活一辈子（如果我这么选，我甚至不用上大学😅）。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Bellman Ford</tag>
      
      <tag>Floyd</tag>
      
      <tag>SPFA</tag>
      
      <tag>SLF</tag>
      
      <tag>Tarjan</tag>
      
      <tag>Kosaraju</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Theories and Decidability</title>
    <link href="/2025/05/18/Mathematical-Logic12/"/>
    <url>/2025/05/18/Mathematical-Logic12/</url>
    
    <content type="html"><![CDATA[<h1 id="theories-and-decidability"><a class="markdownIt-Anchor" href="#theories-and-decidability"></a> Theories and Decidability</h1><h2 id="recall-the-4-questions-were-gonna-answer"><a class="markdownIt-Anchor" href="#recall-the-4-questions-were-gonna-answer"></a> Recall The 4 Questions we’re gonna answer.</h2><p>Q1: What is a mathematical proof?<br />Q2: What makes a proof correct?<br />Q3: <strong>Is there a boundary of provability?</strong><br />Q4: Can computers find proofs?</p><p>We’ve already answer Q1 Q2 &amp; Q4.</p><p>Now we’re going to answer Q3.</p><h2 id="theories"><a class="markdownIt-Anchor" href="#theories"></a> Theories</h2><p>First, give the definition.</p><p><img src="/img/Theory.png" alt="Theory" /></p><p>我们还可以定义T 的逻辑闭包：<br /><img src="/img/%E9%80%BB%E8%BE%91%E9%97%AD%E5%8C%85.png" alt="逻辑闭包" /></p><p>同样我们还可以知道以下3个命题是等价的<br /><img src="/img/%E7%AD%89%E4%BB%B7%E5%91%BD%E9%A2%98.png" alt="" /></p><p>几个证明的关键点在：</p><ul><li>T <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span>  T⊨ (取任意φ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> T；假设模型M 使得 M ⊨ T，则M ⊨ φ，故T ⊨ φ；所以有φ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> T⊨)</li><li>取模型M，如果M ⊨ T，可以取一个M无法满足的句子ψ，则ψ 不是T 的逻辑推论，则ψ 不属于T⊨</li><li>T⊨是封闭的，因为对所有的ψ，如果(T⊨) ⊨ ψ，则T ⊨ ψ，则 ψ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> T⊨</li><li>空真：如果 T 不可满足，且T ⊨ φ，则φ可取任意L^S中公式</li><li>假设 T⊨ 不可满足，则 (T⊨)⊨ = L^S</li></ul><h2 id="peano-arithmetic"><a class="markdownIt-Anchor" href="#peano-arithmetic"></a> Peano Arithmetic</h2><p><strong>φPA</strong><br /><img src="/img/PA.png" alt="Definition Of PA" /></p><h2 id="elementary-arithmetic"><a class="markdownIt-Anchor" href="#elementary-arithmetic"></a> Elementary arithmetic</h2><p><img src="/img/%E5%88%9D%E7%AD%89%E7%AE%97%E6%9C%AF.png" alt="Definition of EA" /></p><p><strong>RMK:</strong><br />It’s easy to see that φPA <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> Th(N),we will show that φPA ⊊ Th(N)</p><h2 id="r-axiomatizable-可公理化"><a class="markdownIt-Anchor" href="#r-axiomatizable-可公理化"></a> R-axiomatizable 可公理化</h2><p><img src="/img/%E5%85%AC%E7%90%86%E5%8C%96.png" alt="Definition" /></p><h2 id="theorem-5"><a class="markdownIt-Anchor" href="#theorem-5"></a> Theorem 5</h2><p><strong>Every R-axiomatizable theory is R-enumerable.</strong></p><h2 id="complete-theory"><a class="markdownIt-Anchor" href="#complete-theory"></a> Complete Theory</h2><p><img src="/img/CT.png" alt="Complete Theory" /></p><h2 id="theorem-6"><a class="markdownIt-Anchor" href="#theorem-6"></a> Theorem 6</h2><p>(i) Every R-axiomatizable complete theory is R-decidable.<br />(ii) Every R-enumerable complete theory is R-decidable.</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proof of the Undecidabilty of FO</title>
    <link href="/2025/05/17/Mathematical-Logic11/"/>
    <url>/2025/05/17/Mathematical-Logic11/</url>
    
    <content type="html"><![CDATA[<h1>Mathematical Logic 11 Proof of the undecidability of FO</h1><h2 id="Undecidability-of-FO">Undecidability of FO</h2><p><img src="/img/FO.png" alt="Undecidability of FO"></p><h2 id="Basic-Thoughts-of-the-Proof">Basic Thoughts of the Proof</h2><p>We’ve already proved that Π halt is not R-decidable by using Π’halt ⩽m Π halt.</p><p><strong>So we only need to show that Π halt ⩽m FO</strong>.</p><p>i.e <strong>We have to construct a reduction.</strong></p><p>P: □ -&gt; halt  ⇔ |= φP</p><h2 id="Main-Target-Build-φP">Main Target: Build φP</h2><h2 id="Configuration-of-the-Register-Machine">Configuration of the Register Machine</h2><p>引入<strong>Configuration 格局</strong>的概念</p><p>我们定义一个(n + 2) 元组：<br>(L,m0,m1,…,mn)</p><p>L表示当前这一条指令，mi表示第i个寄存器中存储的字符串中 | 的个数（若A = {|}）</p><p>显然这样的(n + 2) 元组可以<strong>刻画程序的行为</strong></p><p>初始状态(0,0,…,0)</p><p>停机时状态(k,m0,m1,…,mn)</p><h2 id="Reduction-Overview-1-S-Structure">Reduction Overview 1 : S-Structure</h2><p>定义一种关系：<br>R^P := {(L,m0,m1,…,mn) | (0,0,…,0) -&gt; (L,m0,m1,…,mn)}</p><p><strong>程序可达格局</strong></p><p>So We need that:<br>1.定义一个公式 ψP decribes R^P<br>2.P: □ -&gt; halt  ⇔  (k,m0,m1,…,mn) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> R^P</p><p>所以可以建立如下的S-strcutre</p><p><img src="/img/BuildSStructure.png" alt="S-Structure"></p><h2 id="Reduction-Overview-2">Reduction Overview 2</h2><p>The desired ψP should satisfy the following two properties:、<br><img src="/img/TwoPro.png" alt="P1 &amp; P2"></p><p>Finally , we set:<br><img src="/img/varphi.png" alt="Construct φP"></p><h2 id="We-can-easily-proved-that-P-□-halt-⇔-φP">We can easily proved that P: □ -&gt; halt  ⇔ |= φP</h2><h2 id="The-Constructuction-of-ψP">The Constructuction of ψP</h2><p><img src="/img/Construct1.png" alt=""></p><p><img src="/img/Construct2.png" alt=""></p><p>是一个对指令类型的分类讨论</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA DS MST</title>
    <link href="/2025/05/11/AlgorithmOfDS4/"/>
    <url>/2025/05/11/AlgorithmOfDS4/</url>
    
    <content type="html"><![CDATA[<h1 id="lca-least-common-ancestors"><a class="markdownIt-Anchor" href="#lca-least-common-ancestors"></a> LCA ———— Least Common Ancestors</h1><hr /><h2 id="如何计算"><a class="markdownIt-Anchor" href="#如何计算"></a> 如何计算？</h2><ul><li>深度相同一起跳</li><li>深度不同，深度大的跳</li></ul><p>显然，一层一层跳复杂度将会来到O(N)</p><h2 id="空间换时间-一次多跨几步"><a class="markdownIt-Anchor" href="#空间换时间-一次多跨几步"></a> 空间换时间 一次多跨几步</h2><p>联系：<a href="https://janezair.site/2025/04/05/AlgorithmOfDS2/#sparse-table-st%E8%A1%A8">ST表</a><br />考虑保存<strong>2 的幂次级 祖先</strong></p><p>于是我们有了一种很棒的<strong>倍增</strong>做法：</p><ol><li>假设 y 比 x 深，则 y 需要向上跳 a = h(y) - h(x)</li><li>对 a 进行二进制拆分</li><li>令 f[x][i]为结点 x 的 2^i级祖先，则状态转移方程为：f[x][i] = f[f[x][i-1]][i-1]</li></ol><p>也就是说，我们可以进行一个ST表的预处理：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(int j <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;j &lt;= 20;j ++)&#123;</span><br>    for(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;i &lt;= n;i ++)&#123;</span><br>        f[i][j] <span class="hljs-operator">=</span> f[f[i][j-<span class="hljs-number">1</span>]][j-<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度是O(NlogN)的</p><h2 id="深度相同一起跳"><a class="markdownIt-Anchor" href="#深度相同一起跳"></a> 深度相同一起跳</h2><p>问题在于：深度差未知<br />不能跳过头，但也不想太保守（一点一点往上挪），争取跳出<strong>能跳的 最大的步子</strong></p><p>So:以 2 的幂次从大往小尝试</p><ul><li>每次跳都确保跳到的点不相同</li><li>步长递减到2^0 为止，返回最后点的父亲节点</li></ul><h2 id="lca-代码实现"><a class="markdownIt-Anchor" href="#lca-代码实现"></a> LCA 代码实现</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int lca(int x,int y)&#123;<br>    if(dp<span class="hljs-comment">[x]</span> &lt; dp<span class="hljs-comment">[y]</span>)&#123;<br>        swap(x,y);<br>    &#125;<br>    for(int j = 19;j &gt;= 0;j --)&#123;<br>        if(dp<span class="hljs-comment">[f<span class="hljs-comment">[x]</span><span class="hljs-comment">[i]</span>]</span> &gt;= dp<span class="hljs-comment">[y]</span>)&#123;<br>            x = f<span class="hljs-comment">[x]</span><span class="hljs-comment">[i]</span>;<br>        &#125;<br>    &#125;<br>    if(x == y)&#123;<br>        return x;<br>    &#125;<br>    for(int j = 19;j &gt;= 0;j --)&#123;<br>        if(dp<span class="hljs-comment">[f<span class="hljs-comment">[x]</span><span class="hljs-comment">[j]</span>]</span> != dp<span class="hljs-comment">[f<span class="hljs-comment">[y]</span><span class="hljs-comment">[j]</span>]</span>)&#123;<br>            x = f<span class="hljs-comment">[x]</span><span class="hljs-comment">[j]</span>;<br>            y = f<span class="hljs-comment">[y]</span><span class="hljs-comment">[j]</span>;<br>        &#125;<br>    &#125;<br>    return f<span class="hljs-comment">[x]</span><span class="hljs-comment">[0]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用树上差分"><a class="markdownIt-Anchor" href="#应用树上差分"></a> 应用：树上差分</h2><p>给定一棵树 n 个节点，有 m 次操作，每次操作给出 u，v 两个节点，将 u-v 路径上的所有点权值 +1。之后查询每个点的点权。</p><p>想法：联系<a href="https://janezair.site/2025/04/05/AlgorithmOfDS2/#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%92%8C%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">树状数组区间修改</a></p><p><strong>差分树上节点加 1 ，代表从根节点到该节点的路径上的节点都加 1</strong></p><h2 id="经典例子清理蜘蛛网"><a class="markdownIt-Anchor" href="#经典例子清理蜘蛛网"></a> 经典例子：清理蜘蛛网</h2><p>放个题：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2193">清理蜘蛛网 ACMOJ</a><br />想法一个是图的存储，我一开始试图用树存储，发现整个存储结构一片混乱。无奈最后投向邻接表（注意必须是邻接表而不是邻接矩阵，不然你将无法过编）<br />还有树上差分（边的差分），更新起点终点（++）和lca点（-= 2）<br />以及前缀和的计算，result[u] = diff[u] + sum(children diff[sn])<br />还有体现附加边的作用，<strong>骨架边断开的机会</strong>分类讨论。<br />总结：一道很难想也不太好写的题，主播写了至少1个多小时（还是在有思路的情况下）</p><p>贴个AC代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;cmath&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br>struct edge &#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>&#125;;<br>struct ver &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">value</span>;<br>    edge *head;<br>&#125;;<br>ver g[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> fa[<span class="hljs-number">100005</span>][<span class="hljs-number">21</span>];<br><span class="hljs-type">int</span> diff[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100005</span>];<br><span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;next = g[u].head;<br>    g[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> f,<span class="hljs-type">int</span> h) &#123;<br>    fa[sn][<span class="hljs-number">0</span>] = f;<br>    dp[sn] = h;<br>    edge *e = g[sn].head;<br>    <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(e-&gt;<span class="hljs-keyword">end</span> != f) &#123;<br>            dfs(e-&gt;<span class="hljs-keyword">end</span>,sn,h + <span class="hljs-number">1</span>);<br>        &#125;<br>        e = e-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> lca(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">if</span>(dp[x] &lt; dp[y]) &#123;<br>        swap(x,y);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">19</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(dp[fa[x][j]] &gt;= dp[y]) &#123;<br>            x = fa[x][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x == y) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">19</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(fa[x][j] != fa[y][j]) &#123;<br>            x = fa[x][j];<br>            y = fa[y][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-type">void</span> calculate(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> fa) &#123;<br>    edge *e = g[sn].head;<br>    <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(e-&gt;<span class="hljs-keyword">end</span> != fa) &#123;<br>            calculate(e-&gt;<span class="hljs-keyword">end</span>,sn);<br>            diff[sn] += diff[e-&gt;<span class="hljs-keyword">end</span>];<br>        &#125;<br>        e = e-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> u,v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        g[i].head = nullptr;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        addEdge(u,v);<br>        addEdge(v,u);<br>    &#125;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">20</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>            fa[i][j] = fa[fa[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">int</span> LCA = lca(a,b);<br>        diff[a] ++;<br>        diff[b] ++;<br>        diff[LCA] -= <span class="hljs-number">2</span>;<br>    &#125;<br>    calculate(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    long long <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(diff[i] == <span class="hljs-number">0</span>) &#123;<br>            total += m;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff[i] == <span class="hljs-number">1</span>) &#123;<br>            total ++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; total;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        edge *e = g[i].head;<br>        edge *tmp;<br>        <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>            tmp = e;<br>            e = e-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><hr /><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>并查集是一种用于管理元素所属集合的数据结构。实现为一个<strong>森林</strong>，其中<strong>每棵树表示一个集合</strong>，树中的节点表示对应集合中的元素。</p><h2 id="2种基本操作"><a class="markdownIt-Anchor" href="#2种基本操作"></a> 2种基本操作</h2><h3 id="union-合并"><a class="markdownIt-Anchor" href="#union-合并"></a> Union 合并</h3><p>合并两个元素所属集合（合并对应的树）</p><h3 id="find-查询"><a class="markdownIt-Anchor" href="#find-查询"></a> Find 查询</h3><p>用于判断 2 个元素是否属于一个集合</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p><strong>父亲存储法</strong>：只需要一个数组 f 存储每个节点的父亲即可。</p><p><strong>查询</strong>：只要沿着树找到a, b所在树的根节点fa, fb，若fa, fb相等则两个节点在同一个集合中</p><p><strong>合并</strong>：先沿着树找到a, b所在树的根节点fa, fb，再令f[fa] = fb, 将两树合并</p><h2 id="并查集优化"><a class="markdownIt-Anchor" href="#并查集优化"></a> 并查集优化</h2><h3 id="降低树高"><a class="markdownIt-Anchor" href="#降低树高"></a> 降低树高</h3><h3 id="查询中的路径压缩"><a class="markdownIt-Anchor" href="#查询中的路径压缩"></a> 查询中的路径压缩</h3><p>查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。<br /><strong>在从x到根结点的路径上的每一个结点都将自己的父结点改为根结点。</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gml">int find(<span class="hljs-variable language_">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(parent[<span class="hljs-variable language_">x</span>] != <span class="hljs-variable language_">x</span>)&#123;<br>        parent[<span class="hljs-variable language_">x</span>] = find(parent[<span class="hljs-variable language_">x</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[<span class="hljs-variable language_">x</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启发式合并"><a class="markdownIt-Anchor" href="#启发式合并"></a> 启发式合并</h3><p>我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> unite(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)&#123;<br>    <span class="hljs-keyword">int</span> rootX = <span class="hljs-keyword">find</span>(x);<br>    <span class="hljs-keyword">int</span> rootY = <span class="hljs-keyword">find</span>(y);<br><br>    <span class="hljs-keyword">if</span>(rootX == rootY)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">size</span>[rootX] &lt; <span class="hljs-keyword">size</span>[rootY])&#123;<br>        parent[rootX] = rootY;<br>        <span class="hljs-keyword">size</span>[rootY] += <span class="hljs-keyword">size</span>[rootX];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        parent[rootY] = rootX;<br>        <span class="hljs-keyword">size</span>[rootX] += <span class="hljs-keyword">size</span>[rootY];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="生成树"><a class="markdownIt-Anchor" href="#生成树"></a> 生成树</h1><p>连通图 G 的生成树（Spanning Tree）是包含G的所有节点的树。</p><p>在有权图中，**最小生成树（MST）**是指总权值最小的一棵生成树。</p><p><strong>切割性质</strong>：假设将图中的顶点划分为两个互不相交的集合，那么连接这两个集合的所有边中，权重最小的边一定属于某棵最小生成树。</p><h2 id="kruskal-算法求解mst-较为常用"><a class="markdownIt-Anchor" href="#kruskal-算法求解mst-较为常用"></a> Kruskal 算法——求解MST  （较为常用）</h2><p>Core:<strong>对边排序，每次取出权值最小的边尝试加入，如果不成环则加入，直到全图连通。</strong></p><h2 id="prim-算法求解mst"><a class="markdownIt-Anchor" href="#prim-算法求解mst"></a> Prim 算法——求解MST</h2><p><strong>从任意一个点开始，选距离集合最近的节点加入集合，直到全图连通</strong></p><h1 id="综合dsmst和lca"><a class="markdownIt-Anchor" href="#综合dsmst和lca"></a> 综合DS,MST和LCA</h1><p>老规矩先贴题：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1898">货车运输</a><br />此题lz开始的想法是Floyd暴力dp，显然会炸。后来打算暴搜，显然也会炸。无奈只得点开luogu题解，发现是蓝题🤡<br />个人觉得最妙的是想到使用最大生成树，把较小的边删掉，在得到的最大生成树上（Kruskal得树，邻接表dfs建树）进行LCA操作，得到LCA后相当于求解出了唯一的一条路径，在遍历这条路径求个最小值就好了<br />另外lz总觉得最后的遍历有点儿暴力，感觉可以多维护一些东西，让查询复杂度来到O(1)？没仔细想，以为会T，结果居然1Y飘过了🤣<br />贴个代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> parent[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> Size[<span class="hljs-number">10005</span>];<br>struct edge &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br><span class="hljs-type">void</span> merge(const edge *aBegin, const edge *aEnd, const edge *bBegin,<br>           const edge *bEnd, edge *c) &#123;<br>    <span class="hljs-keyword">while</span> (aBegin != aEnd &amp;&amp; bBegin != bEnd) &#123;<br>        <span class="hljs-keyword">if</span> (bBegin-&gt;weight &gt; aBegin-&gt;weight) &#123;<br>            *c = *bBegin;<br>            ++bBegin;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            *c = *aBegin;<br>            ++aBegin;<br>        &#125;<br>        ++c;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; aBegin != aEnd; ++aBegin, ++c) *c = *aBegin;<br>    <span class="hljs-keyword">for</span> (; bBegin != bEnd; ++bBegin, ++c) *c = *bBegin;<br>&#125;<br><span class="hljs-type">void</span> merge_sort(edge *a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>    <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>    merge_sort(a, l, mid), merge_sort(a, mid, r);<br>    edge* tmp = <span class="hljs-built_in">new</span> edge[r - l + <span class="hljs-number">1</span>];<br>    merge(a + l, a + mid, a + mid, a + r, tmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; r; ++i) a[i] = tmp[i - l];<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br><span class="hljs-type">int</span> find(<span class="hljs-type">int</span> u) &#123;<br>    <span class="hljs-keyword">if</span>(parent[u] != u) &#123;<br>        parent[u] = find(parent[u]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[u];<br>&#125;<br><span class="hljs-type">void</span> unite(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-type">int</span> rootX = find(x);<br>    <span class="hljs-type">int</span> rootY = find(y);<br>    <span class="hljs-keyword">if</span>(rootX != rootY) &#123;<br>        <span class="hljs-keyword">if</span>(Size[rootX] &gt; Size[rootY]) &#123;<br>            parent[rootY] = rootX;<br>            Size[rootX] += Size[rootY];<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            parent[rootX] = rootY;<br>            Size[rootY] += Size[rootX];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> u,v,w;<br>edge Graph[<span class="hljs-number">50005</span>];<br>edge MST[<span class="hljs-number">10005</span>];<br>struct adjEdge &#123;<br>    adjEdge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct adjVer &#123;<br>    adjEdge *head;<br>&#125;;<br>adjVer adjMST[<span class="hljs-number">10005</span>];//最大生成树邻接表<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w) &#123;<br>    adjEdge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> adjEdge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = w;<br>    <span class="hljs-keyword">current</span>-&gt;next = adjMST[u].head;<br>    adjMST[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> fa[<span class="hljs-number">10005</span>][<span class="hljs-number">21</span>];<br><span class="hljs-type">int</span> depth[<span class="hljs-number">10005</span>];<br><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> f,<span class="hljs-type">int</span> h) &#123;<br>    fa[sn][<span class="hljs-number">0</span>] = f;<br>    depth[sn] = h;<br>    adjEdge *<span class="hljs-keyword">current</span> = adjMST[sn].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span> != f) &#123;<br>            dfs(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>,sn,h + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> lca(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-keyword">if</span>(depth[u] &lt; depth[v]) &#123;<br>        swap(u,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">20</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(depth[fa[u][j]] &gt;= depth[v]) &#123;<br>            u = fa[u][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(u == v) &#123;<br>        <span class="hljs-keyword">return</span> u;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">20</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(fa[u][j] != fa[v][j]) &#123;<br>            u = fa[u][j];<br>            v = fa[v][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-type">int</span> findVal(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    adjEdge *<span class="hljs-keyword">current</span> = adjMST[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;end == v) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span>-&gt;weight;<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> getMin(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> lca) &#123;<br>    <span class="hljs-type">int</span> Min = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span>(u != lca) &#123;<br>        <span class="hljs-type">int</span> v = findVal(u,fa[u][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span>(v &lt; Min) &#123;<br>            Min = v;<br>        &#125;<br>        u = fa[u][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> Min;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        parent[i] = i;<br>        Size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        Graph[i].start = u;<br>        Graph[i].end = v;<br>        Graph[i].weight = w;<br>    &#125;<br>    merge_sort(Graph,<span class="hljs-number">1</span>,m + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        <span class="hljs-type">int</span> rst = find(Graph[i].<span class="hljs-keyword">start</span>);<br>        <span class="hljs-type">int</span> rnd = find(Graph[i].<span class="hljs-keyword">end</span>);<br>        <span class="hljs-keyword">if</span>(rst != rnd) &#123;<br>            unite(rst,rnd);<br>            MST[++cnt] = Graph[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= cnt;i ++) &#123;<br>        add_edge(MST[i].<span class="hljs-keyword">start</span>,MST[i].<span class="hljs-keyword">end</span>,MST[i].weight);<br>        add_edge(MST[i].<span class="hljs-keyword">end</span>,MST[i].<span class="hljs-keyword">start</span>,MST[i].weight);<br>    &#125;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">20</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>            fa[i][j] = fa[fa[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    cin &gt;&gt; q;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= q;i ++) &#123;<br>        cin &gt;&gt; <span class="hljs-keyword">start</span> &gt;&gt; <span class="hljs-keyword">end</span>;<br>        <span class="hljs-keyword">if</span>(find(<span class="hljs-keyword">start</span>) != find(<span class="hljs-keyword">end</span>)) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> LCA = lca(<span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>);<br>            cout &lt;&lt; min(getMin(<span class="hljs-keyword">start</span>,LCA),getMin(<span class="hljs-keyword">end</span>,LCA)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>LCA</tag>
      
      <tag>Disjoint Set</tag>
      
      <tag>MST</tag>
      
      <tag>Kruskal</tag>
      
      <tag>Prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic 10 Halting Problem</title>
    <link href="/2025/05/11/Mathematical-Logic10/"/>
    <url>/2025/05/11/Mathematical-Logic10/</url>
    
    <content type="html"><![CDATA[<h1>Mathematical Logic 10 Halting Problem</h1><hr><h2 id="R-computable">R-computable</h2><p>Let F: A* -&gt; B* (A,B are 2 alphabets)</p><p>(1)A program P computes F if for all w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A*, P: w-&gt;F(w)</p><p>(2)F is R-computable if there is a program which computes F.</p><hr><h2 id="Halting-Problem-for-the-register-machine">Halting Problem for the register machine</h2><hr><h2 id="Godel-numbering">Gödel numbering</h2><p>Def:<br>B:= A U {A,B,…,Z} U {0,1,…,9} U {=,+,-,|}.<br>Words in B* are ordered lexicographically(字典序).</p><p><strong>Encode</strong> each program as a word in B*<br>Example:<br>0LETR1 = R1 - a0|1PRINT|2HALT.</p><p>Assume that this word is the n-th word in the lexicographical ordering of B∗.Then we set:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">w_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">p</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0a_0...a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>(n times)</p><p>Π := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A }.</p><p>The mapping P-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is called <strong>Gödel numbering</strong>.<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is called the <strong>Gödel number</strong> of P.</p><p><strong>Π is R-decidable.</strong></p><h2 id="Π’halt-is-not-R-decidable">Π’halt is not R-decidable.</h2><p>Π’halt := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A and P:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>-&gt;halt}<br>PF:<br>Assume that P0 decides Π’halt<br>0 …<br>1 …<br>…<br>10 PRINT<br>…<br>k HALT</p><p>We can build a P1<br>0 …<br>1 …<br>…<br>10 IF R = □ THEN k ELSE k or k or k… or k<br>…<br>k IF R = □ THEN k ELSE k+1 or k+1 or k+1… or k+1<br>k+1 HALT</p><p>Clearly contradict!</p><h2 id="Πhalt-is-not-R-decidable">Πhalt is not R-decidable.</h2><p>Πhalt := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A and P: □ -&gt;halt}</p><p>PF:<br>Build P+:<br>P : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> -&gt; halt  -&gt; P+ : □ -&gt; halt</p><p>A further program T:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> -&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>P</mi><mo>+</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{P+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p>With P0 and T we design a program which <strong>decides Π’halt</strong>. On any w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A∗:</p><ul><li>the program first test whether w = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> for some P.If not, it rejects immediately.</li><li>Otherwise, it uses T to computes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>P</mi><mo>+</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{P+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>. Then the program calls P0 on input wP+.</li><li>It correctly decides whether P : wP -&gt; halt.</li></ul><hr><h2 id="The-undecidability-of-first-order-logic-see-u-next-time">The undecidability of first-order logic.(see u next time)</h2>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.006 Shortest Path Algorithm</title>
    <link href="/2025/05/09/Introduction-to-Algorithms4/"/>
    <url>/2025/05/09/Introduction-to-Algorithms4/</url>
    
    <content type="html"><![CDATA[<h1>MIT 6.006 4 Shortest Path Algorithm</h1><h2 id="Overview">Overview</h2><ul><li>Weighted Graph</li><li>General Approaches</li><li>Negative Edges</li><li>Optimal Substructure</li></ul><p>Mainly <strong>2 Algorithms</strong>：<br><strong>Dijkstra</strong> with O(V + E) for <strong>non-negative edge weights</strong><br><strong>Bellman Ford</strong> with O(EV) for <strong>general case</strong></p><h2 id="Weighted-Graph">Weighted Graph</h2><h3 id="Single-Source-Shortest-Paths">Single Source Shortest Paths</h3><p>Data Structure:<br>d[v] = value inside circles<br>= 0 (if v = s) or ∞ (otherwise)<br>= δ(s,v) (at the end)<br>with δ(s,v) &lt;= d[v] (all the times)</p><p>π[v] = predecessor on the best path to v</p><p><img src="/img/WGSP.png" alt="Example"></p><h2 id="Negative-Weight-Edges">Negative-Weight Edges</h2><p>You may get an endless loop like below:<br><img src="/img/NWG.png" alt="Example"></p><p>That’s a bad negative circle.</p><h2 id="General-Structure-Of-SP-Algorithm">General Structure Of SP Algorithm</h2><p><img src="/img/GCSP.png" alt="General Idea"></p><h2 id="Triangle-Inequality">Triangle Inequality</h2><p>Thm:<br>For all u,v,x <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> X, we have</p><p>δ(u,v) &lt;= δ(u,x) + δ(x,v)</p><p>You may use this idea in Floyd Algorithm.</p><h2 id="DAG-（Directed-Acyclic-Graph-有向无环图）">DAG （Directed Acyclic Graph 有向无环图）</h2><p>No cycles！</p><p>1.Topologically sort the DAG.<br>2.One pass over vertices in topologically sorted order relaxing each edge that<br>leaves each vertex.</p><p><img src="/img/DAG.png" alt="DAG Example"></p><p>using <strong>Dynamic Programming</strong> O(V + E)</p><h2 id="Dijkstra-Algorithm">Dijkstra Algorithm</h2><p><img src="/img/Dijkstra.png" alt="Dijkstra"></p><p>Core Idea:<br><strong>For each edge (u, v) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> E, assume w(u, v) ≥ 0, maintain a set S of vertices whose final shortest path weights have been determined. Repeatedly select u <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> V − S with minimum shortest path estimate, add u to S, relax all edges out of u.</strong></p><h3 id="Pseudo-code">Pseudo-code</h3><p><img src="/img/DijkstraCode.png" alt="Dijkstra Code"></p><h2 id="Dijkstra-Complexity-Analysis">Dijkstra Complexity Analysis</h2><p>V times : insert into pq<br>V times : extract min<br>E times : decrease key</p><h3 id="Array">Array</h3><p>V times : extract min<br>1 time  : decrease key</p><p>Total: O(V^2 + E)</p><h3 id="Binary-Min-Heap">Binary Min Heap</h3><p>lgV times: extract min<br>lgV times: decrease key</p><p>Total: O(VlgV + ElgV)</p><h3 id="Fibonacci-heap">Fibonacci heap</h3><p>lgV times: extract min<br>1 time  : decrease key</p><p>Total: O(VlogV + E)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Shortest Path</tag>
      
      <tag>Bellman Ford</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic9</title>
    <link href="/2025/05/06/Mathematical-Logic9/"/>
    <url>/2025/05/06/Mathematical-Logic9/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：终于和计算机相关了😭😭😭😭😭他真的，我哭死。好玩！但怀疑作业依然不会做。。。">Before：终于和计算机相关了😭😭😭😭😭他真的，我哭死。好玩！但怀疑作业依然不会做。。。</h4><h1>Mathematical Logic 9 Decidability and Enumerability</h1><h1>可判定性 和 可枚举性</h1><h2 id="Desicion-problems-判定问题">Desicion problems 判定问题</h2><p>判断给定输入是否满足特定性质</p><p>i.e<br>设 A* 是有限字母表上的字符串集合<br>input : w<br>满足某种性质 : w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*</p><p>判定问题的特征函数定义为：<br>f = 1 （w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W）<br>f = 0 （otherwise）</p><h2 id="Decidability-可判定性">Decidability 可判定性</h2><p>Def:<br>P 是对于性质W的<strong>一个判定程序（decision procedure for W）</strong>，如果：<br>对于每个输入w，P终会停机，且输出一些w’使得：</p><ul><li>如果 w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W，则w’ 为空串</li><li>否则，w’不为空串</li></ul><p>我们称 W 是可判定的，如果存在这样的一个P</p><h2 id="Enumerability-可枚举性">Enumerability 可枚举性</h2><p>Def:<br>设A 是一个字母表，且 W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*.我们称P 是 W 的一个枚举程序，如果：<br>（在没有任何输入的情况下）P输出了W 中的所有单词（以某种顺序且可能重复）</p><p>我们称 W 是可枚举的，如果存在这样的一个P</p><h2 id="Lemma-about-Enumerability">Lemma about Enumerability</h2><h3 id="Lemma-9">Lemma 9</h3><p>如果W存在这样的一个枚举程序，那么 W 就一定存在一个没有重复的枚举程序</p><h3 id="Lemma-10">Lemma 10</h3><p>如果A 是有限的，那么A* 是可枚举的。</p><h2 id="Decidability-VS-Enumerability">Decidability VS Enumerability</h2><h3 id="Thm-11">Thm 11</h3><p>所有可判定的集合都是可枚举的。</p><h3 id="Thm-12">Thm 12</h3><p>设W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*. W 是可判定的当且仅当 W 和 A*\ W 是可枚举的。</p><h2 id="Q4：Can-computers-find-proofs？">Q4：Can computers find proofs？</h2><p><img src="/img/Turing.png" alt="Alan Turing"></p><p><strong>Undecidability of FO</strong></p><p><strong>any computer program cannot decide whether an arbitrary input mathematical statement has a proof</strong></p><h2 id="Register-Machine">Register Machine</h2><p>基本模型：<br>有限个寄存器R0,…,Rm,每个都可以存储字母表A 上的字符串。</p><p>一个程序由有限条指令组成，每一条都被标记为L <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> N</p><h2 id="Instruction-Type">Instruction Type</h2><ul><li><p>L LET R_i = R_i + a_j<br>It is to add aj at the end of the word in Ri.</p></li><li><p>L LET R_i = R_i - a_j<br>If the word w in Ri ends with aj, then delete this aj; otherwise leave w unchanged.</p></li><li><p>L if Ri = - then L′ else L0 or L1 or · · · or Lr<br>It is to jump to a new location according to the ending letter of the word in Ri.</p></li><li><p>L PRINT<br>It is to output the word in R0.</p></li><li><p>L HALT<br>It is to halt the program.</p></li></ul><h2 id="Register-Program">Register Program</h2><p>A program P starts with w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A* if in the beginning of the execution of P we have R0 = w and all other Ri are empty.</p><h2 id="R-Decidability">R-Decidability</h2><p>W is <strong>register-decidable, or R-decidable</strong> for short, if there is a register program which decides W.</p><h2 id="R-Enumerability">R-Enumerability</h2><p>W is <strong>register-enumerable, or R-enumerable</strong> for short, if there is a register program which enumerates W.</p><h2 id="Proposition-15">Proposition 15</h2><p>设W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*. W 是R-decidable 当且仅当 W 和 A*\ W 是R-enumerable的。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Segment Tree</title>
    <link href="/2025/04/20/AlgorithmOfDS3/"/>
    <url>/2025/04/20/AlgorithmOfDS3/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：Long-time-no-see！最近强度激增，B-树de了一整天，还有MLE和TLE，感觉是某个地方写爆栈了😢数理逻辑作业还没写完，下周还要复习数分。">Before：Long time no see！最近强度激增，B+树de了一整天，还有MLE和TLE，感觉是某个地方写爆栈了😢数理逻辑作业还没写完，下周还要复习数分。</h4><h4 id="upd：昨天晚上过了，打算51把管理系统速通了，挑点bonus写一下（其实想全写但显然没空），弥补一下bookstore啥bonus都没写的遗憾。希望周五数分顺利！">upd：昨天晚上过了，打算51把管理系统速通了，挑点bonus写一下（其实想全写但显然没空），弥补一下bookstore啥bonus都没写的遗憾。希望周五数分顺利！</h4><h1>Algorithm Of Data Structure —— Segment Tree</h1><h2 id="Definition">Definition</h2><ul><li>二叉树</li><li>每一个叶子节点维护原序列的信息</li><li>每个中间结点维护一段区间信息</li><li>通过子节点的高效信息合并得到中间节点的区间信息</li></ul><p>An example of Segment Tree:<br><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91.png" alt="Simple Segment Tree"></p><h2 id="Basic-Rules">Basic Rules</h2><ul><li>Apparently,线段树是一棵完全二叉树，故树高 h = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span></span></span></span></li><li>结点总数约为 2n，故O(n) = 2n</li><li>每个结点代表一个区间[l,r]，并维护该区间的信息，如区间内的数字和、最大(小)值等。该区间信息由两个分别代表[l, mid],[mid+1, r]的子结点合并而来。</li></ul><h2 id="Storage">Storage</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span></span>&#123;<br>    struct TreeNode&#123;<br>        <span class="hljs-keyword">int</span> l,r; <span class="hljs-regexp">//</span>左右端点<br>        <span class="hljs-keyword">int</span> lson,rson; <span class="hljs-regexp">//</span>左右儿子编号<br>        <span class="hljs-keyword">int</span> data; <span class="hljs-regexp">//</span>关键数据<br>    &#125;nodes[maxN &lt;&lt; <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>问题来了，存树的数组应该开多大？<br>通过一些数学证明，我们可以得到，数组应该开成 <strong>4n</strong>。</p><h2 id="Build-Tree">Build Tree</h2><p><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%98%E5%82%A8.png" alt="Build Segment Tree"></p><p>Example：求区间最大值</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void push_up(int <span class="hljs-keyword">node</span><span class="hljs-title">)&#123;</span><br><span class="hljs-title">    auto</span> &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    cur</span>.data = max(nodes[cur.lson],nodes[cur.rson]);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void build(int <span class="hljs-keyword">node</span><span class="hljs-title">,int</span> l,int r)&#123;<br>    auto &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    cur</span>.l = l;<br>    cur.r = r;<br>    if(l == r)&#123;<br>        cur.data = data[l];<br>        return;<br>    &#125;<br>    auto mid = (l + r) / <span class="hljs-number">2</span>;<br>    cur.lson = <span class="hljs-number">2</span> * <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">    cur</span>.rson = <span class="hljs-number">2</span> * <span class="hljs-keyword">node</span> <span class="hljs-title">+ 1</span>;<br>    build(cur.lson,l,mid);<br>    build(cur.rson,mid + <span class="hljs-number">1</span>,r);<br>    push_up(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Query">Query</h2><p>A Good Picture!<br><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%9F%A5%E8%AF%A2.png" alt="Query"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> node,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123;<br>    auto &amp;cur = nodes[node];<br>    <span class="hljs-built_in">if</span>(l &lt;= cur.l &amp;&amp; cur.r &lt;= r)&#123;<br>        return cur.data;<br>    &#125;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (l + r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">if</span>(l &lt;= <span class="hljs-built_in">mid</span>)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,query(cur.lson,l,r));<br>    &#125;<br>    <span class="hljs-built_in">if</span>(r &gt; <span class="hljs-built_in">mid</span>)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,query(cur.rson,l,r));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Single-Point-Update">Single Point Update</h2><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs hsp">void update(<span class="hljs-keyword">int</span> node,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,<span class="hljs-keyword">int</span> val)&#123;<br>    auto &amp;cur = nodes[node]<span class="hljs-comment">;</span><br>    <span class="hljs-keyword">if</span>(cur.lson == cur.rson)&#123;<br>        cur.data = val<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">return</span><span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = (cur.l + cur.r)/<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span> &lt;= mid)&#123;<br>        update(cur.lson,<span class="hljs-keyword">pos</span>,val)<span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span> &gt; mid)&#123;<br>        update(cur.rson,<span class="hljs-keyword">pos</span>,val)<span class="hljs-comment">;</span><br>    &#125;<br>    push_up(node)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Range-Update">Range Update</h2><p>区间查询的核心思想：区间信息上放<br>复杂度：O(logN)</p><p>区间修改能不能也使用相同的思想？<br>若将区间 [l, r] 内元素都加上某个值:</p><ul><li>若维护最值，直接 cur.data+=val</li><li>若维护区间和，则 cur.data+=(r −l+1)∗ val <br>发现：有时我们会对整棵子树做同样的操作</li></ul><p>Solution: Lazy Tag!</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span></span>&#123;<br>    struct TreeNode&#123;<br>        <span class="hljs-keyword">int</span> l,r; <span class="hljs-regexp">//</span>左右端点<br>        <span class="hljs-keyword">int</span> lson,rson; <span class="hljs-regexp">//</span>左右儿子编号<br>        <span class="hljs-keyword">int</span> lazy_tag;<br>        <span class="hljs-keyword">int</span> data; <span class="hljs-regexp">//</span>关键数据<br>    &#125;nodes[maxN &lt;&lt; <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">void modify(<span class="hljs-built_in">int</span> node,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>    auto &amp;cur = nodes[node];<br>    <span class="hljs-keyword">if</span>(l &lt;= cur.l &amp;&amp; cur.r &lt;= r)&#123;<br>        cur.data += <span class="hljs-keyword">val</span>;<br>        cur.lazytag += <span class="hljs-keyword">val</span>;<br>        return;<br>    &#125;<br>    push_down(node);<br>    <span class="hljs-built_in">int</span> mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid)&#123;<br>        modify(cur.lson,l,r,<span class="hljs-keyword">val</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid)&#123;<br>        modify(cur.rson,l,r,<span class="hljs-keyword">val</span>);<br>    &#125;<br>    push_up(node);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void push_down(int <span class="hljs-keyword">node</span><span class="hljs-title">)&#123;</span><br><span class="hljs-title">    auto</span> &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    if</span>(cur.lazytag != <span class="hljs-number">0</span>)&#123;<br>        nodes[cur.lson].data += cur.lazytag;<br>        nodes[cur.rson].data += cur.lazytag;<br>        nodes[cur.lson].lazytag = cur.lazytag;<br>        nodes[cur.rson].lazytag = cur.lazytag;<br>        cur.lazytag = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Template-Problem">Template Problem</h2><p>已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上 x；</li><li>将某区间每一个数加上 x；</li><li>求出某区间每一个数的和。</li></ul><p>(add_tag,mul_tag)------(* k)-----&gt;(add_tag * k,mul_tag * k)<br>(add_tag,mul_tag)------(+ k)-----&gt;(add_tag + k,mul_tag)</p><p>AC代码捏</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;iostream&gt;<br>using namespace std;<br>long long int n,m,mod;<br>long long int num[<span class="hljs-number">100005</span>];<br>struct <span class="hljs-symbol">SegmentTree</span> &#123;<br>    long long int l,r;<br>    long long int lson,rson;<br>    long long int lazytag;<br>    long long int multiTag = <span class="hljs-number">1</span>;<br>    long long int data;<br>&#125;nodes[<span class="hljs-number">400005</span>];<br>void push_up(long long int node) &#123;<br>    auto &amp;cur = nodes[node];<br>    cur.data = nodes[cur.lson].data + nodes[cur.rson].data;<br>    cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>&#125;<br>void push_down(long long int node) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.multiTag != <span class="hljs-number">1</span>) &#123;<br>        nodes[cur.lson].multiTag *= cur.multiTag;<br>        nodes[cur.lson].multiTag = (nodes[cur.lson].multiTag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].multiTag *= cur.multiTag;<br>        nodes[cur.rson].multiTag = (nodes[cur.rson].multiTag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].lazytag *= cur.multiTag;<br>        nodes[cur.lson].lazytag = (nodes[cur.lson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].lazytag *= cur.multiTag;<br>        nodes[cur.rson].lazytag = (nodes[cur.rson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].data *= cur.multiTag;<br>        nodes[cur.lson].data = (nodes[cur.lson].data + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].data *= cur.multiTag;<br>        nodes[cur.rson].data = (nodes[cur.rson].data + mod)<span class="hljs-comment">%mod;</span><br>        cur.multiTag = <span class="hljs-number">1</span>;<br>    &#125;<br>    if(cur.lazytag != <span class="hljs-number">0</span>) &#123;<br>        nodes[cur.lson].lazytag += cur.lazytag;<br>        nodes[cur.lson].lazytag = (nodes[cur.lson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].lazytag += cur.lazytag;<br>        nodes[cur.rson].lazytag = (nodes[cur.rson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].data += (nodes[cur.lson].r - nodes[cur.lson].l + <span class="hljs-number">1</span>)*cur.lazytag;<br>        nodes[cur.lson].data = (nodes[cur.lson].data + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].data += (nodes[cur.rson].r - nodes[cur.rson].l + <span class="hljs-number">1</span>)*cur.lazytag;<br>        nodes[cur.rson].data = (nodes[cur.rson].data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>void buildTree(long long int node,long long int l,long long int r) &#123;<br>    auto &amp;cur = nodes[node];<br>    cur.multiTag = <span class="hljs-number">1</span>;<br>    cur.l = l;<br>    cur.r = r;<br>    if(l == r) &#123;<br>        cur.data = num[l];<br>        return;<br>    &#125;<br>    long long int mid = (l + r)/<span class="hljs-number">2</span>;<br>    cur.lson = <span class="hljs-number">2</span> * node;<br>    cur.rson = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>;<br>    buildTree(cur.lson,l,mid);<br>    buildTree(cur.rson,mid + <span class="hljs-number">1</span>,r);<br>    push_up(node);<br>&#125;<br>void update(long long int node,long long int l,long long int r,long long int val) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.l &gt;= l &amp;&amp; cur.r &lt;= r) &#123;<br>        cur.data += (cur.r - cur.l + <span class="hljs-number">1</span>)*val;<br>        cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag += val;<br>        cur.lazytag = (cur.lazytag + mod)<span class="hljs-comment">%mod;</span><br>        return;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    if(l &lt;= mid) &#123;<br>        update(cur.lson,l,r,val);<br>    &#125;<br>    if(r &gt; mid) &#123;<br>        update(cur.rson,l,r,val);<br>    &#125;<br>    push_up(node);<br>&#125;<br>void update2(long long int node,long long int l,long long int r,long long int val) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.l &gt;= l &amp;&amp; cur.r &lt;= r) &#123;<br>        cur.data *= val;<br>        cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag *= val;<br>        cur.lazytag = (cur.lazytag + mod)<span class="hljs-comment">%mod;</span><br>        cur.multiTag *= val;<br>        cur.multiTag = (cur.multiTag + mod)<span class="hljs-comment">%mod;</span><br>        return;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    if(l &lt;= mid) &#123;<br>        update2(cur.lson,l,r,val);<br>    &#125;<br>    if(r &gt; mid) &#123;<br>        update2(cur.rson,l,r,val);<br>    &#125;<br>    push_up(node);<br>&#125;<br>long long int query(long long int node,long long int l,long long int r) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(l &lt;= cur.l &amp;&amp; cur.r &lt;= r) &#123;<br>        return cur.data;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    long long int res = <span class="hljs-number">0</span>;<br>    if(l &lt;= mid) &#123;<br>        res += query(cur.lson,l,r);<br>    &#125;<br>    res = (res + mod)<span class="hljs-comment">%mod;</span><br>    if(r &gt; mid) &#123;<br>        res += query(cur.rson,l,r);<br>    &#125;<br>    res = (res + mod)<span class="hljs-comment">%mod;</span><br>    return res;<br>&#125;<br>int main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; num[i];<br>    &#125;<br>    buildTree(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    long long int x,y,k;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        int op;<br>        cin &gt;&gt; op;<br>        if(op == <span class="hljs-number">2</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>            update(<span class="hljs-number">1</span>,x,y,k);<br>        &#125;else if(op == <span class="hljs-number">3</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            cout &lt;&lt; query(<span class="hljs-number">1</span>,x,y) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;else if(op == <span class="hljs-number">1</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>            update2(<span class="hljs-number">1</span>,x,y,k);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特别值得注意的是，push_down时应该先更新multiTag，再更新addTag（先乘后加的原则）</p><h2 id="Classic-Problem">Classic Problem</h2><p><a href="http://poj.org/problem?id=3667">POJ 3667 - Hotel</a></p><p>现有一排房间</p><ul><li>询问：是否有连续x个空房间；如果有，就将最靠前的连续x个房间填满</li><li>修改：将任意一段房间清空(可能本来就是空的)</li></ul><p>每个结点维护子树区间内左端极长、右端极长和最长空房间（l_max,r_max,max）<br>Tag：full/null/empty</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Segment Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic Cheating Paper</title>
    <link href="/2025/04/19/Mathematical-Logic8/"/>
    <url>/2025/04/19/Mathematical-Logic8/</url>
    
    <content type="html"><![CDATA[<h1>ML CT Paper</h1><h2 id="前言">前言</h2><p>这是留给25级往后ACM班学弟学妹的一份遗产了，很详细地总结了CS2950 Mathematical Logic这门课程涉及的主要知识点（有所删减）。特别值得注意的是，我在25.6.5晚在前三位作者整理的基础上，增添了6个example，是拟合了近3年ML Final的结果。今晚考完，更觉得整理地挺到位（精准吧 这是能说的嘛🤣）。分数还没出，也不知道实际到底考的怎样😢 但从这门抽象的课中，我学到了很多。这门课的意义就在于，它真正改变了我们看待数学的观点，让我们去定义我们写了这么多年的证明，用了这么多年的公理。我觉得这是一门很很有意思的课（但这门课的难度还是很大的，做好心理准备吧🤣🤣🤣）</p><h2 id="LaTeX-源码">LaTeX 源码</h2><p><a href="https://latex.sjtu.edu.cn/5789875599fpdzxjcfzrgw#7dce86">https://latex.sjtu.edu.cn/5789875599fpdzxjcfzrgw#7dce86</a></p><p>可以根据个人需要删改</p><h2 id="PDF版本">PDF版本</h2><p><img src="/img/CTP1.png" alt="Page_1"></p><p><img src="/img/CTP2.png" alt="Page_2"></p><h2 id="Acknowledgement-排名不分先后">Acknowledgement (排名不分先后)</h2><ul><li><a href="https://github.com/Ancker-0">Coffish</a></li><li><a href="https://github.com/Monkey-Lee0">Monkey_Lee</a></li><li><a href="https://github.com/Sakura-Dusk">Sakura_Dusk</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modern Cpp</title>
    <link href="/2025/04/14/Modern-Cpp/"/>
    <url>/2025/04/14/Modern-Cpp/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：上机课偶遇modern-cpp，拼劲全力无法战胜">Before：上机课偶遇modern cpp，拼劲全力无法战胜</h4><h1>Modern Cpp</h1><h2 id="Overview！">Overview！</h2><p>关于C++的刻板印象是什么？😋<br>笔者在学习了Java（以及相当烂的py）后，深深地感受到了C++语法规则以及一些奇奇怪怪的规定的复杂😇😇。总结一下C++：</p><ul><li>Old, out-dated, less-frequently used</li><li>Unsafe （特别对，救命啊）</li><li>Hard to use</li><li>Various Complication Issues</li></ul><p>Anyway,we still need to learn <strong>Modern Cpp</strong>.<br>We will cover:</p><ul><li>std::move and value types</li><li>Type inference and std::forward</li><li>auto inference</li><li>Syntax sugar</li><li>Smart pointers</li><li>Safety</li></ul><h2 id="Value-Types">Value Types</h2><h3 id="左值-右值">左值 右值</h3><ul><li>左值表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。可以用&amp;</li><li>右值则相反，是一个临时对象，不可以用&amp;</li></ul><p>我们知道有2种赋值方式：拷贝赋值和移动赋值。对于a = xxx:</p><ul><li>拷贝赋值函数：xxx为左值</li><li>移动赋值函数：xxx为右值</li></ul><h3 id="Move-for-lvalue？std-move">Move for lvalue？std::move!</h3><p>一个Common sense是移动move比拷贝要快，如果我们想<strong>移动一个左值呢</strong>？</p><p><strong>我们可以用std::move</strong> for this.<br>std::move可以让编译器认为某个左值是一个右值，进行了<strong>所有权的转移</strong>，使用了std::move后的对象不可再使用。</p><p><code>const</code>变量不可以使用移动语义。<br><strong>Notice：以下地方不可用std::move</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">void Print(const std::string &amp;s);<br>std::string <span class="hljs-built_in">Concat</span>(const std::string &amp;p, std::string q) &#123;<br>    ∕∕ Move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> const <span class="hljs-selector-tag">var</span><br>    std::string tmp = std::<span class="hljs-built_in">move</span>(p);<br><br>    ∕∕ Move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> rvalue<br>    std::string tmp2 = std::<span class="hljs-built_in">move</span>(p + q);<br>    std::string ret = p + q;<br><br>    ∕∕ Move <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span> const value reference<br>    Print(std::<span class="hljs-built_in">move</span>(p + q));<br><br>    ∕∕ Move the return value or <span class="hljs-selector-tag">use</span> after move<br>    return std::<span class="hljs-built_in">move</span>(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>std::move的实现并不同于想象中的复杂类型转换，实际上它只用了<code>static_cast</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">∕∕ A sample implementation of std::move<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="hljs-function">type&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">move</span><span class="hljs-params">(_Tp&amp;&amp; <span class="hljs-type">__t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="hljs-type">__t</span>); &#125;<br></code></pre></td></tr></table></figure><h2 id="Universal-Reference-通用引用">Universal Reference 通用引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;param)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>如果传递的参数是左值（lvalue），则 T 会被推断为该类型的引用。如果传递的参数是右值（rvalue），则 T 会被推断为该类型的值类型。</strong><br>所以如果param是左值，T的类型会是int &amp;，那么param的类型会是int&amp; &amp;&amp;，C++会将其折叠为int&amp;。（<strong>引用折叠</strong>）</p><p>如果param是右值，T的类型会是int。那么param的类型会是int&amp;&amp;。<br>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;param)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_lvalue_reference_v&lt;T&gt;)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Left value passed. Type of param is &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Right value passed. Type of param is &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">func</span>(a);  <span class="hljs-comment">// 左值传递</span><br><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(b));  <span class="hljs-comment">// 右值传递</span><br><br>    <span class="hljs-type">int</span> &amp;c = a;<br>    <span class="hljs-built_in">func</span>(c);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-forward-完美转发">std::forward 完美转发</h2><p>笔者在<a href="https://stackoverflow.com/questions/8526598/how-does-stdforward-work-especially-when-passing-lvalue-rvalue-references">stackoverflow</a>上找了一些观点<br><strong>std::forward is really just syntactic sugar over static_cast&lt;T&amp;&amp;&gt;</strong>.Nicol Bolas CommentedDec 15, 2011 at 21:19</p><p><strong>The concepts that seems to be lacking is that type (for instance int) is not the same thing as “value category” (an int can be sometimes a lvalue if you use a variable int a, sometimes rvalue if you return it from a function int fun()). When you look at a parameter thing&amp;&amp; x its type is an rvalue reference, however, the variable named x also has a value category: it’s an lvalue. std::forward&lt;&gt; will make sure to convert the “value category” x to match its type. It makes sure a thing&amp; x is passed as a value category lvalue, and thing&amp;&amp; x passed as an rvalue.</strong> arkan CommentedOct 1, 2022 at 14:19</p><p>std::forward 的作用是根据模板参数的类型，将参数转发为左值或右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp; t)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-comment">//移除T的引用类型</span><br></code></pre></td></tr></table></figure><p>Attach a test:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-type">void</span> process(<span class="hljs-type">int</span>&amp; x) &#123;<br>    std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-type">void</span> process(<span class="hljs-type">int</span>&amp;&amp; x) &#123;<br>    std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;typename T&gt;<br><span class="hljs-type">void</span> <span class="hljs-keyword">wrapper</span>(T&amp;&amp; arg) &#123;<br>    process(std::forward&lt;T&gt;(arg));<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">wrapper</span>(a); // 输出 &quot;lvalue&quot;<br>    <span class="hljs-keyword">wrapper</span>(<span class="hljs-number">20</span>); // 输出 &quot;rvalue&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Auto-Reference-自动类型推断">Auto Reference 自动类型推断</h2><ul><li>auto可推断变量类型</li><li>auto&amp; 可推断引用类型</li><li>const auto&amp; 可推断常量引用</li></ul><p>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个包含整数的向量</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 auto&amp; 遍历向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : vec) &#123;<br>        <span class="hljs-comment">// 直接修改容器中的元素</span><br>        elem *= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出修改后的向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : vec) &#123;<br>        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="Important-Part-Smart-Pointers-智能指针">Important Part: Smart Pointers!智能指针</h2><h3 id="unique-ptr">unique_ptr</h3><p>一个Move Only的智能指针，只可以拥有一个拥有者。<br>Attach an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass created with name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destroyed with name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>&#125;;<br><br><span class="hljs-comment">// 函数接受一个 unique_ptr 并打印内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintUniquePtr</span><span class="hljs-params">(std::unique_ptr&lt;MyClass&gt; ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>        ptr-&gt;<span class="hljs-built_in">Print</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;unique_ptr is null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数返回一个 unique_ptr</span><br><span class="hljs-function">std::unique_ptr&lt;MyClass&gt; <span class="hljs-title">CreateUniquePtr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 unique_ptr</span><br>    std::unique_ptr&lt;MyClass&gt; myPtr = <span class="hljs-built_in">CreateUniquePtr</span>(<span class="hljs-string">&quot;Kimi&quot;</span>);<br><br>    <span class="hljs-comment">// 使用 unique_ptr</span><br>    myPtr-&gt;<span class="hljs-built_in">Print</span>();<br><br>    <span class="hljs-comment">// 将 unique_ptr 传递给另一个函数</span><br>    <span class="hljs-built_in">PrintUniquePtr</span>(std::<span class="hljs-built_in">move</span>(myPtr));<br><br>    <span class="hljs-comment">// myPtr 已经被移动，现在是空的</span><br>    <span class="hljs-keyword">if</span> (!myPtr) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;myPtr is now null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建另一个 unique_ptr</span><br>    std::unique_ptr&lt;MyClass&gt; anotherPtr = <span class="hljs-built_in">CreateUniquePtr</span>(<span class="hljs-string">&quot;Moonshot AI&quot;</span>);<br><br>    <span class="hljs-comment">// 使用 unique_ptr 的 reset 方法</span><br>    anotherPtr-&gt;<span class="hljs-built_in">Print</span>();<br>    anotherPtr.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 手动释放资源</span><br>    <span class="hljs-keyword">if</span> (!anotherPtr) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;anotherPtr is now null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MyClass created <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Kimi<br><span class="hljs-type">Name</span>: Kimi<br><span class="hljs-type">Name</span>: Kimi<br>MyClass destroyed <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Kimi<br>myPtr <span class="hljs-keyword">is</span> now <span class="hljs-keyword">null</span><br>MyClass created <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Moonshot AI<br><span class="hljs-type">Name</span>: Moonshot AI<br>MyClass destroyed <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Moonshot AI<br>anotherPtr <span class="hljs-keyword">is</span> now <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr">shared_ptr</h3><p>基本特性：</p><ul><li>可以有多个所有者，是可拷贝的，但需要注意循环引用问题。</li><li>只有当所有拥有者都释放它时才会销毁（通过引用计数实现）。</li></ul><p><code>shared_ptr</code>的特殊用途<br>解决类之间的循环引用：<br>如果两个类相互包含对方的对象，会导致编译错误，因为C++需要在编译时知道类的大小。<br>使用shared_ptr可以解决这个问题，因为shared_ptr<T>只需要类的声明而不需要定义就可以使用。</p><p>Attach an example:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    // 其他方法和成员<br>private:<br>    std::shared_ptr&lt;B&gt; b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    // 其他方法和成员<br>private:<br>    std::shared_ptr&lt;A&gt; a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="weak-ptr">weak_ptr</h3><p>在使用智能指针shared_ptr的时候，可能会存在循环引用的问题，例如智能指针a指向智能指针b，智能指针b指向智能指针a。此时两个智能指针的引用计数都不为1，此时存在内存泄露，两个指针指向的内存不会被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;Node&gt; next;<br><br>    <span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node created\n&quot;</span>; &#125;<br><br>    ~<span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_bug_for_shared_ptr</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Node&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>    std::shared_ptr&lt;Node&gt; ptr2 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>    ptr1-&gt;next = ptr2;<br>    ptr2-&gt;next = ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_bug_for_shared_ptr</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br></code></pre></td></tr></table></figure><p><code>weak_ptr</code> 是 C++11 引入的一种智能指针，用于解决 <code>shared_ptr</code> 的循环引用问题。它允许一个对象安全地引用另一个对象，但不会增加引用计数。<br>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;B&gt; b_ptr;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::weak_ptr&lt;A&gt; a_ptr; <span class="hljs-comment">// 使用 weak_ptr 避免循环引用</span><br>    ~<span class="hljs-built_in">B</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建两个对象，避免循环引用</span><br>    &#123;<br>        std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>        std::shared_ptr&lt;B&gt; b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br><br>        <span class="hljs-comment">// A 持有 B 的 shared_ptr</span><br>        a-&gt;b_ptr = b;<br><br>        <span class="hljs-comment">// B 持有 A 的 weak_ptr</span><br>        b-&gt;a_ptr = a;<br><br>        <span class="hljs-comment">// 当作用域结束时，a 和 b 会被正确销毁</span><br>    &#125; <span class="hljs-comment">// 这里不会导致内存泄漏</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> destroyed<br><span class="hljs-selector-tag">B</span> destroyed<br></code></pre></td></tr></table></figure><h2 id="std-any">std::any</h2><p>功能：<br>允许在C++中以类似弱类型语言的方式使用变量。<br>可以存储任何类型的数据，并在需要时进行类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::any x = <span class="hljs-number">114514</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 2</span><br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br>    &#125;<br>    x = <span class="hljs-string">&quot;qwerty&quot;</span>; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 5</span><br>        std::cout &lt;&lt; (*ptr) + <span class="hljs-number">114514</span> &lt;&lt; std::endl; <span class="hljs-comment">// 6</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">114514<br><br></code></pre></td></tr></table></figure><p><code>auto ptr = std::any_cast&lt;int&gt;(&amp;x)</code>会判断ptr是否可以转化为一个int*类型的指针，如果可以就做取地址，如果不可以就变成<code>nullptr</code></p><h2 id="std-optional-and-std-variant">std::optional and std::variant</h2><h3 id="std-optional">std::optional</h3><ul><li>可以存储类型T的值或者什么也不存储（类似于指针，但更安全）。</li><li>用于表示可选值，避免使用裸指针带来的空指针问题。</li></ul><p>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-type">bool</span> returnValue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (returnValue) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 返回空</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 42</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No value&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 42</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No value&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Value:</span> <span class="hljs-number">42</span><br><span class="hljs-literal">No</span> <span class="hljs-string">value</span><br></code></pre></td></tr></table></figure><h3 id="std-variant">std::variant</h3><ul><li>可以存储多种类型的数据（类似于union，但使用起来更方便）。</li><li>用于存储不同类型的数据，并且可以在运行时安全地访问和转换。</li></ul><p>Attach an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 定义一个 std::variant，可以存储 int 或 std::string</span><br><span class="hljs-keyword">using</span> MyVariant = std::variant&lt;<span class="hljs-type">int</span>, std::string&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVariant</span><span class="hljs-params">(<span class="hljs-type">const</span> MyVariant&amp; v)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::visit 访问 std::variant</span><br>    std::<span class="hljs-built_in">visit</span>([](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;, v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 std::variant，初始值为 int</span><br>    MyVariant v1 = <span class="hljs-number">42</span>;<br>    <span class="hljs-built_in">printVariant</span>(v1); <span class="hljs-comment">// 输出: Value: 42</span><br><br>    <span class="hljs-comment">// 修改 std::variant 的值为 std::string</span><br>    v1 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    <span class="hljs-built_in">printVariant</span>(v1); <span class="hljs-comment">// 输出: Value: Hello, World!</span><br><br>    <span class="hljs-comment">// 创建一个 std::variant，初始值为 std::string</span><br>    MyVariant v2 = <span class="hljs-string">&quot;Another string&quot;</span>;<br>    <span class="hljs-built_in">printVariant</span>(v2); <span class="hljs-comment">// 输出: Value: Another string</span><br><br>    <span class="hljs-comment">// 修改 std::variant 的值为 int</span><br>    v2 = <span class="hljs-number">123</span>;<br>    <span class="hljs-built_in">printVariant</span>(v2); <span class="hljs-comment">// 输出: Value: 123</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><ul><li><a href="https://xiyuanyang-code.github.io/posts/Modern-C/">YXY 的Modern Cpp 学习笔记</a></li><li>Kimi AI（发现了kimi的好）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Modern Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic 7 Completeness 1</title>
    <link href="/2025/04/12/Mathematical-Logic7/"/>
    <url>/2025/04/12/Mathematical-Logic7/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：久违的数理逻辑课！上了7节课终于觉得有点入门了，还是挺有意思的。周四下午闪击南京，周五下午又闪击回来。虽然只有1天，但很开心在这短短的20个小时内帮助了不少人（都是无意间）。我要永远做个善良的人！">Before：久违的数理逻辑课！上了7节课终于觉得有点入门了，还是挺有意思的。周四下午闪击南京，周五下午又闪击回来。虽然只有1天，但很开心在这短短的20个小时内帮助了不少人（都是无意间）。我要永远做个善良的人！</h4><h1>Mathematical Logic 7 Completeness 1</h1><p>我们继续完备性的证明！<br>我们知道，要证明一阶逻辑的完备性，我们只需要证明：</p><p>Given a consisitent <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span>,it suffices to construct a term model <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{I}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> = (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">T</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup><mo separator="true">,</mo><msup><mrow><mi>β</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{T}^{\Phi},\mathfrak{\beta}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">T</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class=""><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>) such that:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{I}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> \iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⊢</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>.</p><p>昨晚室友问我为了体现完备性，就是要证明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> 难道不是在说对于任何一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> 上的模型，都能使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>为真吗？但是这里不是只找了一个模型吗？我想这应该是由于<strong>Henkin’s Term Model</strong>的特殊性，但这个留到后几节课再讨论了。</p><h2 id="Henkin’s-Term-Model-Recall-模型回顾">Henkin’s Term Model Recall 模型回顾</h2><p>首先引入等价类的概念：<br>Let $ t_1,t_2 $ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>.Then $ t_1 $ ~ $ t_2 $ if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⊢</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1\equiv t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≡</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>.</p><p>For every t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> we define:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>t</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.81508em;"></span><span class="strut bottom" style="height:0.81508em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> := {t’ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |t’ ~ t}</p><p><strong>Definition</strong><br>The term structure for (\Phi), denoted by (\mathfrak{I}^{\Phi}), is defined as follows.</p><ol><li><p><strong>Universe</strong>:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mrow><mi mathvariant="normal">Φ</mi></mrow></msup><mo>:</mo><mo>=</mo><mo>{</mo><mover accent="true"><mrow><mi>t</mi></mrow><mo stretchy="true">‾</mo></mover><mo>∣</mo><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup><mo>}</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">T^{\Phi} := \{\overline{t} \mid t \in T^S\}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">{</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mrel">∣</span><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Relation symbols</strong>:<br>For every \(n\)-ary relation symbol \(R \in S\), and \(\overline{t_1}, \ldots, \overline{t_n} \in T^{\Phi}\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mover accent="true"><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo><mo>∈</mo><msup><mi>R</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mspace width="1em"></mspace><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi></mtext><mspace width="1em"></mspace><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>R</mi><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(\overline{t_1}, \ldots, \overline{t_n}) \in R^{\mathfrak{I}^{\Phi}} \quad \text{if} \quad \Phi \vdash R t_1 \ldots t_n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:1.2087649999999999em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mspace quad"></span><span class="text mord textstyle uncramped"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span></span><span class="mord mspace quad"></span><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Function symbols</strong>:<br>For every \(n\)-ary function symbol \(f \in S\), and \(\overline{t_1}, \ldots, \overline{t_n} \in T^{\Phi}\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mo>(</mo><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mover accent="true"><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo><mo>:</mo><mo>=</mo><mi>f</mi><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo>⋯</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f^{\mathfrak{I}^{\Phi}} (\overline{t_1}, \ldots, \overline{t_n}) := f \overline{t_1} \cdots t_n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:1.2087649999999999em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">:</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="minner">⋯</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Constants</strong>:<br>For every constant \(c \in S\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mo>:</mo><mo>=</mo><mover accent="true"><mrow><mi>c</mi></mrow><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">c^{\mathfrak{I}^{\Phi}} := \overline{c}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:0.9587649999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">:</span><span class="mrel">=</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">c</span></span></span><span style="top:-0.5505599999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li></ol><p>For every variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,we let:<br>\mathfrak{\beta}^{\Phi}\(v_i\) := <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{v_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.63056em;"></span><span class="strut bottom" style="height:0.78056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.5505599999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span></p><h2 id="对于原子公式成立-atomic-varphi">对于原子公式成立 atomic <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span></h2><p><strong>Lemma 5</strong></p><p>(i) For any \( t \in T^S \),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>(</mo><mi>t</mi><mo>)</mo><mo>=</mo><mover accent="true"><mrow><mi>t</mi></mrow><mo>¯</mo></mover><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi(t) = \bar{t}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.18407999999999997em;margin-left:0.16668em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p><p>(ii) For every atomic \(\varphi\),<br>\mathfrak{I}^\Phi \models \varphi \iff \Phi \vdash \varphi.</p><p>(i)的证明，我们<strong>对项t进行归纳</strong>：</p><ul><li>t = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is a variable</li><li>t = c is a constant</li><li>t = f<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_1...t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li></ul><p>根据定义可证</p><p>(ii)的证明，对2个原子公式进行分类讨论：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><msub><mi>t</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models t_1 \equiv t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≡</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>R</mi><msub><mi>t</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models Rt_1...t_n    </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br>利用(i)中所证，可证</p><h2 id="Consistent-Negation-Complete-Contains-Witness">Consistent,Negation Complete,Contains Witness</h2><h3 id="Lemma-8">Lemma 8</h3><p>先看一个引理：</p><h1>Lemma 8</h1><p>Let (\varphi) be an (S)-formula and (x_1, \ldots, x_n) pairwise distinct variables. Then</p><h3 id="i">(i)</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi mathvariant="normal">∃</mi><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><mi mathvariant="normal">∃</mi><msub><mi>x</mi><mi>n</mi></msub><mi>φ</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \exists x_1 \ldots \exists x_n \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathrm">∃</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord mathrm">∃</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">φ</span></span></span></span><br><strong>if and only if</strong> there are (S)-terms (t_1, \ldots, t_n) such that<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>φ</mi><mfrac><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \varphi \frac{t_1 \ldots t_n}{x_1 \ldots x_n}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8455559999999999em;"></span><span class="strut bottom" style="height:1.295556em;vertical-align:-0.44999999999999996em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.4149999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mathrm">.</span></span></span></span></p><h3 id="ii">(ii)</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi mathvariant="normal">∀</mi><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><mi mathvariant="normal">∀</mi><msub><mi>x</mi><mi>n</mi></msub><mi>φ</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \forall x_1 \ldots \forall x_n \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathrm">∀</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord mathrm">∀</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">φ</span></span></span></span><br><strong>if and only if</strong> for all (S)-terms (t_1, \ldots, t_n) we have<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>φ</mi><mfrac><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \varphi \frac{t_1 \ldots t_n}{x_1 \ldots x_n}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8455559999999999em;"></span><span class="strut bottom" style="height:1.295556em;vertical-align:-0.44999999999999996em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.4149999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mathrm">.</span></span></span></span></p><p>由替换引理等可证</p><h3 id="Consistent">Consistent</h3><p><strong>Definition</strong><br><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is consistent if there is no <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> such that both <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> ⊢ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> ⊢ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>. Otherwise,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is inconsistent.</strong></p><h3 id="Negation-Complete">Negation Complete</h3><p><strong>Definition</strong><br>A set (\Phi) is <em>negation complete</em> if for every (S)-formula (\varphi):<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi><mtext><mtext> </mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mtext> </mtext></mtext><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">¬</mi><mi>φ</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi \text{ or } \Phi \vdash \neg \varphi.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mspace"> </span></span><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">¬</span><span class="mord mathit">φ</span><span class="mord mathrm">.</span></span></span></span></p><p>通俗的说，就是如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> 证不出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>，那就一定能证出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span>；证不出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span>，那就一定能证出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span></p><h3 id="Contains-Witness">Contains Witness</h3><h1>Definition</h1><p>🔍 A set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <strong>contains witnesses</strong> if for every <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>∈</mo><msup><mi>L</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">\varphi \in L^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> and every variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>, there exists a term <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">t \in T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> such that:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mrow><mo fence="true">(</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mi>φ</mi><mo>→</mo><mi>φ</mi><mfrac><mrow><mi>t</mi></mrow><mrow><mi>x</mi></mrow></mfrac><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \left( \exists x \varphi \to \varphi \frac{t}{x} \right).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathrm">∃</span><span class="mord mathit">x</span><span class="mord mathit">φ</span><span class="mrel">→</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord mathrm">.</span></span></span></span></p><h2 id="Henkin’s-Theorem-Proof">Henkin’s Theorem Proof</h2><p>First,还是先来证明一个引理：</p><h3 id="Lemma-9">Lemma 9</h3><p>Assume that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is <strong>consistent</strong>, <strong>negation complete</strong>, and <strong>contains witnesses</strong>. Then for all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>-formulas <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span></span></span></span>:</p><p>(i)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span></span></span></span> if and only if \Phi \not\vdash \neg \varphi.</p><p>(ii)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mo>(</mo><mi>φ</mi><mo>∨</mo><mi>ψ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Phi \vdash (\varphi \vee \psi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mopen">(</span><span class="mord mathit">φ</span><span class="mbin">∨</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mclose">)</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span></span></span></span>.</p><p>(iii)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \exists x \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">∃</span><span class="mord mathit">x</span><span class="mord mathit">φ</span></span></span></span> if and only if there is a term <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">t \in T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi><mfrac><mrow><mi>t</mi></mrow><mrow><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi \frac{t}{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>.</p><p>(i)向右通过consistent定义说明，向左通过negation complete定义说明<br>(ii)向左利用V-intro by succedent证明，向右证明如下：<br>Assume that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span><br><strong>Proof Steps:</strong><br><img src="/img/Lemma9.png" alt="Lemma 9(ii)Proof"></p><p>(iii)向右可通过Modus ponens证明，向左可通过\exist-intro in succedent证明</p><h3 id="Henkin’s-Theorem">Henkin’s Theorem</h3><p>由引理证明起来还是比较显然的：<br><img src="/img/Henkin.png" alt="Henkin's Theorem Proof"></p><p>注意，这里对公式的归纳是对公式的<strong>connective rank</strong>归纳，保证要证的公式都更长：<br><strong>Rank Definition:</strong><br>rk(\varphi) := \begin{cases} 0 & \text{if } \varphi \text{ is atomic,} \1 + rk(\psi) & \text{if } \varphi = \neg\psi, \1 + rk(\psi_1) + rk(\psi_2) & \text{if } \varphi = (\psi_1 \lor \psi_2), \1 + rk(\psi) & \text{if } \varphi = \exists x \psi. \end{cases}</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust RefCell机制</title>
    <link href="/2025/04/07/Rust-RefCell%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/07/Rust-RefCell%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：为什么要出一期挺莫名其妙的东西？起因还是机考，连续2次机考工程题一分没拿了（太菜了bushi），感觉对C-的各种机制很不熟悉，而Rust又是重要的一门现代编程语言。援引StanfordCS110L前言的一段话：">Before：为什么要出一期挺莫名其妙的东西？起因还是机考，连续2次机考工程题一分没拿了（太菜了bushi），感觉对C++的各种机制很不熟悉，而Rust又是重要的一门现代编程语言。援引<a href="https://reberhardt.com/cs110l/spring-2020/">StanfordCS110L</a>前言的一段话：</h4><h5 id="如果你学过-C-并接触过一些系统编程的话，应该对-C-的内存泄漏以及指针的危险有所耳闻，但-C-的底层特性以及高效仍然让它在系统级编程中无法被例如-Java-等自带垃圾收集机制的高级语言所替代。而-Rust-的目标则是希望在-C-的高效基础上，弥补其安全不足的缺点。因此-Rust-在设计之初，就有带有很多系统编程的观点。学习-Rust，也能让你之后能用-C-语言编写出更安全更优雅的系统级代码（例如操作系统等）。"><em>如果你学过 C 并接触过一些系统编程的话，应该对 C 的内存泄漏以及指针的危险有所耳闻，但 C 的底层特性以及高效仍然让它在系统级编程中无法被例如 Java 等自带垃圾收集机制的高级语言所替代。而 Rust 的目标则是希望在 C 的高效基础上，弥补其安全不足的缺点。因此 Rust 在设计之初，就有带有很多系统编程的观点。学习 Rust，也能让你之后能用 C 语言编写出更安全更优雅的系统级代码（例如操作系统等）。</em></h5><h1>Rust Learning _RefCell机制</h1><h2 id="Rust的所有权机制">Rust的所有权机制</h2><p>Rust的所有权机制要求每个值都有<strong>唯一的所有者</strong>（通常是变量），并且在同一时间内只能有一个所有者。所有权的转移可以通过赋值、函数参数传递或返回值来实现。相当于 C++ 中的移动语义（std::move()）</p><p>在一个值的所有者变量的作用域之外（例如在另外一个函数中）对该值的访问必须通过借用（相当于 C++ 中指向变量的指针）来实现。Rust 中的借用分为两种：</p><ul class="lvl-0"><li class="lvl-2"><p>不可变借用（Immutable Borrow）：相当于 C++ 中的 const T*，允许读取但不允许修改</p></li><li class="lvl-2"><p>可变借用（Mutable Borrow）：相当于 C++ 中的 T*，允许读取和修改</p></li></ul><p>Rust 对变量的借用有着严格的限制：</p><ul class="lvl-0"><li class="lvl-2"><p>在同一时间内，只能有<strong>一个可变借用，或者多个不可变借用</strong></p></li><li class="lvl-2"><p><strong>不能同时存在可变借用和不可变借用</strong></p></li><li class="lvl-2"><p>所有借用都必须在拥有变量的生命周期内有效，对以上规则的违反会导致编译错误。</p></li></ul><p>Rust 的借用机制对编译器优化非常有帮助。由于不可变借用不能与可变借用共存，**被不可变借用指向的值只需要从堆内存中获取一次，之后可以安全地存储在寄存器或栈上缓存中。*<em>相比之下，C++ 中也进行类似的优化，但其他函数修改 const</em> 指针指向的值是未定义行为，可能导致不安全的代码。</p><p>Rust 的编译器可以在编译时就能“静态”地检查所有权和借用关系，在运行时无需额外检查。然而，<strong>对于堆上对象，在编译期检查所有权和借用关系是非常困难的</strong>。因此，Rust 提供了 RefCell<T> 类型来在运行时检查所有权和借用关系。它有如下方法：</p><ul class="lvl-0"><li class="lvl-2"><p>borrow() 与 try_borrow()：获取一个不可变借用，返回 Ref<T> 类型。如果当前存在可变借用则失败。borrow() 会 panic，相当于 C++ 中的 abort，而 try_borrow() 返回一个 Result&lt;Ref<T>, BorrowError&gt;，相当于 C++ 中的 std::optional&lt;Ref<T>&gt;</p></li><li class="lvl-2"><p>borrow_mut() 与 try_borrow_mut()：获取一个可变借用，返回 RefMut<T> 类型。如果当前存在任何借用则会失败</p></li><li class="lvl-2"><p>返回的 Ref<T> 和 RefMut<T> 包装器实现了解引用操作符，可以像使用普通引用一样使用</p></li><li class="lvl-2"><p>当 Ref<T> 和 RefMut<T> 的生命周期结束时，会自动减少或重置借用计数</p></li><li class="lvl-2"><p>当 RefCell<T> 的生命周期结束时，若仍有借用存在，则会 panic</p></li></ul><h2 id="C-中的std-optional">C++中的std::optional</h2><p>编程中，我们经常会需要表示或处理一个“可能为空”的变量，可能是一个为包含任何元素的容器，可能是一个类型的指针没有指向任何有效的对象实例，再或者是一个对象没有被赋予有效的值。</p><p>C++17中的std::optional<T>为解决这类问题提供了简单的解决方案。optional<T>可以看作是T类型变脸与一个布尔值的打包。其中的布尔值用来表示T是否为“空”。<br>std::optional<T>可以：<strong>包含一个类型为T的值或者不包含任何值(处于&quot;空&quot;状态)</strong><br>不包含任何值显示表示为：std::nullopt</p><p>Advantage: 明确表示值可能存在或不存在；强制使用者考虑值缺失的情况；通常比使用指针或额外标志更高效</p><h2 id="C-中的const-成员函数">C++中的const 成员函数</h2><p><strong>在C++中，只有被声明为const的成员函数才能被一个const类对象调用。</strong><br>const 成员函数<strong>不能修改类的普通成员变量</strong><br>如果想修改，需加上mutable关键字，允许 const 成员函数修改内部计数器（确实这个关键字常见于计数器）</p><h2 id="剩余代码的实现">剩余代码的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCellError</span> : <span class="hljs-keyword">public</span> std::runtime_error &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCellError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : std::runtime_error(message) &#123;</span>&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RefCellError</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<span class="hljs-comment">// Abstract class as base class</span><br><br><span class="hljs-comment">//invalidly call an immutable borrow</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><span class="hljs-comment">//invalidly call a mutable borrow</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowMutError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowMutError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><span class="hljs-comment">//still has refs when destructed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructionError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DestructionError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCell</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>    <span class="hljs-comment">// TODO(student)</span><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_num;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_mut_num;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Forward declarations</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span>;<br><br>    <span class="hljs-comment">// Constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; initial_value)</span>:value(initial_value),borrow_mut_num(<span class="hljs-number">0</span>),borrow_num(<span class="hljs-number">0</span>) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(T &amp;&amp; initial_value)</span>:value(std::move(initial_value)),borrow_mut_num(<span class="hljs-number">0</span>),borrow_num(<span class="hljs-number">0</span>) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// Disable copying and moving for simplicity</span><br>    <span class="hljs-built_in">RefCell</span>(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">RefCell</span>(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// Borrow methods</span><br>    <span class="hljs-function">Ref <span class="hljs-title">borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        ++ borrow_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;Ref&gt; <span class="hljs-title">try_borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        ++ borrow_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">RefMut <span class="hljs-title">borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        ++ borrow_mut_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;RefMut&gt; <span class="hljs-title">try_borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        ++ borrow_mut_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Inner classes for borrows</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-type">const</span> RefCell* refcell;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Ref</span>(<span class="hljs-type">const</span> RefCell &amp;c):<span class="hljs-built_in">refcell</span>(&amp;c),<span class="hljs-built_in">valid</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br><br>        ~<span class="hljs-built_in">Ref</span>() &#123;<br>            <span class="hljs-keyword">if</span>(valid ) &#123;<br>                -- refcell-&gt;borrow_num;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-comment">// Allow copying</span><br>        <span class="hljs-built_in">Ref</span>(<span class="hljs-type">const</span> Ref&amp; other):<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            <span class="hljs-keyword">if</span>(valid)&#123;<br>                ++ refcell-&gt;borrow_num;<br>            &#125;<br>        &#125;<br>        Ref&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Ref&amp; other) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span>(valid) &#123;<br>                    -- refcell-&gt;borrow_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = other.valid;<br>                <span class="hljs-keyword">if</span>(valid)&#123;<br>                    ++ refcell-&gt;borrow_num;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Allow moving</span><br>        <span class="hljs-built_in">Ref</span>(Ref&amp;&amp; other) <span class="hljs-keyword">noexcept</span>:<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            <span class="hljs-comment">//TODO</span><br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Ref&amp; <span class="hljs-keyword">operator</span>=(Ref&amp;&amp; other) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    --refcell-&gt;borrow_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = <span class="hljs-literal">true</span>;<br>                other.valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//other = nullptr;</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// TODO(student)</span><br>        RefCell* refcell;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">RefMut</span>(RefCell &amp;c):<span class="hljs-built_in">refcell</span>(&amp;c),<span class="hljs-built_in">valid</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br><br>        ~<span class="hljs-built_in">RefMut</span>() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(valid ) &#123;<br>                -- refcell-&gt;borrow_mut_num;<br>            &#125;<br>        &#125;<br><br>        T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_mut_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> refcell-&gt;value;<br>        &#125;<br><br>        T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_mut_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-comment">// Disable copying to ensure correct borrow rules</span><br>        <span class="hljs-built_in">RefMut</span>(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br><br>        <span class="hljs-comment">// Allow moving</span><br>        <span class="hljs-built_in">RefMut</span>(RefMut&amp;&amp; other) <span class="hljs-keyword">noexcept</span>:<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid)  &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(RefMut&amp;&amp; other) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    --refcell-&gt;borrow_mut_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = other.valid;<br>                other.valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//other = nullptr;</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor</span><br>    ~<span class="hljs-built_in">RefCell</span>() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num &gt; <span class="hljs-number">0</span> || borrow_num &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DestructionError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        borrow_mut_num = <span class="hljs-number">0</span>;<br>        borrow_num = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2641">stargazer 的 RefCell</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/hhdshg/article/details/103433781">C++17之std::optional全方位详解</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Rust</tag>
      
      <tag>Const</tag>
      
      <tag>Memory Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Of DS——Fenwick Tree &amp; Sparse Table</title>
    <link href="/2025/04/05/AlgorithmOfDS2/"/>
    <url>/2025/04/05/AlgorithmOfDS2/</url>
    
    <content type="html"><![CDATA[<h4 id="before20250329must-be-one-of-the-best-days-in-2025i-cant-tell-you-why-and-i-beg-you-dont-ask-me-whyi-just-hope-to-be-like-her-and-continue-chasing-after-my-dreamjust-like-her-and-themwhatever-it-takesi-just-cant-help-being-excited-about-this-wonderful-meeting-in-xuhuishanghai-hope-everything-will-be-alright"><a class="markdownIt-Anchor" href="#before20250329must-be-one-of-the-best-days-in-2025i-cant-tell-you-why-and-i-beg-you-dont-ask-me-whyi-just-hope-to-be-like-her-and-continue-chasing-after-my-dreamjust-like-her-and-themwhatever-it-takesi-just-cant-help-being-excited-about-this-wonderful-meeting-in-xuhuishanghai-hope-everything-will-be-alright"></a> Before：2025.03.29，must be one of the best days in 2025.I can’t tell you why and I beg you don’t ask me why.I just hope to be like her and continue chasing after my dream,just like her and them.Whatever it takes.I just can’t help being excited about this wonderful meeting in Xuhui,Shanghai. Hope everything will be alright.</h4><p><img src="/img/xuhui.jpg" alt="2025.03.29晚-徐家汇-上海" /></p><h1 id="algorithm-of-ds-2-fenwick-tree-and-sparse-table"><a class="markdownIt-Anchor" href="#algorithm-of-ds-2-fenwick-tree-and-sparse-table"></a> Algorithm of DS 2 Fenwick Tree and Sparse Table</h1><h1 id="fenwick-tree-树状数组"><a class="markdownIt-Anchor" href="#fenwick-tree-树状数组"></a> Fenwick Tree 树状数组</h1><p>一点点feeling：1~base在算法题里还是很香的😢</p><h2 id="单点修改与区间查询"><a class="markdownIt-Anchor" href="#单点修改与区间查询"></a> 单点修改与区间查询</h2><p>对于序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,...,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>我们要支持一下操作：<br />（1）单点修改其中某个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />（2）查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>A problem we first met in the <strong>Chunking</strong> with a time complexity of O(n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>).（上机课上助教反复说过，可以用《线段树和树状数组解决》）所以要介绍的就是《<strong>树状数组</strong>》来解决这个经典问题。</p><p>如下图所示，就展示了一个树状数组求解前缀和的很好的例子：<br /><img src="/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" alt="树状数组" /></p><p>首先我们介绍树状数组中的<strong>预处理函数</strong>——lowbit函数！</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<span class="hljs-comment">//有时可能需要开成long long int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不难知道，这其实是x二进制表示下从右往左第一个出现1的位置。<br />每一个树状数组c[x]管辖的范围其实是：[x - lowbit(x) + 1,x]<br />为求得前缀和，每次回退lowbit(x)，得到新的x（新的起点）。如此往复，直到x = 0，代码实现如下：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml">int query(int <span class="hljs-variable language_">x</span>)&#123;<br>    int ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">x</span> &gt; <span class="hljs-number">0</span>)&#123;<br>        ans += c[<span class="hljs-variable language_">x</span>];<br>        <span class="hljs-variable language_">x</span> -= lowbit(<span class="hljs-variable language_">x</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我需要得到区间[x,y]之间的和，则：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">return <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>而对于更新操作，我们需要对第x位后包括x的所有树状数组的和进行加w的操作，相当于是一个逆过程：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-type">void</span> update(int <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span>int w)&#123;<br>    while(<span class="hljs-keyword">x</span> &lt;<span class="hljs-operator">=</span> n)&#123;<br>        <span class="hljs-keyword">c</span>[<span class="hljs-keyword">x</span>] +<span class="hljs-operator">=</span> w<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">x</span> +<span class="hljs-operator">=</span> lowbit(<span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间修改和单点查询"><a class="markdownIt-Anchor" href="#区间修改和单点查询"></a> 区间修改和单点查询</h2><p>似乎略有变化，实则并无变化，只是我们维护的树状数组c[x]是对于差分数组的。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">d<span class="hljs-comment">[i]</span> = a<span class="hljs-comment">[i]</span> - a<span class="hljs-comment">[i-1]</span>;<br></code></pre></td></tr></table></figure><p>查询操作很简单，就是对差分数组求一个前缀和，函数实现一模一样。<br />如果要对某一区间[x,y]内的所有数进行一个 + w的操作，观察到，当i <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> [x + 1,y]时，d[i]不会发生变化，我们只需要修改首尾两处的d[i]即可，进行操作:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">update</span>(x,w);<br><span class="hljs-built_in">update</span>(y + <span class="hljs-number">1</span>,-w);<br></code></pre></td></tr></table></figure><h2 id="区间修改与区间查询"><a class="markdownIt-Anchor" href="#区间修改与区间查询"></a> 区间修改与区间查询</h2><p>又有了一些小变化，不妨列出来看一看：<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} \Sigma_{j = 1}^{i} d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span><br />= k * d[1] + (k - 1) * d[2] + … + 1 * d[k]<br />= (k + 1) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>i</mi><mo>∗</mo><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} i * d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></p><p>可见事实上我们只需要再多维护一个id[i]的树状数组就可以了(in fact 是这次小作业的某一题)，召唤术：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2665">区间修改与查找</a><br />hint：校外用户对不住了，ACMOJ只对sjtu内部开放😢😢</p><h2 id="二维树状数组"><a class="markdownIt-Anchor" href="#二维树状数组"></a> 二维树状数组</h2><p>Show me the Problem!<br />给定一个二维数组A，要求实现以下操作：<br />（1）单点修改A[x][y]<br />（2）单点查询A[x][y]<br />（3）子矩阵和查询：(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为左上角，(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为右下角<br />（4）子矩阵修改：(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为左上角，(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为右下角，所有元素加w</p><p>类似地建立树状数组c[x][y]表示以(x - lowbit(x) + 1,y - lowbit(y) + 1)为左上角，(x,y)为右下角的子矩阵的信息。<br />对于单点修改，思路大致不变，核心在于先固定一个然后修改另一个，使用循环嵌套：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x;i &lt;= n;i += <span class="hljs-built_in">lowbit</span>(i))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &lt;= m;j += <span class="hljs-built_in">lowbit</span>(j))&#123;<br>            c[i][j] += w;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于子矩阵的查询，想法和一维也是一致的（若左上角为(1,1)）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x;i &gt; <span class="hljs-number">0</span>;i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &gt; <span class="hljs-number">0</span>;j -= <span class="hljs-built_in">lowbit</span>(j))&#123;<br>            ans += c[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>而如果是任意的子矩阵，可以通过容斥原理来解决：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">return <span class="hljs-built_in">query</span>(x2,y2) - <span class="hljs-built_in">query</span>(x1,y2) - <span class="hljs-built_in">query</span>(x2,y1) + <span class="hljs-built_in">query</span>(x1,y1);<br></code></pre></td></tr></table></figure><p>What about <strong>区间修改和单点查询</strong>?<br />Redefine 差分数组：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">d[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span>] = a[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span>] - a[<span class="hljs-variable language_">x</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">y</span>] - a[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span> - <span class="hljs-number">1</span>] + a[<span class="hljs-variable language_">x</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">y</span> - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>对差分数组构建一个树状数组，单点查询就被转变为了区间前缀和。</p><p>而对于区间修改，通过观察+想象（或者逻辑推演）可知：只需要对4个角进行修改，具体表现为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">update</span>(x1,y1,w);<br><span class="hljs-built_in">update</span>(x1,y2 + <span class="hljs-number">1</span>,-w);<br><span class="hljs-built_in">update</span>(x2,y1 + <span class="hljs-number">1</span>,-w);<br><span class="hljs-built_in">update</span>(x2 + <span class="hljs-number">1</span>,y2 + <span class="hljs-number">1</span>,w);<br></code></pre></td></tr></table></figure><h2 id="another-经典应用树状数组求解逆序对数"><a class="markdownIt-Anchor" href="#another-经典应用树状数组求解逆序对数"></a> Another 经典应用——树状数组求解逆序对数</h2><p>核心在于:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> ans =  <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>    ans += query(maxN) - query(<span class="hljs-built_in">num</span>[i]);<br>    update(<span class="hljs-built_in">num</span>[i],<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果num[i]范围过大，可以采用离散化的方式防止RE😢😰<br />下面附上离散化的代码（de死我了，遇到了各种离谱的bug）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span> &#123;<br>    <span class="hljs-type">int</span> Data;<br>    <span class="hljs-type">int</span> pos;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">const</span> number*abegin,<span class="hljs-type">const</span> number*aend,<span class="hljs-type">const</span> number*bbegin,<span class="hljs-type">const</span> number*bend,number*c)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (abegin != aend &amp;&amp; bbegin != bend) &#123;<br>        <span class="hljs-keyword">if</span>(abegin-&gt;Data &lt; bbegin-&gt;Data) &#123;<br>            *c = *abegin;<br>            abegin ++;<br>            c ++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            *c = *bbegin;<br>            bbegin ++;<br>            c ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(abegin != aend) &#123;<br>        *c = *abegin;<br>        abegin ++;<br>        c ++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(bbegin != bend) &#123;<br>        *c = *bbegin;<br>        bbegin ++;<br>        c ++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(number *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(r - l &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(a,mid,r);<br>    <span class="hljs-keyword">auto</span> *tmp = <span class="hljs-keyword">new</span> number[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">merge</span>(a + l,a + mid,a + mid,a + r,tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; r;i ++) &#123;<br>        a[i] = tmp[i - l];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br><span class="hljs-type">int</span> c[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> tem[<span class="hljs-number">500005</span>];<br>number a[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> w)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(x &lt;= n) &#123;<br>        c[x] += w;<br>        x += <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) &#123;<br>        ans += c[x];<br>        x -= <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> pairNum = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; a[i].Data;<br>        a[i].pos = i;<br>    &#125;<br>    <span class="hljs-built_in">merge_sort</span>(a,<span class="hljs-number">1</span>,n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> id = <span class="hljs-number">1</span>;<br>    tem[a[<span class="hljs-number">1</span>].pos] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(a[i].Data == a[i - <span class="hljs-number">1</span>].Data) &#123;<br>            tem[a[i].pos] = id;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            tem[a[i].pos] = ++ id;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        pairNum += <span class="hljs-built_in">query</span>(id) - <span class="hljs-built_in">query</span>(tem[i]);<br>        <span class="hljs-built_in">update</span>(tem[i],<span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; pairNum;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sparse-table-st表"><a class="markdownIt-Anchor" href="#sparse-table-st表"></a> Sparse Table ST表</h1><p>ST 表（Sparse Table，稀疏表）是用于解决<strong>可重复贡献问题</strong>的数据结构。</p><h2 id="rmq问题"><a class="markdownIt-Anchor" href="#rmq问题"></a> RMQ问题</h2><p>Problem First😢😢😢：<br />给定n个数，m次询问，对于每个询问，回答区间[l,r]中的最大值。</p><p>我们发现区间最大值是一个具有「可重复贡献」性质的问题。即使用来求解的预处理区间有重叠部分，只要这些区间的并是所求的区间，最终计算出的答案就是正确的。我们能使用至多两个预处理过的区间来覆盖询问区间，也就是说询问时的时间复杂度可以被降至O(1)，在处理有大量询问的题目时十分有效。</p><p>令f(i,j)表示区间[i,i + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span> - 1]区间上的最大值。对于每个询问，我们把它分为[l,l + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span> - 1]和[r - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span> + 1,r]，其中s = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">log_2{r - l + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span>。</p><p>鉴于log操作计算量较大（double），我们考虑用一个函数手写一下：（和OiWiki上的想法不太一样，但感觉能用）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        x /= <span class="hljs-number">2</span>;<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是预处理：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>    cin &gt;&gt; f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是倍增处理了：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">for(int i = <span class="hljs-number">1</span><span class="hljs-comment">;i &lt;= 21;i ++)&#123; //如果数据是1e6级的，那么21就查不多了，甚至不用调用函数再算一下</span><br>    for(int <span class="hljs-keyword">j </span>= <span class="hljs-number">1</span><span class="hljs-comment">;i + (1 &lt;&lt; j) - 1 &lt;= n;j ++)&#123;</span><br>        f[i][<span class="hljs-keyword">j] </span>= std::max(f[i][<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>],f[i + (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>))][<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当查询时，就更简单了：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int s = log(r - l + 1);<br>cout &lt;&lt; std::max(f<span class="hljs-comment">[i]</span><span class="hljs-comment">[s]</span>,f<span class="hljs-comment">[r - (1 &lt;&lt; s) + 1]</span><span class="hljs-comment">[s]</span>);<br></code></pre></td></tr></table></figure><h2 id="超级经典问题与众不同"><a class="markdownIt-Anchor" href="#超级经典问题与众不同"></a> 超级经典问题——与众不同！</h2><p>指路：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2183">与众不同</a><br />思路：记f(i)表示以第i个位置为结尾的最长完美序列的左端点位置，容易发现f(i)是不降的对于一个[l,r]的询问，我们将区间中的点分成左右两部分，左边的点满足f(i)&lt;L,右边的点满足f(i)≥L, 对于左边的点我们可以直接算出答案，对于右边的点我们可以用st表区间询问求得答案。</p><p>上代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> LastExist[<span class="hljs-number">2000005</span>];<br><span class="hljs-type">int</span> position[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">200005</span>][<span class="hljs-number">20</span>];//ST表<br><span class="hljs-type">int</span> LOG(<span class="hljs-type">int</span> x) &#123;<br>    <span class="hljs-type">int</span> i = - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(x) &#123;<br>        x /= <span class="hljs-number">2</span>;<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    std::ios::sync_with_stdio(<span class="hljs-keyword">false</span>);<br>    cin.tie(<span class="hljs-number">0</span>); <br>    cout.tie(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        x += <span class="hljs-number">1000001</span>;<br>        position[i] = max(position[i - <span class="hljs-number">1</span>],LastExist[x] + <span class="hljs-number">1</span>);<br>        LastExist[x] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> l,r;<br>    //ST表初始化<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = i - position[i] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">21</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k + (<span class="hljs-number">1</span> &lt;&lt;j) - <span class="hljs-number">1</span> &lt;= n ;k ++) &#123;<br>            f[k][j] = max(f[k][j - <span class="hljs-number">1</span>],f[k + (<span class="hljs-number">1</span>&lt;&lt;(j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i ++) &#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l ++;<br>        r ++;<br>        <span class="hljs-type">int</span> maxLength = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> newstart = - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = l;j &lt;= r;j ++) &#123;<br>            <span class="hljs-keyword">if</span>(position[j] &lt; l) &#123;<br>                maxLength = j - l + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                newstart = j;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(newstart ==  - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; maxLength &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> s = LOG(r - newstart + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> another = max(f[newstart][s],f[r - (<span class="hljs-number">1</span> &lt;&lt; s) + <span class="hljs-number">1</span>][s]);<br>        <span class="hljs-keyword">if</span>(another &gt; maxLength) &#123;<br>            maxLength = another;<br>        &#125;<br>        cout &lt;&lt; maxLength &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://oi-wiki.org/ds/fenwick/">树状数组</a></li><li><a href="https://oi-wiki.org/ds/sparse-table/">ST表</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Fenwick Tree</tag>
      
      <tag>Sparse Table</tag>
      
      <tag>RMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic6</title>
    <link href="/2025/03/28/Mathematical-Logic6/"/>
    <url>/2025/03/28/Mathematical-Logic6/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：稍有强度的一周，主要表现在…超级大的数学物理数理逻辑强度，但感觉经过3、4天的摸爬滚打，基本上还是搞明白了😇还有平安度过的XZJT（感觉还是挺成功的？maybe）继续加油！">Before：稍有强度的一周，主要表现在…超级大的数学物理数理逻辑强度，但感觉经过3、4天的摸爬滚打，基本上还是搞明白了😇还有平安度过的XZJT（感觉还是挺成功的？maybe）继续加油！</h5><h5 id="ps：昨天小姐姐double-happy了🥰🥰">ps：昨天小姐姐double happy了🥰🥰</h5><h1>Mathematical Logic 6</h1><h2 id="Call-back-Introduction-to-Sequent-Calculus">Call back: Introduction to Sequent Calculus</h2><p><strong>10 Basic Rules</strong></p><ol><li class="lvl-3"><p>Antecedent</p></li><li class="lvl-3"><p>Assumption</p></li><li class="lvl-3"><p>Case Analysis</p></li><li class="lvl-3"><p>Contradiction</p></li><li class="lvl-3"><p>V-introduction in antecedent</p></li><li class="lvl-3"><p>V-introduction in succedent</p></li><li class="lvl-3"><p>∃ -introduction in succedent</p></li><li class="lvl-3"><p>∃ -introduction in antecedent</p></li><li class="lvl-3"><p>Equality</p></li><li class="lvl-4"><p>Substitution</p></li></ol><p>Every Basic Rules is correct.(can be proved)</p><p><strong>Derived Rules 1</strong></p><ol><li class="lvl-3"><p>Excluded middle</p></li><li class="lvl-3"><p>Modified Contradiction</p></li><li class="lvl-3"><p>Chain Deduction</p></li></ol><p><strong>Derived Rules 2</strong><br>Modus Ponens<br>$\Gamma \vdash \varphi \rightarrow \psi $<br>$\Gamma \vdash \varphi$<br>—————————<br>$\Gamma \vdash \psi$<br><strong>Derived Rules 3</strong><br>1.Symmetry of $\equiv$<br>$\Gamma \vdash t_1 \equiv t_2$<br>—————————<br>$\Gamma \vdash t_2 \equiv t_1$</p><p>2.Transitivity of $\equiv$<br>$\Gamma \vdash t_1 \equiv t_2$<br>$\Gamma \vdash t_2 \equiv t_3$<br>—————————<br>$\Gamma \vdash t_1 \equiv t_3$</p><p>3.For n-ary relation symbol R $\in$ S<br>can be proved by using Substitution Lemma<br>$\Gamma \vdash R t_1 \ldots t_n  $<br>$\Gamma \vdash t_1 \equiv t’_1 $<br>$\Gamma \vdash t_2 \equiv t’_2 $<br>$\cdots \cdots$<br>$\Gamma \vdash t_n \equiv t’_n $<br>—————————<br>$\Gamma \vdash R t’_1 \ldots t’_n$</p><p>4.For n-ary function symbol R $\in$ S<br>can also be proved by using Substitution Lemma<br>$\Gamma \vdash t_1 \equiv t’_1 $<br>$\Gamma \vdash t_2 \equiv t’_2 $<br>$\cdots \cdots$<br>$\Gamma \vdash t_n \equiv t’_n $<br>—————————<br>$\Gamma \vdash f t_1 \ldots t_n \equiv f t’_1 \ldots t’_n$</p><p><strong>Soundness</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Defintion</p></li><li class="lvl-2"><p>Lemma 1</p></li><li class="lvl-2"><p>Theorem 2(<strong>Soundness</strong>)<br>If $\Phi \vdash \varphi$,then $\Phi \vDash \varphi$</p></li></ul><p>Opposite is <strong>Completeness</strong> and we will prove it in later lessons.</p><h2 id="Consistency">Consistency</h2><p><strong>Defintion</strong><br><strong>$\Phi$ is consistent if there is no $\varphi$ such that both $\Phi$ ⊢ $\varphi$ and $\Phi$ ⊢ $\neg$$\varphi$. Otherwise,$\Phi$ is inconsistent.</strong></p><p><strong>Lemma3</strong>: $\Phi$ is inconsistent if and only if $\Phi \vdash \varphi$ for any formulas $\varphi$.<br>This can be proved by using <strong>Modified Contradiction</strong>.</p><p><strong>Lemma 4</strong>: $\Phi$ is consistent if and only if there is a $\varphi$ such that $\Phi \not\models \varphi$.<br>This can be proved by using <strong>Modified Contradiction</strong>.</p><p><strong>Lemma 5</strong>: $\Phi$ is consistent if and only if every finite $\Phi_0 \subset \Phi$</p><p><strong>Lemma 6</strong>: Every satisfiable $\Phi$ is consistent.<br>(Prove from the negative perspective using soundness and build a model)</p><p><strong>Lemma 7</strong>:<br>(1) $\Phi \vdash \varphi$ if and only if $\Phi \cup \neg\varphi$ is inconsistent.</p><p>Easy to prove.</p><p>(2) $\Phi \vdash \neg\varphi$ if and only if $\Phi \cup \varphi$ is inconsistent.</p><p>(3)If cons($\Phi$),then either cons($\Phi \cup \varphi$) or cons($\Phi \cup \neg\varphi$).</p><h2 id="So-the-end-of-Sequent-Calculus">So the end of Sequent Calculus.</h2><h2 id="Start-of-Question-2-What-makes-a-proof-correct">Start of Question 2: What makes a proof correct?</h2><p>能证的都是对的（soundness），对的都是能证的（Completeness完备性）。</p><p><strong>Theorem 8</strong><br>If $\Phi \models \varphi$,$\Phi \vdash \varphi$</p><p><strong>Theorem 9</strong><br>cons($\Phi$) implies that $\Phi$ is satisfiable.</p><h2 id="Term-Model（version-1）">Term Model（version 1）</h2><p>Define the term model $\mathcal{I}^\Phi(t)$ so that for every t $\in T^S$.<br>$\mathcal{I}^\Phi(t) = t$<br>把语法对象作为语义的universe<br>That is, the interpretation of an S-term $t$ is the syntax object $t \in T^S$ itself.</p><p><strong>Universe</strong>：A = $T^S$<br><strong>n-ary function symbol</strong>：<br>$f^A(t_1, \ldots, t_n) := f t_1 \ldots t_n.$</p><p><strong>n-ary relation symbol</strong>：<br>$R^A = {(t_1, \ldots, t_n) | \Phi \vdash R t_1 \ldots t_n}.$</p><p>$c^A := c$ and $\beta(v_i) := v_i$ for every variable $v_i$</p><p>But：we will meet a problem.<br>Let S = {f} where f is a function symbol and $\Phi:={fv_0 \equiv fv_1}$</p><ul class="lvl-0"><li class="lvl-2"><p>$\mathcal{I}^\Phi(fv_0) = fv_0 \neq fv_1 = \mathcal{I}^\Phi(fv_1)$(2 strings are not the same)</p></li><li class="lvl-2"><p>$\mathcal{I}^\Phi \models \Phi$ implies that $\mathcal{I}^\Phi(fv_0) = \mathcal{I}^\Phi(fv_1)$</p></li></ul><p><strong>Contradict!<strong>😢😰😢😰<br>To Overcome The Issue!<br>在项的集合上定义一个</strong>等价关系</strong>，define an equivalence relation ~ on $T^S$</p><p><strong>Let $t_1$, $t_2$ $\in T^S$.Then $t_1$ ~ $t_2$ if $\Phi \vdash t_1 \equiv t_2$.</strong><br>(Easy to prove equivalence relation)</p><p>Introduce the <strong>Equivalence Class of t</strong>.<br>For every $t \in T^S$ we define:<br>$\overline{t} := {t’ \in T^S \mid t’ \sim t}$</p><p>Through <strong>Derived Rules 3</strong>,we can prove that:</p><ul class="lvl-0"><li class="lvl-2"><p>For every $n$-ary function symbol $f \in S$ and terms $t_1 \sim t_1’, \ldots, t_n \sim t_n’$, we have<br>$f t_1 \cdots t_n \sim f t_1’ \cdots t_n’.$</p></li><li class="lvl-2"><p>For every $n$-ary relation symbol $R \in S$ and terms $t_1 \sim t_1’, \ldots, t_n \sim t_n’$, we have<br>$\Phi \vdash R t_1 \cdots t_n \iff \Phi \vdash R t_1’ \cdots t_n’.$</p></li></ul><p>So we will introduce…</p><h2 id="Term-Model（version-2）">Term Model（version 2）!!!</h2><p>The term structure for $\Phi$, denoted by $\mathfrak{T}^{\Phi}$, is defined as follows.</p><p>(i) The universe is ${T}^{\Phi} := {\overline{t} \mid t \in T^S}$.</p><p>(ii) For every $n$-ary relation symbol $R \in S$, and $\overline{t}_1, \ldots, \overline{t}_n \in T^{\Phi}$</p><p>$(\overline{t}_1, \ldots, \overline{t}_n)$ $\in {R}<sup>\mathfrak{T}</sup>{\Phi}  \text{if}  \Phi \vdash R t_1 \ldots t_n.$</p><p>(iii) For every $n$-ary function symbol $f \in S$, and $\overline{t}_1, \ldots, \overline{t}_n \in T^{\Phi}$</p><p>${f}<sup>\mathfrak{T}</sup>{\Phi}$ $(\overline{t}_1, \ldots, \overline{t}_n)$ := $\overline{f t_1 \ldots t_n}.$</p><p>(iv) For every constant $c \in S$<br>${c}<sup>\mathfrak{T}</sup>{\Phi}$ := $\overline{c}.$</p><p>And we still need an assignment:<br>$\mathfrak{\beta}^{\Phi}(v_i):= \overline{v_i}$</p><p>So we have the <strong>Heenkin’s term model</strong>:<br>$\mathfrak{I}<sup>{\Phi}$:=($\mathfrak{T}</sup>{\Phi},\mathfrak{\beta}^{\Phi}$)</p><p><strong>Lemma 11</strong>:<br>(1)For any $t$ $\in T^S$:<br>$\mathfrak{I}^{\Phi}(t) = \overline{t}$</p><p>(2)For every atomic $\varphi$<br>$\mathfrak{I}^{\Phi} \models \varphi \iff \Phi \vdash \varphi$</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic5</title>
    <link href="/2025/03/22/Mathematical-Logic5/"/>
    <url>/2025/03/22/Mathematical-Logic5/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Raytracing-ing-Build-my-first-ppm-file-I-❤️-Computer-Graphics">Before：Raytracing ing!Build my first ppm file!I ❤️ Computer Graphics!</h5><p><img src="/img/First.png" alt="PPM Hello World!"></p><h1>Mathematical Logic 5 Left Proof of Substitution Lemma 替换引理 &amp; Sequent Calculus (I)  序列演算</h1><h2 id="Left-Proof-of-Substitution-Lemma-替换引理">Left Proof of Substitution Lemma 替换引理</h2><p>对于项的替换引理证明还是比较直观容易的：<br><img src="/img/Sub%E8%AF%81%E6%98%8E1.png" alt="项替换Proof"></p><p>但对于公式来说，需要对公式进行归纳，这就有一定的难度了（特别是对∃的证明），外加由于此博客的Markdown渲染器并未配好(upd:配好了，也是终于能用Tex了)，就偷个懒直接了lecture-notes的图了🤡<br><img src="/img/Sub%E8%AF%81%E6%98%8E2.png" alt="公式替换Proof"></p><h2 id="Sequent-Calculus-Basic-Defintion">Sequent Calculus  Basic Defintion</h2><p>把证明当作数学对象来研究，这里的<strong>Sequent Calculus</strong>就是一种我们建立起来的证明系统。从已有的antecedent得到新的succedent。<br>$<br>Γ ⊢ Δ<br>$ <br>Γ 是前提集合，Δ是结论集合而Sequent Calculus要做的就是，设计一个演算系统，通过一系列规则从已知的序列推导出新的序列。</p><h3 id="Sequent-Rule-序列规则的形式">Sequent Rule 序列规则的形式</h3><p>$<br>\frac{Γ_1  φ_1…Γ_n  φ_n}{Γ’  φ}<br>$</p><h3 id="Derivability-可推导性">Derivability 可推导性</h3><p>如果可以从 Γ 推出 $\phi$ ，则记作<br>$<br>⊢ \Gamma \phi<br>$<br>这称为可推导</p><p>如果存在<strong>有限</strong>个公式<br>$<br>\phi_1 \phi_2 … \phi_n \in \Phi<br>$<br>使得<br>$<br>⊢ \phi_1 \phi_2 … \phi_n \phi<br>$<br>则称作公式$\phi$可从公式集$\Phi$中形式化证明或推导，记作<br>$<br>\Phi ⊢ \phi<br>$</p><h3 id="Correctness-正确性">Correctness 正确性</h3><p>A sequent $\Gamma$ $\phi$ is correct if<br>$<br>{\psi | \psi \in \Gamma} ⊢ \phi<br>$<br>即我们需要序列$\Gamma$中的所有公式都满足$\phi$，才能得到$\Gamma$ ⊢ $\phi$<br>引入的规则必须保证只产生正确的序列</p><h2 id="Structure-Rules-结构规则">Structure Rules 结构规则</h2><h3 id="Antecedent-前提规则">Antecedent 前提规则</h3><p>$<br>\frac{Γ ⊢ φ}{Γ’ ⊢ φ} \quad Γ ⊆ Γ’<br>$<br>如果某个结论可以从一组前提中推导出来，那么它也可以从更大的前提集合中推导出来。我们可以在推导过程中增加前提</p><h3 id="Assumption">Assumption</h3><p>$<br>\frac{}{\Gamma \vdash \varphi} \quad \text{如果 } \varphi \in \Gamma<br>$<br>如果某个公式已经是前提集合的一部分，那么它可以直接作为结论。换句话说，假设规则允许我们直接从前提集合中&quot;提取&quot;已知的公式作为结论，而无需进一步的推导。</p><h2 id="Connective-Rules-连接词规则">Connective Rules 连接词规则</h2><h3 id="Case-Analysis-案例分析规则">Case Analysis 案例分析规则</h3><p>我觉得就是<strong>分类讨论</strong>（遍历所有情况）<br>$<br>\frac{\Gamma, \psi \vdash \varphi \quad \Gamma, \neg \psi \vdash \varphi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合和某个假设 𝜓可以推导出结论 𝜑，并且从前提集合和 ¬𝜓也可以推导出𝜑，那么可以直接从前提集合推导出𝜑</p><h3 id="Contradiction-矛盾规则">Contradiction 矛盾规则</h3><p>我觉得就是<strong>反证的思想推出矛盾</strong><br>$<br>\frac{\Gamma, \neg \varphi \vdash \psi \quad \Gamma, \neg \varphi \vdash \neg \psi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合和 ¬𝜑可以推导出 𝜓和 ¬𝜓，那么可以直接从前提集合推导出 𝜑。</p><h3 id="v-introduction-in-antecedent-析取引入规则-前提版">v-introduction in antecedent 析取引入规则(前提版)</h3><p>$<br>\frac{\Gamma, \varphi \vdash \chi \quad \Gamma, \psi \vdash \chi}{\Gamma, \varphi \vee \psi \vdash \chi}<br>$<br>如果无论 𝜑为真还是 𝜓为真，𝜒都成立，那么从 𝜑∨𝜓（即 𝜑或𝜓中至少有一个为真）也可以推导出 𝜒。</p><h3 id="v-introduction-in-succedent-析取引入规则-结论版">v-introduction in succedent 析取引入规则(结论版)</h3><p>$<br>\frac{\Gamma \vdash \varphi}{\Gamma \vdash \varphi \vee \psi} \quad \text{or} \quad \frac{\Gamma \vdash \psi}{\Gamma \vdash \varphi \vee \psi}<br>$<br>如果𝜑为真，则𝜑∨𝜓也为真；如果𝜓为真，则𝜑∨𝜓也为真；因此只要𝜑和𝜓中的一个为真，𝜑∨𝜓就为真</p><h2 id="Derived-Rules-派生规则（可通过结构规则、连接词规则证明）">Derived Rules 派生规则（可通过结构规则、连接词规则证明）</h2><h3 id="排中律-Law-of-Excluded-Middle">排中律 Law of Excluded Middle</h3><p>$<br>\vdash \varphi \vee \neg \varphi<br>$<br>对于任何命题 𝜑，$ \varphi \vee \neg \varphi$  总是为真。也就是说，任何命题要么为真，要么为假，不存在中间状态</p><h3 id="修改的矛盾规则-Modified-Contradiction">修改的矛盾规则 Modified Contradiction</h3><p>$<br>\frac{\Gamma \vdash \psi \quad \Gamma \vdash \neg \psi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合 $\Gamma $ 可以推导出 $ \psi $，并且从前提集合 $ \Gamma $ 也可以推导出 $ \neg \psi $，那么可以直接从 $ \Gamma $ 推导出 $ \varphi $。</p><h3 id="链式推理-Chain-Deduction">链式推理 Chain Deduction</h3><p>$<br>\frac{\Gamma \vdash \varphi \quad \Gamma, \varphi \vdash \psi}{\Gamma \vdash \psi}<br>$<br>通过中间步骤 $ \varphi $，可以将前提集合 $ \Gamma $ 与结论 $ \psi $ 连接起来，形成一个推理链。</p><h2 id="Quantifier-Rules-量词规则">Quantifier Rules 量词规则</h2><h3 id="∃-introduction-in-succedent-结论版">∃-introduction in succedent(结论版)</h3><p>$<br>\frac{\Gamma \vdash \varphi(t/x)}{\Gamma \vdash \exists x \varphi}<br>$<br>如果存在一个具体的项  t ，使得 $ \varphi(t/x) $ 成立，那么可以推导出存在量词 $ \exists x \varphi $。</p><h3 id="∃-introduction-in-antecedent-前提版">∃-introduction in antecedent(前提版)</h3><p>$<br>\frac{\Gamma, \varphi(y/x) \vdash \psi}{\Gamma, \exists x \varphi \vdash \psi} \quad \text{如果 } y \notin \text{free}(\Gamma \cup {\exists x \varphi, \psi})<br>$<br>通过引入一个新的变量  y ，可以将存在量词 $ \exists x \varphi $ 引入前提中，从而推导出 $ \psi $。<br><strong>变量y选取的重要性</strong>（如果变量选取不当，可能会导致逻辑错误）<br>y 必须是一个新变量，不能在其他地方自由出现</p><h2 id="Equality-Rules-等式规则">Equality Rules 等式规则</h2><h3 id="Equality-等式的基本规则">Equality 等式的基本规则</h3><p>$<br>t \equiv t<br>$<br>等式的基本规则表明任何项 𝑡 都等于它自身。</p><h3 id="Substitution-替换规则">Substitution 替换规则</h3><p>$<br>\frac{\Gamma \vdash t \equiv t’ \quad \Gamma \vdash \varphi(t/x)}{\Gamma \vdash \varphi(t’/x)}<br>$<br>如果两个项  t  和  t’  相等，那么在任何公式中，可以用  t’  替换  t ，而不改变公式的真值。</p><h2 id="Soundness-可靠性定理">Soundness 可靠性定理</h2><p>$<br>\text{如果 } \Phi \vdash \varphi, \text{ 则 } \Phi \models \varphi.<br>$<br>如果从前提集合 $ \Phi $ 可以形式化推导出 $ \varphi $，那么 $ \varphi $ 在语义上也成立。也就是说，形式化推导的结果在语义上是正确的。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic4</title>
    <link href="/2025/03/14/Mathematical-Logic4/"/>
    <url>/2025/03/14/Mathematical-Logic4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"><a href="#Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜" class="headerlink" title="Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"></a>Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜</h5><h5 id="今天是3月14日，𝜋节。2022-03-14-2025-03-14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。"><a href="#今天是3月14日，𝜋节。2022-03-14-2025-03-14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。" class="headerlink" title="今天是3月14日，𝜋节。2022.03.14 - 2025.03.14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。"></a>今天是3月14日，𝜋节。2022.03.14 - 2025.03.14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。</h5><h1 id="Mathematical-Logic-4-同构引理的证明-替换"><a href="#Mathematical-Logic-4-同构引理的证明-替换" class="headerlink" title="Mathematical Logic 4 同构引理的证明 &amp; 替换"></a>Mathematical Logic 4 同构引理的证明 &amp; 替换</h1><h2 id="Call-back-previous-一阶逻辑语义"><a href="#Call-back-previous-一阶逻辑语义" class="headerlink" title="Call back previous 一阶逻辑语义"></a>Call back previous 一阶逻辑语义</h2><p><strong>同构</strong><br>存在一个A -&gt; B 的映射满足：</p><ol><li>是双摄</li><li>保持关系（n元关系运算符）</li><li>保持运算（n元函数运算符）</li><li>保持常量（常数c）</li></ol><p>则结构A、结构B同构</p><p>在上周的作业中，我们证明了同构是一种等价关系。回忆，等价关系需要满足三个条件：</p><ol><li>自反性</li><li>对称性</li><li>传递性</li></ol><h2 id="同构引理的证明"><a href="#同构引理的证明" class="headerlink" title="同构引理的证明"></a>同构引理的证明</h2><p>Recall:<br>A、B是2个同构的S-结构，那么对于所有S-sentence 𝜑，有：</p><p>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑 </p><p>Prof:<br>由重合引理可知：<br>A |&#x3D; 𝜑 ⟺ (A,β) |&#x3D; 𝜑<br>B |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>so A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑  ⟺  (A,β) |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>定义β^𝜋(x) :&#x3D; 𝜋(β(x))<br>那么我们要证：<br>(A,β) |&#x3D; 𝜑 ⟺ (B,β^𝜋) |&#x3D; 𝜑 (𝜑 是任意S-公式)<br>&#x2F;&#x2F; 这不就从句子推广到公式上了嘛 </p><p>也就是要证明：<br>I:&#x3D; (A,β) I^𝜋:&#x3D; (B,β^𝜋)<br>𝜋(I(t)) &#x3D; I^𝜋(t)</p><p>这里改写成解释，也就可以进行结构归纳法（对公式的归纳了）<br>略</p><h2 id="项的替换-Substitution"><a href="#项的替换-Substitution" class="headerlink" title="项的替换 Substitution"></a>项的替换 Substitution</h2><p>设t 是一个S-term，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义项的替换：<br><img src="/img/%E6%9B%BF%E6%8D%A2.png" alt="替换"></p><p>(a)如果t &#x3D; x是一个变量，那么：<br><img src="/img/%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="变量替换"></p><p>(b)如果t &#x3D; c是一个常数，那么：<br><img src="/img/%E5%B8%B8%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="常量替换"></p><p>(c)对于一个函数项<br><img src="/img/%E5%87%BD%E6%95%B0%E9%A1%B9%E6%9B%BF%E6%8D%A2.png" alt="函数项替换"></p><h2 id="公式上的替换"><a href="#公式上的替换" class="headerlink" title="公式上的替换"></a>公式上的替换</h2><p>设𝜑 是一个S-formula，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义：<br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A21.png" alt="公式替换"><br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A22.png" alt="公式替换"></p><h2 id="赋值上的替换（对于自由变量）"><a href="#赋值上的替换（对于自由变量）" class="headerlink" title="赋值上的替换（对于自由变量）"></a>赋值上的替换（对于自由变量）</h2><p><img src="/img/%E8%B5%8B%E5%80%BC%E6%9B%BF%E6%8D%A2.png" alt="赋值替换"></p><h2 id="替换引理"><a href="#替换引理" class="headerlink" title="替换引理"></a>替换引理</h2><p>替换引理分为2个部分：</p><h3 id="项的替换引理"><a href="#项的替换引理" class="headerlink" title="项的替换引理"></a>项的替换引理</h3><p>对一个项 𝑡 进行替换后，其解释等于在原解释 𝐼 的基础上，将变量x0,…,xr替换为项t0,…,tr的解释<br><img src="/img/%E9%A1%B9%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%90%86.png" alt="项的替换引理"></p><h3 id="公式的替换引理"><a href="#公式的替换引理" class="headerlink" title="公式的替换引理"></a>公式的替换引理</h3><p>对一个公式 𝜑 进行替换后，其真值等于在原解释 𝐼 的基础上，将变量x0,…,xr替换为项t0,…,tr的解释后的真值<br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%90%86.png" alt="公式的替换引理"></p><h3 id="二者均为语法替换-⟺-语义更新"><a href="#二者均为语法替换-⟺-语义更新" class="headerlink" title="二者均为语法替换 ⟺  语义更新"></a>二者均为语法替换 ⟺  语义更新</h3>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Of DS——Monotonic Stack &amp; Queue</title>
    <link href="/2025/03/13/AlgorithmOfDS1/"/>
    <url>/2025/03/13/AlgorithmOfDS1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：最近在de-STLite的最后一个数据结构map。周二用一个下午-一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️">Before：最近在de STLite的最后一个数据结构map。周二用一个下午+一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️</h5><h1>Algorithm of Data Structure 1 单调栈&amp;单调队列&amp;栈模拟递归</h1><h2 id="单调栈">单调栈</h2><p>定义：栈内元素满足某种单调性质，可以单增也可以单减</p><p>在处理每个元素时，将其与栈顶元素进行比较，如果当前元素大于（或小于）栈顶元素，则将栈顶元素出栈，直到满足单调性质为止。然后，将当前元素入栈，继续处理下一个元素（<strong>当前元素必须入栈</strong>）</p><p>单调栈可以快速找到每个元素的下一个更大（或更小）元素，时间复杂度为O(n)（n为序列的长度）</p><p>具体来说，<strong>单调递增栈可用于寻找下一个更小元素，而单调递减栈可用于寻找下一个更大元素</strong>，并且只需要遍历整个序列一次</p><p>Example：找到数列中每个元素下一个比它大的元素下标（1 — base）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈顶位置</span><br>stack[top] = <span class="hljs-number">0</span>; <span class="hljs-comment">//a[0]入栈  stack数组记录栈内元素下标</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span> &amp;&amp; a[stack[top]] &lt; a[i])&#123;<br>        ans[stack[top]] = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//记录答案</span><br>        top --; <span class="hljs-comment">//当前栈顶元素出栈</span><br>    &#125;<br>    stack[++ top] = i;<br>&#125;<br><span class="hljs-keyword">while</span>(top &gt;=<span class="hljs-number">0</span>)&#123;<br>    ans[stack[top --]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈内剩余元素不存在下一个比它大的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：需要一个stack数组记录栈内情况，一个top记录栈顶位置，一个a存储原本序列数据，和一个ans存储答案</p><h2 id="单调栈例题">单调栈例题</h2><p><a href="https://www.luogu.com.cn/problem/P1901">luogu P1901</a></p><ul class="lvl-0"><li class="lvl-2"><p>某地有N个能量发射站排成一行，每个发射站i都有不相同的高度Hi，并能向两边（两端的发射站只能向一边）同时发射能量值为Vi的能量，发出的能量只被两边最近的且比它高的发射站接收。</p></li><li class="lvl-2"><p>显然，每个发射站发出的能量有可能被0~2个其他发射站所接受。</p></li><li class="lvl-2"><p>请计算出接收最多能量的发射站接收的能量是多少。</p></li></ul><p>小黄题，15分钟速通😋 Strong女也只能切黄题了呜呜呜</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>main() &#123;<br>   <span class="hljs-built_in"> int </span>n;<br>    cin &gt;&gt; n;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        cin &gt;&gt; h1[i];<br>        cin &gt;&gt; v1[i];<br>    &#125;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        h2[i] = h1[n - 1 -i];<br>        v2[i] = v1[n - 1- i];<br>    &#125;<br>   <span class="hljs-built_in"> int </span>top1 = 0;<br>   <span class="hljs-built_in"> int </span>top2 = 0;<br>    stack1[top1] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top1 &gt;= 0 &amp;&amp; h1[stack1[top1]] &lt; h1[i]) &#123;<br>            ans1[stack1[top1]] = i;<br>            total1[i] += v1[stack1[top1]];<br>            top1 --;<br>        &#125;<br>        stack1[++ top1] = i;<br>    &#125;<br>    while(top1 &gt;= 0) &#123;<br>        ans1[stack1[top1 --]] = -1;<br>    &#125;<br><br>    stack2[top2] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top2 &gt;= 0 &amp;&amp; h2[stack2[top2]] &lt; h2[i]) &#123;<br>            ans2[stack2[top2]] = i;<br>            total2[i] += v2[stack2[top2]];<br>            top2 --;<br>        &#125;<br>        stack2[++ top2] = i;<br>    &#125;<br>    while(top2 &gt;= 0) &#123;<br>        ans2[stack2[top2 --]] = -1;<br>    &#125;<br><br>   <span class="hljs-built_in"> int </span>maxE = 0;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>       <span class="hljs-built_in"> int </span>current = total1[i] + total2[n - 1 - i];<br>        if(current &gt; maxE) &#123;<br>            maxE = current;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><p>高效地维护队列中元素的单调性（递增或递减），同时支持在队列两端的插入和删除操作</p><ul class="lvl-0"><li class="lvl-2"><p>可在队首出队</p></li><li class="lvl-2"><p>仅在队尾入队</p></li><li class="lvl-2"><p>如果影响单调性，可能从队尾出队</p></li></ul><p>省流：其实是一个双端队列（deque）（这不是隔壁这次大作业嘛🤣有福了）</p><p><strong>它通常用于解决需要在一个滑动窗口（或固定长度的子数组）内找到最大值或最小值的问题</strong></p><ul class="lvl-0"><li class="lvl-2"><p>插入元素：当新元素进入窗口时，从队列尾部移除所有小于新元素的元素，然后将新元素插入队列尾部。</p></li><li class="lvl-2"><p>移除元素：当元素离开窗口时，如果它是队列头部的元素，则从队列头部移除。</p></li><li class="lvl-2"><p>获取最值：队列头部的元素始终是当前窗口的最大值（或最小值，取决于单调性）</p></li></ul><p>可实现在O(1)的时间复杂度下获得最值比如我们现在要一个递增的单调队列</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> minFront = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> minBack = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-built_in">num</span>[i] = read();<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; minWin[minFront] &lt;= i - k)&#123; <span class="hljs-comment">//队头指针小于等于队尾指针 &amp;&amp; 队头元素索引已经不在窗口范围内</span><br>        ++ minFront;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; <span class="hljs-built_in">num</span>[i] &lt; minWin[minBack])&#123;<br>        -- minBack; <span class="hljs-comment">// 将破坏单调性的元素出列</span><br>    &#125;<br>    <span class="hljs-comment">//加入队列</span><br>    minWin[++ minBack] = <span class="hljs-built_in">num</span>[i];<br>    <span class="hljs-keyword">if</span>(i &gt;= k)&#123;<br>        cout &lt;&lt; minWin[minFront];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列例子">单调队列例子</h2><p>小Z的家门口种了N棵树，第i棵树在目标点xi，高度hi。如果一棵树左边D距离内和右边D距离内有高度至少是它的两倍的树，那么小Z认为这棵树不够茁壮。春天到了，他想给不够茁壮的树多施点肥，请你帮忙数数有几棵不够茁壮的树。</p><p>思路：长度为D（若不足D 也可）的数组（窗口），移动即可。两个方向都扫一遍</p><h2 id="栈模拟递归">栈模拟递归</h2><p>递归过程：</p><ol><li class="lvl-3"><p>执行代码块0</p></li><li class="lvl-3"><p><strong>保存现场准备进入下一层</strong></p></li><li class="lvl-3"><p>接受下层返回的数据</p></li><li class="lvl-3"><p><strong>恢复现场</strong></p></li><li class="lvl-3"><p>继续执行代码块1</p></li></ol><p>直接用递归程序实现递归时，第二步和第四步都是编译器在帮助你完成而非递归实现，我们期望：自己用实现保存现场和恢复现场</p><p>用栈模拟递归的优势在于：</p><ol><li class="lvl-3"><p>避免递归深度限制</p></li><li class="lvl-3"><p>更直观的控制流程</p></li><li class="lvl-3"><p>避免递归调用的开销</p></li></ol><h2 id="END">END</h2><p>你可以当我哑巴一样你不会看见我的抵抗请别怕我受伤 我自己会圆场</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Monotonic Stack</tag>
      
      <tag>Monotonic Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic3</title>
    <link href="/2025/03/08/Mathematical-Logic3/"/>
    <url>/2025/03/08/Mathematical-Logic3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"><a href="#Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣" class="headerlink" title="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"></a>Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣</h5><p>🐖🐖🐖</p><h1 id="Mathematical-Logic-3-重合引理-同构引理"><a href="#Mathematical-Logic-3-重合引理-同构引理" class="headerlink" title="Mathematical Logic 3 重合引理 同构引理"></a>Mathematical Logic 3 重合引理 同构引理</h1><h2 id="概念回顾"><a href="#概念回顾" class="headerlink" title="概念回顾"></a>概念回顾</h2><p><strong>项</strong>是由<strong>变量、常量符号和函数符号</strong>通过递归方式构造的表达式。<br><strong>公式</strong>（formula）是由<strong>项</strong>通过<strong>谓词符号、逻辑连接词和量词构造</strong>的表达式。<br><strong>结构</strong>由<strong>域</strong>和<strong>解释函数</strong>组成。<br><strong>解释</strong>由<strong>结构</strong>和<strong>赋值函数</strong>（将自由变量映射到域中的元素）组成。</p><ul><li>原子公式：包括等式公式、谓词公式R</li><li>逻辑连接词：¬、∧、∨、→、↔</li><li>量词：∀xφ (x是变量，φ 是公式)、∃xφ (x是变量，φ 是公式)</li></ul><p>我们可以解释term、解释formula、解释sentence</p><h2 id="结构归纳法（对公式进行归纳）"><a href="#结构归纳法（对公式进行归纳）" class="headerlink" title="结构归纳法（对公式进行归纳）"></a>结构归纳法（对公式进行归纳）</h2><p>公式的归纳基于公式的结构，即公式的构造方式。由于公式是通过递归方式定义的（<strong>从原子公式逐步构造出复杂公式</strong>），因此我们可以使用结构归纳法来证明公式的性质。<br>公式的归纳证明通常分为以下几个步骤：</p><ul><li>证明性质𝑃对所有原子公式成立</li><li>归纳步骤：假设性质𝑃对某些公式𝜑和𝜓成立（归纳假设），然后证明𝑃对通过这些公式构造的复杂公式也成立。</li></ul><h2 id="重合引理（The-Coincidence-Lemma）"><a href="#重合引理（The-Coincidence-Lemma）" class="headerlink" title="重合引理（The Coincidence Lemma）"></a>重合引理（The Coincidence Lemma）</h2><p>设I1(A1,β1),I2(A2,β2)是2个S-解释，且满足以下条件：</p><ul><li>A1 &#x3D; A2（解释的域相同）</li><li>对于S：&#x3D; S1 ∩ S2中的每个符号，它们在A1、A2中的解释相同</li></ul><p>那么：</p><ul><li>对于任何S项t，如果β1(x) &#x3D; β2(x)对于t中的所有变量x成立，则I1(x) &#x3D; I2(x)<br>即需要满足<strong>结构的解释相同</strong>和<strong>变量的赋值相同</strong></li><li>对于任何S公式𝜑，如果β1(x) &#x3D; β2(x)对于𝜑中的所有自由变量x成立，则I1 |&#x3D; 𝜑 当且仅当 I2 |&#x3D; 𝜑<br>即需要满足<strong>结构的解释相同</strong>和<strong>自由变量的赋值相同</strong></li></ul><p>证明依赖于<strong>结构归纳法</strong></p><h2 id="同构引理（The-Isomorphism-Lemma）"><a href="#同构引理（The-Isomorphism-Lemma）" class="headerlink" title="同构引理（The Isomorphism Lemma）"></a>同构引理（The Isomorphism Lemma）</h2><p>首先给出<strong>同构</strong>的定义：<br>在模型论中，同构是指两个结构之间存在一个<strong>双射</strong>（bijection），这个双射<strong>保持了结构中的所有关系、函数和常量</strong>。<br>具体来说：<br>设A(A,I)和B(B,J)是2个S—结构，其中A和B是它们的域，I和J是解释函数。<br>一个同构𝜋：A → B是一个双射，满足以下条件：</p><ul><li>保持关系<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%85%B3%E7%B3%BB.png" alt="保持关系"></li><li>保持运算<br><img src="/img/%E4%BF%9D%E6%8C%81%E8%BF%90%E7%AE%97.png" alt="保持运算"></li><li>保持常量<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%B8%B8%E9%87%8F.png" alt="保持常量"></li></ul><p>如果存在这样的双射𝜋，则称结构A和B是同构的，记作A≅B<br>例子：群论 &amp; 图论中的同构</p><p>同构的性质：</p><ul><li>自反性（Reflexivity）：A ≅ A</li><li>对称性（Symmetry）：若A ≅ B，则B ≅ A</li><li>传递性（Transitivity）：若A ≅ B 且 B ≅ C ，则A ≅ C</li></ul><p>因此，同构是一个<strong>等价关系</strong></p><p>那么同构引理可以表示为：<br>如果A、B是两个同构的S-结构，则对于任何<strong>S-句子</strong>𝜑，有<br>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑<br>这意味着，同构的结构在一阶逻辑中无法被区分，它们满足相同的句子。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms3</title>
    <link href="/2025/03/06/Introduction-to-Algorithms3/"/>
    <url>/2025/03/06/Introduction-to-Algorithms3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"><a href="#Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢" class="headerlink" title="Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"></a>Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢</h5><h1 id="Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL"><a href="#Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL" class="headerlink" title="Introduction to Algorithms 3 Balanced Binary Search Tree——AVL"></a>Introduction to Algorithms 3 Balanced Binary Search Tree——AVL</h1><p>First, recall an important definition of <strong>Height of a Node</strong>: <strong>length of the longest downward path to a leaf</strong></p><h2 id="The-Importance-of-Being-Balanced"><a href="#The-Importance-of-Being-Balanced" class="headerlink" title="The Importance of Being Balanced"></a>The Importance of Being Balanced</h2><p>As we talk about last time,BST suppports insert&#x2F;delete&#x2F;min&#x2F;max&#x2F;next_larger&#x2F;next_smaller or in a time complexity of <strong>O(h)</strong>.But that’s not what we want.Somehow if h equals to n,it’s gonna be really bad.</p><p>We love this tree😋😋😋：<br><img src="/img/PerfectTree.png" alt="Perfectly Balanced Binary Tree"></p><p>We hope to do some adjustments to the tree so that h can equal to <strong>logN</strong>.</p><h2 id="AVL-Trees——Adel’son-Vel’skii-Landis-1962"><a href="#AVL-Trees——Adel’son-Vel’skii-Landis-1962" class="headerlink" title="AVL Trees——Adel’son-Vel’skii &amp; Landis 1962"></a>AVL Trees——Adel’son-Vel’skii &amp; Landis 1962</h2><h3 id="Main-Defintion"><a href="#Main-Defintion" class="headerlink" title="Main Defintion:"></a>Main Defintion:</h3><p>For every node,require <strong>heights</strong> of left &amp; right children to differ by at most <strong>± 1</strong>.</p><ul><li>We mark nil trees as height <strong>-1</strong>（quite smart cuz -1 + 1 &#x3D; 0）</li><li>Each nodes stores its height</li></ul><p><img src="/img/AVL%E4%BE%8B%E5%AD%90.png" alt="An example of an AVL tree"></p><h3 id="Balance"><a href="#Balance" class="headerlink" title="Balance"></a>Balance</h3><p>Consider the largest height of an AVL tree with N nodes.(worst time complexity)<br>Equalently,we can consider <strong>the minimun node numbers of an AVL tree with height h</strong>!<br>Great thoughts!</p><p>We can do a rough Maths proof:<br>N_h &#x3D; N_(h - 1) + N_(h - 2) &gt; 2N_(h - 2)<br>&#x3D;&gt; N_h &gt; 2^(h&#x2F;2)<br>&#x3D;&gt; h &lt; 2 log(N_h)<br>So proved that h is alogN(a is a parameter)</p><p>Theoretical computer scientists can do this more accurately,like what the picture below shows using Fibonacci:<br><img src="/img/AVLproof.png" alt="The secret behind the logN height of the AVL tree"></p><h3 id="AVL-insert"><a href="#AVL-insert" class="headerlink" title="AVL insert"></a>AVL insert</h3><p>1.insert as in simple BST(just the normal one)<br>2.<strong>work your way up tree, restoring AVL property</strong>(the most important step of building the AVL tree)</p><p>Each Step of the famous <strong>AVL Rotation</strong>:</p><ul><li><p>suppose x is lowest node violating(违背) AVL</p></li><li><p>assume x is right-heavy (left case symmetric)</p></li><li><p>if x’s right child is right-heavy or balanced:<br><img src="/img/AVL%E6%97%8B%E8%BD%AC1.png" alt="AVL Inserting Balance"></p></li><li><p>else: follow steps<br><img src="/img/AVL%E6%97%8B%E8%BD%AC2.png" alt="AVL Inserting Balance"></p></li><li><p>then continue up to x’s grandparent, greatgrandparent</p></li></ul><h2 id="Other-Balanced-Trees"><a href="#Other-Balanced-Trees" class="headerlink" title="Other Balanced Trees"></a>Other Balanced Trees</h2><ul><li>B-Trees&#x2F;2-3-4 Trees Bayer and McCreight 1972 (see CLRS 18)</li><li>BB[α] Trees Nievergelt and Reingold 1973</li><li>Red-black Trees CLRS Chapter 13</li><li>Splay-Trees Sleator and Tarjan 1985</li><li>Skip Lists Pugh 1989</li><li>Scapegoat Trees Galperin and Rivest 1993</li><li>Treaps Seidel and Aragon 1996</li></ul><h2 id="Comparison-with-Heap"><a href="#Comparison-with-Heap" class="headerlink" title="Comparison with Heap"></a>Comparison with Heap</h2><p><img src="/img/HeapAVL1.png"><br><img src="/img/HeapAVL2.png"></p><h2 id="End-Start-BHW-3-Map"><a href="#End-Start-BHW-3-Map" class="headerlink" title="End(Start BHW 3 Map~~~)"></a>End(Start BHW 3 Map~~~)</h2>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>AVL</tag>
      
      <tag>Balanced Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms2</title>
    <link href="/2025/03/01/Introduction-to-Algorithms2/"/>
    <url>/2025/03/01/Introduction-to-Algorithms2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：风止于秋水，我止于你"><a href="#Before：风止于秋水，我止于你" class="headerlink" title="Before：风止于秋水，我止于你"></a>Before：风止于秋水，我止于你</h5><h1 id="Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort"><a href="#Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort" class="headerlink" title="Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort"></a>Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort</h1><h2 id="Base-on"><a href="#Base-on" class="headerlink" title="Base on ?"></a>Base on ?</h2><p><strong>Runway Reservation System</strong>!!!(My favourite plane! We’re saved!)</p><p><img src="/img/Runway.png" alt="Runway Reservation System"></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Each node x in the binary tree has a key <strong>key(x)</strong>.Nodes other than the root have a <strong>parent p(x)</strong>.Nodes may have a left child <strong>left(x)</strong> and&#x2F;or a right child <strong>right(x)</strong>.<br>ps：ALL POINTERS!Unlike in the Heap.</p><p><strong>Characteristics</strong>：for any node x, for all nodes y in the left subtree of x, key(y) ≤ key(x). For all nodes y in the right subtree of x key(y) ≥ key(x).</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>As the picture shows below🤓<br><img src="/img/BST%E6%8F%92%E5%85%A5.png" alt="BST insert operation"></p><p>Under the problem,we need to do the “Within K minutes Check” before inserting.If doesn’t follow,then stop the insertion.</p><h2 id="Find-Exists-find-val"><a href="#Find-Exists-find-val" class="headerlink" title="Find Exists : find(val)"></a>Find Exists : find(val)</h2><p>Follow left and right pointers until you find it or hit NIL.</p><h2 id="Find-the-minimum-element-in-a-BST-findmin"><a href="#Find-the-minimum-element-in-a-BST-findmin" class="headerlink" title="Find the minimum element in a BST : findmin()"></a>Find the minimum element in a BST : findmin()</h2><p>Just go left until you can’t.</p><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><p>All the operations above have an O(h) time complexity.<br>ps: <strong>h is the height of BST</strong></p><p>We may find a problem: somehow in a tricky (or abstract) way of insertion, the BST may turn to a <strong>List</strong>.So the complexity will be O(n),but we hope O(logn).😣😣😣</p><p>We’re gonna talk about it next time in the <strong>AVL Chapter</strong>😋😋😋<br>Balanced BSTs to the rescue in the next lecture!</p><h2 id="Find-the-next-larger-element-next-larger-x"><a href="#Find-the-next-larger-element-next-larger-x" class="headerlink" title="Find the next larger element: next_larger(x)"></a>Find the next larger element: next_larger(x)</h2><p>IF right child is not NIL,return minimun(x -&gt; right)<br>    else y &#x3D; parent(x)</p><pre><code class="hljs">while y not NIL and x = right(y)    x =  y    y = parent(y)return y;</code></pre><h2 id="How-many-planes-are-scheduled-to-land-at-times-≤-t"><a href="#How-many-planes-are-scheduled-to-land-at-times-≤-t" class="headerlink" title="How many planes are scheduled to land at times ≤ t?"></a>How many planes are scheduled to land at times ≤ t?</h2><p>Algorithm:<br>1.Walk down tree to find desired time( find t pos )<br>2.Add in nodes that are smaller<br>3.Add in subtree sizes to the left( record the size of the subtrees)</p><h2 id="附上早上手写的BST"><a href="#附上早上手写的BST" class="headerlink" title="附上早上手写的BST"></a>附上早上手写的BST</h2><p>（由于赶时间就没写类模板了，int型BST凑合看看吧😢）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by JaneZ on 2025/3/2.</span><br><span class="hljs-comment">//</span><br>#ifndef BST_H<br>#define BST_H<br>#include &lt;cstdio&gt;<br><br>class BinarySearchTree &#123;<br>private:<br>    struct treeNode &#123;<br>        treeNode *parent;<br>        treeNode *left;<br>        treeNode *right;<br>        int count; <span class="hljs-comment">//单个结点出现次数</span><br>        int size; <span class="hljs-comment">//以该结点为根 的子树大小</span><br>        int value; <span class="hljs-comment">//存储的值，这里以整数为例</span><br><br>        treeNode(treeNode *p = nullptr,treeNode *l = nullptr,treeNode *r = nullptr,int c = <span class="hljs-number">1</span>,int s = <span class="hljs-number">1</span>,int v = <span class="hljs-number">0</span>):<br>        parent(p),left(l),right(r),count(c),size(s),value(v)&#123;&#125;<br>    &#125;;<br><br>    treeNode *root;<br><br>    treeNode *buildTree(treeNode *other) &#123;<br>        <span class="hljs-keyword">if</span>(other != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">treeNode</span> *r = new treeNode(nullptr,nullptr,nullptr,other-&gt;</span><span class="hljs-function"><span class="hljs-title">count</span>,other-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>,other-&gt;</span>value);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = buildTree(other -&gt;</span> left);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = buildTree(other -&gt;</span> right);<br>            return r;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            return nullptr;<br>        &#125;<br>    &#125;<br><br>    void clear(treeNode *r) &#123;<br>        <span class="hljs-keyword">if</span>(r != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> left);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> right != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> right);<br>            &#125;<br>            delete r;<br>        &#125;<br>    &#125;<br>public:<br>    BinarySearchTree():root(nullptr)&#123;&#125;<br><br>    BinarySearchTree(const BinarySearchTree &amp;other) &#123;<br>        root = buildTree(other.root);<br>    &#125;<br><br>    ~BinarySearchTree() &#123;<br>        clear(root);<br>    &#125;<br><br>    treeNode *search(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == val) &#123;<br>            return r;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &lt; r -&gt;</span> value)&#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> right,val);<br>        &#125;<br>    &#125;<br><br>    treeNode *insert(treeNode *r,int key) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            r = new treeNode(nullptr,nullptr,nullptr,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,key);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == key) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span>count ++;<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &lt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> left,key);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &gt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//返回新的根结点</span><br>    treeNode *remove(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(val &lt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = remove(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> right,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> count &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> count --;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr ) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> right;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> right == nullptr) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> left;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//用右子树的最小值作为新的根结点</span><br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *pos = findMin(r -&gt;</span> right);<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> = pos -&gt;</span> count;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">value</span> = pos -&gt;</span> value;<br>                    <span class="hljs-function"><span class="hljs-title">pos</span> -&gt;</span> count = <span class="hljs-number">1</span>;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,pos -&gt;</span> value);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    treeNode *findMin(treeNode *r) &#123;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> = r -&gt;</span> left;<br>        &#125;<br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名</span><br>    int queryRank(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value == val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                return <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value &gt; val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">return</span> queryRank(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> 1 + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名为第k名的树</span><br>    int queryKth(treeNode *r,int k) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> left ,k);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> count &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,k - (r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> : 0) - r -&gt;</span> count);<br>    &#125;<br>&#125;;<br><br>#endif <span class="hljs-comment">//BST_H</span><br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Still an easy one.Can’t wait to see AVL!<br>立下flag，争取这周搞定用AVL实现的map!😋</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Algorithms1</title>
    <link href="/2025/03/01/Introduction-to-Algorithms1/"/>
    <url>/2025/03/01/Introduction-to-Algorithms1/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"><a href="#Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭" class="headerlink" title="Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 @three-hats-user 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"></a>Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 <a href="https://github.com/Jxint001">@three-hats-user</a> 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭</h4><h1 id="Introduction-to-Algorithms-1-Heaps-and-heap-sort"><a href="#Introduction-to-Algorithms-1-Heaps-and-heap-sort" class="headerlink" title="Introduction to Algorithms 1  Heaps and heap sort"></a>Introduction to Algorithms 1  Heaps and heap sort</h1><h2 id="Priority-Queues-Definition"><a href="#Priority-Queues-Definition" class="headerlink" title="Priority Queues Definition"></a>Priority Queues Definition</h2><p>A data structure implementing a set S of elements,each associated with a key,supporting the following operations: </p><ul><li>insert(S,x)</li><li>max(S)</li><li>extract_max(S):return element of S with largest key and remove it from S</li><li>increase_key(S,x,k):increase the value of element x’ s key to new value k</li></ul><p>Priority Queues can be built by using Heap or AVL.</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>As I said seconds before,<strong>Heap</strong> is one of the Implementations of a priority queue.</p><p>First,we are going to visualize an <strong>Array</strong> as a <strong>nearly complete binary tree</strong>（完全二叉树）</p><p>Let’s just talk about <strong>Max Heap</strong> here（Min Heap is exactly the same）</p><p><strong>Max Heap Property</strong>:The key of a node is $\geq$ than the key children.<br>For example:</p><p><img src="/img/%E5%A4%A7%E6%A0%B9%E5%A0%86%E4%BE%8B%E5%AD%90.png" alt="Max Heap Example"></p><p>Almost the same basic characteristics as Binary Tree</p><p>Here’re some simple Heap Operations:</p><ul><li>build max heap: produce a max-heap from an unordered array</li><li><strong>max_heapify</strong>: correct a single violation(违反) of the heap property in a subtree at its root</li><li>insert,extract_max,heapsort</li></ul><h3 id="The-most-important-procedure-Max-heapify"><a href="#The-most-important-procedure-Max-heapify" class="headerlink" title="The most important procedure: Max_heapify"></a>The most important procedure: Max_heapify</h3><p>• Assume that the trees rooted at left(i) and right(i) are max-heaps.</p><p>• If element A[i] violates the max-heap property, correct violation by “trickling” element A[i] down the tree, making the subtree rooted at index i a max-heap.</p><p>Here is an example of Max_heapify:<br><img src="/img/Heapify1.png" alt="Max_heapify1"><br><img src="/img/Heapify2.png" alt="Max_heapify2"><br><img src="/img/Heapify3.png" alt="Max_heapify3"></p><p>Time Complexity: O(logN)</p><h3 id="Build-Max-Heap"><a href="#Build-Max-Heap" class="headerlink" title="Build Max Heap"></a>Build Max Heap</h3><p>For n&#x2F;2 to 1  &#x2F;&#x2F;从后往前第一个非叶节点开始<br>    do Max_heapify(A,i)</p><p>这里我们很容易“看出”时间复杂度是O(NlogN)，然而真的如此嘛？<br>可以想一下，最底一层的非叶结点进行的操作次数至多只有1次，而并非logN次，只有根结点才会进行logN次操作，所以经过数学推导，我们可以验证，建堆操作的时间复杂度是O(N)</p><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p>I think it’s just a simple use of Max_Heap.Easy to understand and I will just show the thoughts.<br>(1)Build Max_Heap from an unordered array.<br>(2)Find A[1] (the biggest element)<br>(3)Swap elements A[1] and A[n]<br>(4)Discard(移除) n from the heap<br>(5)Run MaxHeapify to fix the missing 1 place<br>(6)Go to Step 2 until empty</p><p>The time complexity of Heap Sort is O(NlogN)</p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>这节的内容整体还是挺容易的，特别是在写完priority_queue之后😋<br>Keep Going!</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic2</title>
    <link href="/2025/02/28/Mathematical-Logic2/"/>
    <url>/2025/02/28/Mathematical-Logic2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"><a href="#Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅" class="headerlink" title="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"></a>Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅</h5><h5 id="Result：果断重开了"><a href="#Result：果断重开了" class="headerlink" title="Result：果断重开了"></a>Result：果断重开了</h5><h5 id="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"><a href="#Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！" class="headerlink" title="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"></a>Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！</h5><h1 id="Mathematical-Logic-2-一阶逻辑的语义"><a href="#Mathematical-Logic-2-一阶逻辑的语义" class="headerlink" title="Mathematical Logic 2 一阶逻辑的语义"></a>Mathematical Logic 2 一阶逻辑的语义</h1><h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><p>在不同的场合下，同一个一阶逻辑命题可能有不同的含义。如对∀v0Rv0v0，既可以解读成“任意自然数都整除自己”（真），也可以解读成“任何实数都小于自己”（假）<br>So：讨论语义时首先需要确定讨论的数学对象</p><p>刚刚的例子中，自然数和实数明确了讨论对象取自怎样的集合，这个集合称作<strong>域</strong>（universe），记为A</p><p>确定符号集中每个符号的含义，就是确定每个符号对应的元素、集合或映射具体是什么：</p><ul><li>一个n元关系就是某个A^n的子集 a(R)</li><li>一个n元函数就是某个A^n到A的映射 a(f)</li><li>每个常数符号对应A中某个特定元素 a(c)</li></ul><p>我们把这个从符号到其具体含义的映射记为a。<br>A 和 a 确定了一阶逻辑中变量的“定义域”和符号集中每个符号的含义。我们把二元组(A,a)记为 𝔄，称作<strong>S-结构</strong>。</p><p>对于符号集S &#x3D; {R,f,c}，我们通常将a(R)写作$R^𝔄$或$R^A$，a(f)写作$f^𝔄$或$f^A$，a(c)写作$c^𝔄$或$c^A$。</p><h2 id="Interpretation-解释"><a href="#Interpretation-解释" class="headerlink" title="Interpretation 解释"></a>Interpretation 解释</h2><p>Structure给出了变量的定义域和符号集的语义，但我们接下来还有<strong>terms</strong>和<strong>formulas</strong></p><p><strong>一个term的语义是从一个term到universe中一个元素的映射</strong>——$\beta$<br>为了确定这个映射，我们首先需要知道term中的每个变量代表universe当中的哪个元素，这就是要我们给出一个$v_i$ -&gt; A 的映射$\beta$</p><p>所以我们把一个S-structure和一个S-assignment的二元组称作I &#x3D; (𝔄,$\beta$)<br>定义<strong>解释</strong>的语义</p><ul><li>对于变量x，I(x) &#x3D; $\beta$(x)</li><li>对于常量c，I(c) &#x3D; $c^𝔄$</li><li>对于n元函数关系f $\in$ S，$t_1,t_2,…,t_n$均为S-terms。那么有I(ft_1 … t_n) &#x3D; $f^𝔄$(I(t_1),I(t_2),…,I(t_n))</li></ul><p><strong>formula的语义是从一个term到“真或假”的映射(类似于bool?)</strong><br>对于一个formula 𝜑  ，我们用记号 I |&#x3D; 𝜑  来表示 公式 𝜑 的语义为真，读作I 满足𝜑 ，|&#x3D; 即称为<strong>满足关系</strong>。（ 解释 I 满足公式 𝜑  ）</p><p>下面是一些原子性&#x2F;关于逻辑连词&#x2F;量词的情况<br><img src="/img/%E8%A7%A3%E9%87%8A%E6%BB%A1%E8%B6%B3%E5%85%AC%E5%BC%8F.png" alt="解释满足formulas"></p><p>(a) 当且仅当I(t_1)，I(t_2)是universe下的同一个元素<br>(b) 当且仅当 (I(t_1),…,I(t_n)) 属于$R^𝔄$<br>(c) 当且仅当 解释I 不满足公式 𝜑<br>(d) 当且仅当 解释I 满足公式 𝜑 且 解释I 满足公式Ψ<br>(e) 当且仅当 解释I 满足公式 𝜑  或 解释I 满足公式Ψ<br>(f) （一个有点神奇的解释）当且仅当 I |&#x3D; φ（语法上）表明解释I 满足公式 𝜑 （语义上）<br>(g) 当且仅当（还有一个当且仅当，亿点点绕）（解释I 满足 公式 𝜑 当且仅当解释I 满足公式Ψ）</p><p>比较复杂的就是 ∀ 和 ∃<br>(h) 想说的意思是：当且仅当universe中每个元素为公式 𝜑 中出现的x赋值并保持其他变量赋值不变，公式 𝜑 始终不变</p><p>为此我们定义一个描述为formula中的某个特定变量赋特殊的值的方便的符号：<br><img src="/img/Assignment.png" alt="修改赋值函数"></p><p>于是新的解释I 变为了：<br><img src="/img/%E6%96%B0%E8%A7%A3%E9%87%8A.png" alt="新的解释"><br>这表示在解释I 中，将变量 𝑥 的赋值修改为 𝑎，其他部分保持不变。</p><p>于是(h)表示的即为：对于域 𝐴中的每一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 都为真。</p><p>(i) （也是同理）存在域 𝐴中的一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 为真。</p><p>如果一个公式 𝜑 是valid(恒真)，那么所有的解释都能满足公式 𝜑</p><p>逻辑推论的定义：<br>Φ 是一个S-公式的集合；<br>公式 𝜑 是一个单独的S-公式<br>如果 Φ |&#x3D; 𝜑，表示 𝜑 是 Φ 的逻辑推论，即公式 𝜑 可以从 Φ 中逻辑推导出来</p><p>我们称公式 𝜑 是可满足的，如果存在一个S-解释I，使得公式 𝜑 在解释I下为真</p><p>公式 𝜑 和公式 Ψ 是逻辑等价的，如果 𝜑 |&#x3D; Ψ 且 Ψ |&#x3D; 𝜑</p><p><img src="/img/%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7.png" alt="逻辑等价例子"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/">https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/</a></p><p>这位博主真的救命，讲的太清楚了</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic4</title>
    <link href="/2025/02/23/Java-Basic4/"/>
    <url>/2025/02/23/Java-Basic4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭"><a href="#Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭" class="headerlink" title="Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭"></a>Before：忙里偷闲出一期extra，感觉后面时间越来越少了，Games101遥遥无期😭😭😭</h5><h1 id="Java-Basic-4"><a href="#Java-Basic-4" class="headerlink" title="Java Basic 4"></a>Java Basic 4</h1><h2 id="Good-program-design"><a href="#Good-program-design" class="headerlink" title="Good program design"></a>Good program design</h2><p>Correct &#x2F; Easy to understand &#x2F; Easy to modify &#x2F; speed</p><h3 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h3><p>Variables: nouns,lowercase first letter,capitals separating words<br>Methods: Verbs,lowercase first letter<br>Classes:nouns,uppercase first letter</p><h3 id="Good-Class-Design"><a href="#Good-Class-Design" class="headerlink" title="Good Class Design"></a>Good Class Design</h3><ul><li>Make fields and methods private by default 默认私有即可，无需强行private</li><li>Only make methods public if you need to 只有必要时将函数设为公有</li><li>If you need access to a field, create a method 我们建议将成员变量设成private，再通过get或set函数来获取值或修改值</li></ul><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><h3 id="Interval-Testing"><a href="#Interval-Testing" class="headerlink" title="Interval Testing"></a>Interval Testing</h3><p>Important cases<br>下界以下、等于下界、在区间内、等于上界、上界以上</p><h3 id="Eclipse-Warnings"><a href="#Eclipse-Warnings" class="headerlink" title="Eclipse Warnings"></a>Eclipse Warnings</h3><p>May not be a mistake, but it likely is.<br>Always fix all warning!</p><h3 id="Assertion-断言"><a href="#Assertion-断言" class="headerlink" title="Assertion 断言"></a>Assertion 断言</h3><p>断言用于验证代码是否按预期运行</p><ul><li>当断言条件为真时，程序正常运行，不会有额外操作。</li><li>当断言条件为假时，程序会崩溃并抛出错误。</li></ul><p><code>assert difference &gt;= 0</code><br>这行代码表示断言变量difference的值大于或等于0，如果不满足该条，程序将报错。</p><h2 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h2><p><img src="/img/interface.png" alt="Implementation/Interface"><br>Java接口可以在不了解对象内部工作原理的情况下对其进行操作。</p><ul><li>当处理相似但不完全相同的对象时，接口很有用</li><li>当想要使用他人编写的代码时，接口也很实用。通过定义接口，代码提供者可以明确对外提供的功能契约，使用者只需按照接口定义来调用，而无需关心具体实现细节</li></ul><p>类比：C++中的抽象基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Graphics<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drawable</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Graphics surface)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(Color color)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Graphics<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drawable</span>&#123;<br>    <span class="hljs-comment">//some stuff...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Graphics surface)</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>implement关键字：用于类与接口之间的关系，表明一个类要实现接口中定义的所有抽象方法。<strong>一个类可以实现多个接口</strong>，从而具备多种不同的行为。（与后文提到的extends一个重要的区别）</p><h3 id="Interface-Notes-关于抽象基类"><a href="#Interface-Notes-关于抽象基类" class="headerlink" title="Interface Notes 关于抽象基类"></a>Interface Notes 关于抽象基类</h3><ul><li>只有函数</li><li>不提供具体代码实现，只提供定义</li><li>一个类可以实现任意数量的接口<br>关于最后一点，在C++中，可以举个这样的例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 第一个抽象类，模拟第一个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数，模拟接口方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Flyable</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 第二个抽象类，模拟第二个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Swimmable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数，模拟接口方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Swimmable</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 一个类继承多个抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> : <span class="hljs-keyword">public</span> Flyable, <span class="hljs-keyword">public</span> Swimmable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 实现Flyable接口的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Duck is flying.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// 实现Swimmable接口的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Duck is swimming.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><p>当通过接口来引用对象时，只能访问接口中定义的成员（方法、常量等）<br>举个例子：<br><code>Drawable d = new BouncingBox(...);</code><br>d只能访问Grawable接口中定义的draw函数<br>相当于接口限定了外部可见功能的边界</p><h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Drawable d <span class="hljs-operator">=</span> new BouncingBox(...)<span class="hljs-comment">;</span><br>BouncingBox box <span class="hljs-operator">=</span> (BouncingBox) d<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>则box可以调用BouncingBox类中</p><h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>extends关键字：用于类与类之间的继承关系，即一个类（子类、派生类）可以继承另一个类（父类、基类）的属性和方法。<br>特别注意的是：<strong>在 Java 里，类的继承只支持单继承，也就是一个子类只能有一个直接父类。</strong><br>class A extends B{}：A是B的子类<br>A拥有B的全部成员变量和函数，且可以增加自己的成员变量和函数</p><p>Example:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    void eat() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Animal is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    void bark() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Dog is barking.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然A也可以通过implement替换父类中的某个函数<br>Example:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> speed;<br><br>    void move() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Vehicle is moving.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">extends</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> numDoors;<br><br>    <span class="hljs-variable">@Override</span><br>    void move() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car is moving on the road.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>Java中的报错信息主要为以下几种：<br><img src="/img/Exceptions.png" alt="Java Exceptions"><br>Java 通过创建异常对象并抛出的方式处理异常</p><h3 id="throw-主动抛出异常"><a href="#throw-主动抛出异常" class="headerlink" title="throw 主动抛出异常"></a>throw 主动抛出异常</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>throws &amp; throw：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) throws ArrayOutOfBoundsException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= size())<br>        throw <span class="hljs-built_in">new</span> ArrayOutOfBoundsException(&quot;&quot;+<span class="hljs-keyword">index</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>throws关键字：用于方法声明中，它告诉 Java 这个get方法在执行过程中可能会抛出ArrayOutOfBoundsException（数组越界异常）</li><li>throw关键字：用于实际抛出一个ArrayOutOfBoundsException异常对象，并将index作为参数传递给异常构造函数，方便在异常处理时获取相关信息。</li></ul><h3 id="try-catch-捕获并处理异常"><a href="#try-catch-捕获并处理异常" class="headerlink" title="try-catch 捕获并处理异常"></a>try-catch 捕获并处理异常</h3><p>Java希望调用get函数来处理异常</p><ul><li>Catching it</li><li>Rethrowing it</li></ul><p>try块用于执行可能会抛出异常的代码。在执行过程中，一旦代码抛出异常，程序的执行流程就会立即改变。<br>catch块则是告诉 Java 当捕获到指定类型的异常时，应该执行什么样的处理逻辑。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">get</span>(<span class="hljs-number">-1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ArrayOutOfBoundsException err) &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;oh dear!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws Exception</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O-文件读写"><a href="#I-O-文件读写" class="headerlink" title="I&#x2F;O 文件读写"></a>I&#x2F;O 文件读写</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>以字节为单位进行数据读写，适用于处理所有类型的数据，如图片、音频等二进制文件。<br>InputStream（输入字节流的抽象类）和OutputStream（输出字节流的抽象类）</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>以字符为单位进行数据读写，适合处理文本数据。主要的字符流类有Reader（输入字符流的抽象类）和Writer（输出字符流的抽象类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;./src/readme&quot;</span>);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>        <span class="hljs-comment">//缓冲功能</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(line);<br>        &#125;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>MIT 6.092: Introduction To Programming In Java<br>完结撒花🎇🎆</p>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
      <tag>Exceptions</tag>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic1</title>
    <link href="/2025/02/21/Mathematical-Logic1/"/>
    <url>/2025/02/21/Mathematical-Logic1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-数理逻辑CS2950是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是Yin-Qiang，Yijia-Chen的学生。后续会更新这门“抽象”的课的Lecture-Notes❤️">Before: 数理逻辑<a href="https://wiki.pdy.app:8443/s/96e05898-1739-424b-8a49-85de7c83ebec">CS2950</a>是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是<a href="https://cs.sjtu.edu.cn/~qyin/">Yin Qiang</a>，<a href="https://basics.sjtu.edu.cn/~chen/">Yijia Chen</a>的学生。后续会更新这门“抽象”的课的Lecture Notes❤️</h5><h1>Methematical Logic 1 Introduction &amp; The Syntax of First-order Logic</h1><h2 id="Course-Introduction">Course Introduction</h2><p>Four Problems mainly</p><ul class="lvl-0"><li class="lvl-2">What is a mathematical proof</li><li class="lvl-2">What makes a proof correct</li><li class="lvl-2">Is there a boundary of provability</li><li class="lvl-2">Can computers find proofs</li></ul><h3 id="Q1-What-is-a-mathematical-proof">Q1.What is a mathematical proof</h3><p>Based on first-order logic</p><h3 id="Q2-What-makes-a-proof-correct">Q2.What makes a proof correct</h3><p>Gödel Completeness Theorem</p><h3 id="Q3-Is-there-a-boundary-of-provability"><a href="http://Q3.Is">Q3.Is</a> there a boundary of provability</h3><p>Gödel’s First Incompleteness Theorem</p><h3 id="Q4-Can-computers-find-proofs">Q4.Can computers find proofs</h3><p>Any computer program cannot decide whether an arbitrary input mathematical statement has a proof.<br>Turing’s undecidability of the halting problem.(图灵停机问题不可判定)</p><p>Below is A Proof of Q4:<br>φP,x has a proof | P will eventually halt on input x<br>1.construct the mathematical statement φx,x<br>2.call the program T on input φx,x<br>3.if T(φx,x) = yes then run forever else halt</p><p>Then we can get that H(H) haltss iff H(H) does not halt.(Using what we know up)</p><h2 id="The-Syntax-of-First-order-Logic-一阶逻辑语法">The Syntax of First-order Logic 一阶逻辑语法</h2><h3 id="Alphabets-字母表">Alphabets 字母表</h3><p>an nonempty set of symbols 非空符号的集合</p><h3 id="Word-词">Word 词</h3><p>A word w over A(an Alphabet) is a finite sequence of symbols in A,i.e,<br>$$<br>w = w_1w_2…w_n<br>$$<br>$<br>w_i \in A<br>$<br>$A^*$ denotes the set of all words over A</p><h3 id="Countable-Set">Countable Set</h3><p>There exists an injective function(单射) α from N onto M<br>At most countable: if M is either finite or countable</p><p>Two lemmas<br>1.These three equivalent:<br>(1)M is at most countable<br>(2)an surjective function f:N -&gt; M<br>(3)an injective function f:M -&gt; N<br>2.A is most countable,then $A^*$ is countable.</p><h3 id="Terms-项">Terms 项</h3><p>Variable Constant are both S-terms.<br>And if f is a n-ary function symbol in S,then f(S-terms) is also a S-term.</p><h3 id="Formula-公式">Formula 公式</h3><p>The set $L^S$ of S-formulas contains precisely those words in $A^∗_S$ which can be obtained by applying the following rules finitely many times.<br><img src="/img/Formula.png" alt="Formula Rules"></p><h3 id="Variables-变量">Variables 变量</h3><p>Let t be a S-term, then var(t) is the set of variables in t.</p><h3 id="Free-Variables-自由变元">Free Variables 自由变元</h3><p>We say that an occurrence of x in φ is free if it is not in the scope of any ∀x or ∃x.<br>只有出现在约束范围内的变量才算是约束出现的</p><h3 id="Sentence-句子">Sentence 句子</h3><p>If free(φ) is ∅,then it’s a sentence. 没有自由变元<br>Reflect Mathematical characteristics.<br>$L_N^S$:= {φ | φ an S-formula with free(φ) ⊆ {v0, . . . , vn−1}}.</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic3</title>
    <link href="/2025/02/11/Java-Basic3/"/>
    <url>/2025/02/11/Java-Basic3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Welcome-back-to-JaneZ’s-Java-Learning"><a href="#Before：Welcome-back-to-JaneZ’s-Java-Learning" class="headerlink" title="Before：Welcome back to JaneZ’s Java Learning!"></a>Before：Welcome back to JaneZ’s Java Learning!</h5><h2 id="Java-Basic-3"><a href="#Java-Basic-3" class="headerlink" title="Java Basic 3"></a>Java Basic 3</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Public VS Private ————对于fields和methods而言<br>Public: 可以被其他对象调用  Private: 只可被类内成员调用<br>那么为什么要对访问权限进行公有和私有的区分呢？</p><ul><li>为了保护私有信息</li><li>声明其他对象应该如何调用当前类</li><li>将实现与接口分离————意味着你可以自由地修改类的内部实现，而不影响使用该类的其他代码，只要公共接口保持不变</li></ul><h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><p>在函数中定义的变量只能在该函数中进行访问，而在类中定义的变量可以在类的所有函数中进行访问<br>函数级别的变量只在函数内部有效，而类级别的变量在整个类中都有效</p><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>用于引用当前对象的实例，其作用在于：</p><ul><li>明确作用域（Clarifies scope）：<br>当类中的成员变量和方法参数同名时，使用this关键字可以明确指出要访问的是成员变量而不是参数。</li><li>表示“my object”：<br>this关键字用于引用当前对象，即调用方法的对象。</li></ul><h3 id="Java的包-Package"><a href="#Java的包-Package" class="headerlink" title="Java的包 Package"></a>Java的包 Package</h3><p>类似于C++中的namespace(名字空间)</p><ul><li>每个类都属于一个包，包是组织类的一种形式</li><li>同一包中的类具有相似的用途。例如，所有与图形用户界面相关的类可能放在一个名为 gui 的包中。</li><li>包只是目录</li><li>需要导入其他包中的类<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> com.example.data;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataModel</span> </span>&#123;<br>    // 数据模型相关的代码<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h4><p>在C++中，我们有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> myapp &#123;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace myapp</span><br></code></pre></td></tr></table></figure><p>而相应的在Java中，我们有：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package com.example.myapp; <span class="hljs-comment">// 文件路径</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义的基本格式为：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> path.to.package.foo<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="包的使用方式"><a href="#包的使用方式" class="headerlink" title="包的使用方式"></a>包的使用方式</h4><p>在C++中，我们有<code>using namespace std</code><br>而相应的在Java中，我们有：<code>import path.to.package.foo.Foo</code></p><h4 id="为什么包？（好奇怪的句子"><a href="#为什么包？（好奇怪的句子" class="headerlink" title="为什么包？（好奇怪的句子"></a>为什么包？（好奇怪的句子</h4><ul><li>组合相似功能<br>包可以用来将功能相似的类组合在一起。这样做可以提高代码的模块化，使得相关功能更加集中和易于管理。</li><li>区分相似名称<br>包还可以用来区分具有相似名称的类，以避免命名冲突。<br>例如，shopping.List 和 packing.List 这两个类虽然名称相似，但它们位于不同的包中，分别代表购物清单和打包清单。通过使用包，我们可以清楚地区分这两个类，即使它们的名称相同。</li></ul><h4 id="特殊的包"><a href="#特殊的包" class="headerlink" title="特殊的包"></a>特殊的包</h4><p>首先，同一包内的类可以互相访问。<br>其次，还有一个比较特殊的包：java.lang<br>所有位于 java.lang 包中的类都不需要显式导入就可以在任何地方使用。这是Java语言规范的一部分，java.lang 包被视为Java程序的基础包，其中包含了一些最常用的类，如 String、Math、System 等。</p><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><p>起因是在使用deepseek时看到了这样一个界面：<br><img src="/img/deepseekAPI.png" alt="deepseekAPI"><br>一直对<strong>API</strong>为何物充满了疑问，出于好奇还充了10块钱买了五百万tokens，但并不知道应该如何使用😅（最近资源紧张似乎已经买不了了🤣）<br>在看到这里时十分激动，于是立刻开始了学习！<br>首先，我先问了deepseek✌，API是什么？<br><img src="/img/APIanswer.png" alt="APIanswer"><br><strong>Application Programing Interface!</strong><br>好像也没有那么抽象嘛？我的理解是就是一种很不错的工具，通过标准化接口简化开发，提升效率，广泛应用于数据访问、服务集成和微服务架构中。而我们要讨论的Java API，其实就类似于C++&#x2F;Python中的标准库（standard library）<br>Java语言包含了大量的包（packages）和类（classes），开发者可以利用Java提供的现有类来完成特定的任务，而不需要从头开始编写代码，这样可以节省时间和努力。<br>C++中的标准模板库（STL）我们已经挺熟悉的了，那么接下来，让我们看看Java API中有什么相应的数据结构：<br>1.ArrayList<br>我们知道在C++中有std::vector，可以动态地调节数组的大小，而在Java中，有一个具有同样功能的容器————<strong>ArrayList</strong>，其用法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ArrayList&lt;Book&gt; books = <span class="hljs-keyword">new</span> ArrayList&lt;Book&gt;();<br>books.<span class="hljs-keyword">add</span>(b);<br>books.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span> , a); <span class="hljs-comment">//相当于insert</span><br>books.<span class="hljs-keyword">remove</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//相当于remove</span><br></code></pre></td></tr></table></figure><p>2.Set<br>同样的，我们知道在C++中有std::set，表示集合，而在Java中，有一个具有相似功能的容器————<strong>Set</strong>，其特点如下：</p><ul><li>集合中每个对象只存储一份，即不允许重复</li><li>集合中的对象没有索引，不能通过索引访问对象<br>下面是两种主要的Set实现：</li><li>TreeSet，对应C++中的std::set  有序</li><li>HashSet，对应C++中的std::unordered_set  无序但查找更快</li></ul><p>3.Map<br>更加同样的，我们知道在C++中有std::map，表示映射，而在Java中，有一个具有相似功能的容器————<strong>Map</strong>，其特点如下：</p><ul><li>存储的是键值对（key-value pair）</li><li>可以通过查找键（key）来获取对应的值（value）<br>下面是两种主要的Map实现：</li><li>TreeMap，对应C++中的std::map  有序</li><li>HashMap，对应C++中的std::unordered_map  无序但查找更快</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOP</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic2</title>
    <link href="/2025/02/09/Java-Basic2/"/>
    <url>/2025/02/09/Java-Basic2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：快开学了（-还没玩够呢呜呜呜😢-）"><a href="#Before：快开学了（-还没玩够呢呜呜呜😢-）" class="headerlink" title="Before：快开学了（ 还没玩够呢呜呜呜😢 ）"></a>Before：快开学了（ 还没玩够呢呜呜呜😢 ）</h5><p>下面是一点碎碎念吧：<br>昨天和fz学弟吃饭，震惊于学弟对物竞的执着，想必是没法把学弟骗来泥交了吧🤣🤣🤣。想起了3年前的自己对数竞也是一样的痴迷，励志要把一生都献给纯数研究。当时应该还在学物竞，尝试着数物双修。还是在寒假后放弃了物理，选了数学，当然最后也只以高二的省一草草收场。有时候想，如果当时跟大多数人一样学了物理，大概至少也有个国一吧。经常嘴上说自己物理差数学好，其实细想自己还是挺喜欢物竞的。下学期也是终于有物理课了，希望能借此找到以前对物理的热爱❤️</p><h2 id="Java-Basic-2"><a href="#Java-Basic-2" class="headerlink" title="Java Basic 2"></a>Java Basic 2</h2><h3 id="Good-Programing-Style-代码风格"><a href="#Good-Programing-Style-代码风格" class="headerlink" title="Good Programing Style 代码风格"></a><strong>Good Programing Style 代码风格</strong></h3><ul><li>Rule 1 : 使用好的&#x2F;有意义的变量名</li><li>Rule 2 : 正确的缩进  Ctrl + shift + F 可自动调节缩进</li><li>Rule 3 : 空格 （特别是在复杂的表达式中） 空行 增强可读性</li><li>Rule 4 : 不要重复测试 可能存在多个条件判断中不必要的重复检查等问题，使得代码不够简洁和高效。</li></ul><h3 id="循环-Loops"><a href="#循环-Loops" class="headerlink" title="循环 Loops"></a>循环 Loops</h3><p>Java中有几个循环语句，与C ++ 中几乎一致</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">( condition )</span></span>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(initialization; condition ; updata)</span></span>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="break-continue"><a href="#break-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h4><p>与C ++ 中用法一致</p><h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 Arrays"></a>数组 Arrays</h3><p>与C ++ 同样都是 0 ~ base - 1</p><h4 id="Arrays-的定义"><a href="#Arrays-的定义" class="headerlink" title="Arrays 的定义"></a>Arrays 的定义</h4><p>int[] values;  &#x2F;&#x2F;整型一维数组<br>int[][] values; &#x2F;&#x2F;整型二维数组<br>如果想创建一个固定大小的数组，使用运算符 new<br>int[] values &#x3D; new int[5];</p><h4 id="Arrays-初始化"><a href="#Arrays-初始化" class="headerlink" title="Arrays 初始化"></a>Arrays 初始化</h4><p>注意：这种方法只能在声明变量时使用：<br>int[] values &#x3D; {12 , 24 , -23 , 47};</p><h4 id="Arrays-访问"><a href="#Arrays-访问" class="headerlink" title="Arrays 访问"></a>Arrays 访问</h4><p>同样是下标访问  values[index]</p><h4 id="length-变量"><a href="#length-变量" class="headerlink" title="length 变量"></a>length 变量</h4><p>Java数组在这里与C++数组存在一点区别：<br>C++中length变量只存在于STL容器中，普通数组并不具备这一变量，但Java中则存在<br>For example:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span>[] <span class="hljs-keyword">values</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">12</span>];<br><span class="hljs-type">int</span> size = <span class="hljs-keyword">values</span>.length;<br></code></pre></td></tr></table></figure><h4 id="String-Array"><a href="#String-Array" class="headerlink" title="String Array"></a>String Array</h4><p>Java中允许字符串数组（C ++ 中并不允许string数组）</p><h3 id="Object-Oriented-Programing-面向对象编程"><a href="#Object-Oriented-Programing-面向对象编程" class="headerlink" title="Object Oriented Programing 面向对象编程"></a>Object Oriented Programing 面向对象编程</h3><h4 id="Why-use-classes"><a href="#Why-use-classes" class="headerlink" title="Why use classes ?"></a>Why use classes ?</h4><p><img src="/img/whyclasses1.png" alt="Why use classes"><br><img src="/img/whyclasses2.png" alt="Why use classes"></p><h4 id="Class-Definition"><a href="#Class-Definition" class="headerlink" title="Class Definition"></a>Class Definition</h4><p><code>Baby myBaby = new Baby();</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baby</span></span>&#123;<br>    fields<br>    methods<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数-constructer"><a href="#构造函数-constructer" class="headerlink" title="构造函数 constructer"></a>构造函数 constructer</h4><ul><li>函数名即为类名</li><li>没有返回值</li><li>通常初始化fields</li><li>每个类至少需要一个构造函数<br>For example:<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span>&#123;<br>    <span class="hljs-type">String</span> name;<br>    <span class="hljs-type">boolean</span> isMale;<br>    <span class="hljs-built_in">Baby</span>(<span class="hljs-type">String</span> myname , <span class="hljs-type">boolean</span> malebaby)&#123;<br>        name = myname;<br>        isMale = malebaby;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="调用类"><a href="#调用类" class="headerlink" title="调用类"></a>调用类</h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">Baby</span> <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">Baby</span> <span class="hljs-type">Jane</span> = new <span class="hljs-type">Baby</span>(<span class="hljs-string">&quot;JaneZ&quot;</span> , <span class="hljs-literal">false</span> );<br><span class="hljs-type">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">Jane</span>.name);<br><span class="hljs-type">Jane</span>.sayhi();<br></code></pre></td></tr></table></figure><h3 id="基本数据类型-VS-引用数据类型"><a href="#基本数据类型-VS-引用数据类型" class="headerlink" title="基本数据类型 VS 引用数据类型"></a>基本数据类型 VS 引用数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>包括 int（整数）、long（长整数）、double（双精度浮点数）、boolean（布尔值）、char（字符）、short（短整数）、byte（字节）、float（单精度浮点数）</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>数组和对象<br>所占的空间比基本数据类型要大的多</p><h3 id="Java-对Object-的存储——引用！"><a href="#Java-对Object-的存储——引用！" class="headerlink" title="Java 对Object 的存储——引用！"></a>Java 对Object 的存储——引用！</h3><p><strong>Reference</strong>: Object的存储位置<br>遵循对对象的引用 &lt;-&gt; 按照指示前往一所房子<br>改变对象中的字段 &lt;-&gt; 挪动房子里的家具</p><h3 id="静态数据类型和函数"><a href="#静态数据类型和函数" class="headerlink" title="静态数据类型和函数"></a>静态数据类型和函数</h3><p>静态字段或函数是为类声明（class declaration）而定义的<br>也就是说，它们属于类本身，而不是类的某个具体实例</p><h4 id="Why-public-static-void-main-String-arguments"><a href="#Why-public-static-void-main-String-arguments" class="headerlink" title="Why public static void main(String[] arguments)"></a>Why <code>public static void main(String[] arguments)</code></h4><ul><li>无需实例化：程序启动时，Java 虚拟机（JVM）需要直接调用 main 方法来执行程序。如果 main 方法不是 static，JVM 就需要先实例化一个类的对象，然后才能调用 main 方法，但在程序启动初期，没有合适的机制来创建对象，所以将 main 声明为 static，JVM 可以直接通过类名调用它，无需创建类的实例。</li><li>内存和性能考虑：静态方法在类加载时就已经绑定到类上，调用时不需要额外的对象创建开销，这有助于提高程序启动的效率，并且在程序启动阶段也更符合内存管理和性能优化的需求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basic1</title>
    <link href="/2025/02/03/Java-Basic1/"/>
    <url>/2025/02/03/Java-Basic1/</url>
    
    <content type="html"><![CDATA[<h5 id="JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）"><a href="#JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）" class="headerlink" title="JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）"></a>JaneZ的Java学习启动了（本来上学期中就想开始的，但大作业真的难评）</h5><h4 id="Before-我选择了MIT-6-092-Introduction-To-Programming-In-Java作为Java的入门，目标是快速上手Java"><a href="#Before-我选择了MIT-6-092-Introduction-To-Programming-In-Java作为Java的入门，目标是快速上手Java" class="headerlink" title="Before: 我选择了MIT 6.092: Introduction To Programming In Java作为Java的入门，目标是快速上手Java"></a>Before: 我选择了MIT 6.092: Introduction To Programming In Java作为Java的入门，目标是快速上手Java</h4><h2 id="Java-Basic-1"><a href="#Java-Basic-1" class="headerlink" title="Java Basic 1"></a>Java Basic 1</h2><h3 id="Compiling-Java"><a href="#Compiling-Java" class="headerlink" title="Compiling Java"></a>Compiling Java</h3><p>Source Code(.java) -&gt; javac -&gt; Byte Code -&gt; java</p><h3 id="Java版的Hello-world"><a href="#Java版的Hello-world" class="headerlink" title="Java版的Hello world"></a>Java版的Hello world</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] <span class="hljs-variable language_">arguments</span></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>,<span class="hljs-title function_">printIn</span>(<span class="hljs-string">&quot;Hello world.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Program-Structure"><a href="#Program-Structure" class="headerlink" title="Program Structure"></a>Program Structure</h3><p>class <strong>CLASSNAME</strong>{<br>    public static void main(String[] arguments){<br>        <strong>STATEMENTS</strong><br>    }<br>}</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>System.out.printIn(some String)<br>Example:</p><ul><li>System.output.printIn(“output”);</li><li>Console: output</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>boolean 相当于C&#x2F;C++中的bool<br>int 相当于C&#x2F;C++中的int<br>double 相当于C&#x2F;C++中的double<br>String 相当于C&#x2F;C++中的string<br><strong>注意：Java要求数据类型必须正确匹配</strong><br>如：String five &#x3D; 5; &#x2F;&#x2F; ERROR</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Form:<br>Type Name;</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用 &#x3D;  与C&#x2F;C++相同<br>Example:<br>String foo;<br>foo &#x3D; “IAP 6.092”;<br>double badPi &#x3D; 3.14;</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>与C&#x2F;C++完全一致<br>&#x3D; + - * &#x2F;(整数进行&#x2F;时同样是向下取整)<br><strong>注意： double b &#x3D; 5&#x2F;2; &#x2F;&#x2F; b &#x3D; 2.0</strong><br>优先级：括号 &gt; 乘除法 &gt; 加减法<br>也支持 +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; 等复合运算符</p><h3 id="字符串加法"><a href="#字符串加法" class="headerlink" title="字符串加法"></a>字符串加法</h3><p>String text &#x3D; “hello” + “world”;<br>text &#x3D; text + “number” + 5;<br>&#x2F;&#x2F; text &#x3D; “helloworldnumber5”;</p><h3 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h3><ul><li>强制类型转换 ： int a &#x3D; (int)18.7;</li><li>隐式类型转换 ：double a &#x3D; 2;&#x2F;&#x2F;2.0</li></ul><h3 id="Java的函数——Method"><a href="#Java的函数——Method" class="headerlink" title="Java的函数——Method"></a>Java的函数——Method</h3><p>Example:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NAME</span>()</span>&#123;<br>    STATEMENTS<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：NAME();</p><h4 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">NewLine</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newLine</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">threeLines</span>()</span>&#123;<br>        newLine();<br>        newLine();<br>        newLine();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] arguments</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;Line 1&quot;</span>);<br>        threeLines();<br>        System.<span class="hljs-keyword">out</span>.printIn(<span class="hljs-string">&quot;Line 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数参数Parameter"><a href="#函数参数Parameter" class="headerlink" title="函数参数Parameter"></a>函数参数Parameter</h4><p>Example:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-keyword">NAME</span>(<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    STATEMENTS</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>调用：<br>NAME(EXPRESSION);<br>Another Example:<br>多个参数</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-keyword">NAME</span>(<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>,<span class="hljs-keyword">TYPE</span> <span class="hljs-keyword">NAME</span>)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    STATEMENTS</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Return-Values-返回值"><a href="#Return-Values-返回值" class="headerlink" title="Return Values 返回值"></a>Return Values 返回值</h4><p>Example：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TYPE <span class="hljs-title">NAME</span>()</span>&#123;<br>    STATEMENTS<br>    <span class="hljs-keyword">return</span> EXPRESSION;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IF-ELSE语句"><a href="#IF-ELSE语句" class="headerlink" title="IF ELSE语句"></a>IF ELSE语句</h3><p>Example:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(CONDITION)</span></span>&#123;<br>    STATEMENTS<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(CONDITION)&#123;<br>    STATEMENTS<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    STATEMENTS<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>x &gt; y  x &lt; y  x &gt;&#x3D; y x &lt;&#x3D; y  x&#x3D;&#x3D; y</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;&amp; ||</p>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Before Everything</title>
    <link href="/2025/01/21/Before-Everything/"/>
    <url>/2025/01/21/Before-Everything/</url>
    
    <content type="html"><![CDATA[<h1>Before Everything 前言</h1><p>By JaneZ,2025.1.21,M Stand Coffee,Nanjing<br>Well, hello world ! This is the owner of this blog! My name is JaneZ , a student from <a href="https://www.sjtu.edu.cn/">Shanghai Jiaotong University</a>.I major in <strong>Computer Science</strong> in <a href="https://acm.sjtu.edu.cn/home">ACM Class</a>.I’m an ENTJer.</p><p>First, I want to thank my high school classmate <a href="https://github.com/xiyuanyang-code">Xiyuan Yang</a> for giving me the idea of setting up a blog, who majors in <a href="https://soai.sjtu.edu.cn/">Artificial Intelligence</a> also in SJTU and has been a model of mine ever since in Year 11.</p><p>My blog (personal homepage) uses the <a href="https://hexo.io/zh-cn/">Hexo</a> Fluid theme, where I mainly share notes from my daily studies and learning insights.Welcome to my blog if you’re interested in <strong>CS or Music</strong>!!! If you have any questions about configuring or deploying a Hexo blog, feel free to ask me. I’ve encountered some pitfalls myself, and I hope no one else has to fall into them.</p><p>Any way,let’s get started.</p><p>Attach a picture of this wonderful coffee shop!<br><img src="/img/MStandCoffee.png" alt="M Stand Coffee"></p><p>Can’t live without coffee … ？</p><p>upd: Something bad happens.Bye Coffee😢</p><p>upd：No coffee and alcohol for an entire semester. Now I’m a brand-new person.</p>]]></content>
    
    
    
    <tags>
      
      <tag>JaneZ&#39;s Wonderland</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
