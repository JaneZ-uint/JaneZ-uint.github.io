<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>25 Fall</title>
    <link href="/2025/09/15/25-Fall/"/>
    <url>/2025/09/15/25-Fall/</url>
    
    <content type="html"><![CDATA[<h1>25 Fall Learning Record</h1><hr><p>25 Fall 开始，依托的RCompiler，混乱的Arch课程，两门😇 的数学课，三节早八的物理课，毫无想法的xzjt，TA 工作，</p><p>原来已经大二了😥</p><p>学期有些规划。</p><p>该如何收场。</p><p>CSAPP 和 CAAQA。</p><p>快让我润出去吧，每天都在幻想能不能直接跳过本科3年直接润美😇</p><p>我要换 Macbook 了. 还是不换了，thinkpad还能用（</p><hr><p>大多数人都生活在平静的绝望中：欲言又止。</p><p>最优化有意思。</p><p>天热总是令人头痛，再喝可乐，就会变成可乐了。</p><hr><p><a href="/img/MCL.jpg">Sunset &amp; McLaren</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Compiler</tag>
      
      <tag>Arch</tag>
      
      <tag>Probability Theory</tag>
      
      <tag>Optimization</tag>
      
      <tag>Physics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph Algorithm</title>
    <link href="/2025/05/23/AlgorithmOfDS5/"/>
    <url>/2025/05/23/AlgorithmOfDS5/</url>
    
    <content type="html"><![CDATA[<h1>Graph Algorithms</h1><h4 id="ps-上机课是05-18上的，算法是05-23学的🤣（评价是这周事还是太多了）perhaps和这节上机课量巨大也有关系吧😢">ps: 上机课是05.18上的，算法是05.23学的🤣（评价是这周事还是太多了）perhaps和这节上机课量巨大也有关系吧😢</h4><h2 id="术语回顾">术语回顾</h2><ul><li>DAG 有向无环图</li><li>点度 = 入度 + 出度</li><li>SPT 最短路径树</li></ul><h2 id="最短路-单源-多源">最短路 单源/多源</h2><p>Q：给出一个加权图和图上的一个节点s，找出s到图中每一节点的最短路径</p><h3 id="Dijkstra-算法">Dijkstra 算法</h3><p>Core:<br><strong>v=argmin_u∈SPT,(u,v)∈E,v∉SPT{d(s,u)+w(u,v)}</strong></p><p>代码实现（使用pq进行优化）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;queue&gt;</span><br>struct edge&#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct ver&#123;<br>    edge *head;<br>&#125;;<br>ver G[<span class="hljs-number">200005</span>];<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)&#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = w;<br>    <span class="hljs-keyword">current</span>-&gt;next = G[u].head;<br>    G[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">bool</span> known[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> distance[<span class="hljs-number">200005</span>];<br>struct Pair&#123;<br>    <span class="hljs-type">int</span> dis;<br>    <span class="hljs-type">int</span> u;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(const Pair &amp;a)const&#123;<br><span class="hljs-keyword">return</span> dis &gt; a.dis;<br>    &#125;<br>&#125;;<br>priority_queue&lt;Pair&gt; pq;<br><span class="hljs-type">int</span> main()&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin &gt;&gt; <span class="hljs-keyword">start</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++)&#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; <br>        add_edge(u,v,w);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        known[i] = <span class="hljs-keyword">false</span>;<br>        distance[i] = <span class="hljs-number">1e9</span>;<br>    &#125;<br>    distance[<span class="hljs-keyword">start</span>] = <span class="hljs-number">0</span>;<br>    pq.push(&#123;<span class="hljs-number">0</span>,<span class="hljs-keyword">start</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.empty())&#123;<br>        Pair top = pq.top();<br>        pq.pop();<br>        <span class="hljs-keyword">if</span>(known[top.u])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        known[top.u] = <span class="hljs-keyword">true</span>;<br>        edge *<span class="hljs-keyword">current</span> = G[top.u].head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>            <span class="hljs-keyword">if</span>(dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] &gt; dis[top.u] + <span class="hljs-keyword">current</span>-&gt;weight)&#123;<br>                dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = dis[top.u] + <span class="hljs-keyword">current</span>-&gt;weight;<br>                pq.push(&#123;dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>],<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>upd：改了一下Dijkstra的板子（某个🤡机考的时候Dijkstra板子写成了修改前的错误版本导致痛失70分😭😭😭）。<br>总结：板子写错最为致命🫠🫠🫠 逆天机考至少有170分的😅😅😅</p><h3 id="Bellman-Ford-算法">Bellman-Ford 算法</h3><p><strong>用于处理存在负边的图</strong><br>update操作的正确性毋庸置疑<br>于是，假设d(s,v)最短路经过k个点，那么在经过(k-1)个点的最短路都被确定的前提下，一次update操作保证了d(s,v)的正确性</p><p>代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br>struct edge&#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct ver&#123;<br>    edge *head;<br>&#125;;<br>ver G[<span class="hljs-number">200005</span>];<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)&#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = w;<br>    <span class="hljs-keyword">current</span>-&gt;next = G[u].head;<br>    G[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> distance[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> main()&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin &gt;&gt; <span class="hljs-keyword">start</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++)&#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; <br>        add_edge(u,v,w);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        known[i] = <span class="hljs-keyword">false</span>;<br>        distance[i] = <span class="hljs-number">1e9</span>;<br>    &#125;<br>    distance[<span class="hljs-keyword">start</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        flag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j ++)&#123;<br>            <span class="hljs-keyword">if</span>(dis[<span class="hljs-keyword">current</span>] == <span class="hljs-number">1e9</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            edge *<span class="hljs-keyword">current</span> = G[j].head;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>                <span class="hljs-keyword">if</span>(dis[curent-&gt;<span class="hljs-keyword">end</span>] &gt; dis[j] + <span class="hljs-keyword">current</span>-&gt;weight)&#123;<br>                    dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = dis[j] + <span class="hljs-keyword">current</span>-&gt;weight;<br>                    flag = <span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)&#123;<br>            break;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag)&#123;<br>        std::cout &lt;&lt; <span class="hljs-number">-1</span>;//存在负权环<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SPFA-算法-（已经死了）">SPFA 算法 （已经死了）</h3><p><sub>虽然可以构造数据把BF的队列优化卡掉，</sub>但还是学习一下这种优化吧，毕竟笔者刚做小作业时，第一遍BF 大T特T，第二遍SPFA 被卡了一个点，最后进行了SPFA + SLF优化才过。</p><p>首先是SPFA的队列优化</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">bool visit[<span class="hljs-number">25005</span>];<span class="hljs-comment">//用于维护结点是否上次被松驰过，因为只有上一次被松弛过的结点才会对下一轮循环产生影响</span><br>queue&lt;int&gt; q;<br><br><span class="hljs-keyword">while</span>(!q.empty())&#123;<br>    int u = q.front();<br>    q.pop();<br>    visit[u] = <span class="hljs-literal">false</span>;<br>    edge *current = G[u].head;<br>    <span class="hljs-keyword">while</span>(current)&#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(dis[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] &gt; dis[u] + current-&gt;</span>weight)&#123;<br>            <span class="hljs-function"><span class="hljs-title">dis</span>[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] = dis[u] + current-&gt;</span>weight;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!visit[current-&gt;</span>end])&#123;<br>                <span class="hljs-function"><span class="hljs-title">visit</span>[current-&gt;</span>end] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-function"><span class="hljs-title">q</span>.push(current-&gt;</span>end);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">current</span> = current-&gt;</span>next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续观察，还可以发现，如果松驰后的顶点的dis越小，那么对后续产生的影响越大，可以往前放，于是我们首先想到是否可以用pq解决</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">dis[s] = <span class="hljs-number">0</span>;<br>priority_queue&lt;int&gt; q;<br>q.push(s);<br><span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>    int u = q.top();<br>    q.pop();<br>    visit[u] = <span class="hljs-literal">false</span>;<br>    edge *current = G[u].head;<br>    <span class="hljs-keyword">while</span> (current) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(dis[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] &gt; dis[u] + current-&gt;</span>weight) &#123;<br>            <span class="hljs-function"><span class="hljs-title">dis</span>[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] = dis[u] + current-&gt;</span>weight;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!visit[current-&gt;</span>end]) &#123;<br>                <span class="hljs-function"><span class="hljs-title">q</span>.push(current-&gt;</span>end);<br>                <span class="hljs-function"><span class="hljs-title">visit</span>[current-&gt;</span>end] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">current</span> = current-&gt;</span>next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>确实优化了，但依然被助教卡了，主要还是因为pq凭空多了调整的logN级复杂度，那么还能怎么优化呢？</p><p>男明星：deque！双端队列使插入删除变为O(1)的复杂度，很好了🥰</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xl">dis[s] = <span class="hljs-number">0</span>;<br>deque&lt;int&gt; q;<br>q.push_front(s);<br><span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>    int u = q.front();<br>    q.pop_front();<br>    visit[u] = <span class="hljs-literal">false</span>;<br>    edge *current = G[u].head;<br>    <span class="hljs-keyword">while</span> (current) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(dis[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] &gt; dis[u] + current-&gt;</span>weight) &#123;<br>            <span class="hljs-function"><span class="hljs-title">dis</span>[current-&gt;</span><span class="hljs-function"><span class="hljs-title">end</span>] = dis[u] + current-&gt;</span>weight;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(!visit[current-&gt;</span>end]) &#123;<br>                <span class="hljs-function"><span class="hljs-title">visit</span>[current-&gt;</span>end] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-function"><span class="hljs-title">if</span>(!q.empty() &amp;&amp; dis[current-&gt;</span>end] &lt; dis[q.front()])&#123;<br>                    <span class="hljs-function"><span class="hljs-title">q</span>.push_front(current-&gt;</span>end);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-function"><span class="hljs-title">q</span>.push_back(current-&gt;</span>end);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">current</span> = current-&gt;</span>next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也就是传说中的 SPFA + SLF优化！妙啊！（使我不用写Dijkstra + 连通分量的正解了XD）</p><h3 id="Floyd-算法">Floyd 算法</h3><p><strong>用于多元最短路问题</strong>（求任意两个结点之间最短路）<br>复杂度较高但常数小</p><p>类似BF的dp思路，维护一个三维数组 d[k,u,v]，表示只允许经过 1-k 的顶点，结点u到结点v 的最短路长度</p><p>状态转移方程为：<br>d[k,u,v] = min{d[k-1,u,v], d[k-1,u,k] + d[k-1,k,v]}</p><p><strong>从 u 到 v 经过 k 或者不经过 k</strong></p><p>代码实现：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for(int k = 1;k &lt;= n;k ++)&#123;<br>    for(int u = 1;u &lt;= n;u ++)&#123;<br>        for(int v = 1;v &lt;= n;v ++)&#123;<br>            f<span class="hljs-comment">[k]</span><span class="hljs-comment">[u]</span><span class="hljs-comment">[v]</span> = min(f<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[u]</span><span class="hljs-comment">[v]</span>,f<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[u]</span><span class="hljs-comment">[k]</span> + f<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[k]</span><span class="hljs-comment">[v]</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题">例题</h3><p>贴个题: <a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1196">裂点</a></p><p>省流：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> 个点 m 条有向边，边有正边权，可以免费走 k 条边，边权视为 <span class="hljs-number">0</span>，求 s 到 <span class="hljs-built_in">t</span> 的最短路<br></code></pre></td></tr></table></figure><p>想法：<br>点集取为(v,f)，f 为免费次数</p><p>则(u,f) -&gt; (v,f) 边权w<br>(u,f) -&gt; (v,f - 1) 0</p><p>用Dijkstra即可</p><h2 id="连通分量">连通分量</h2><h3 id="Concept-Recall">Concept Recall</h3><ul><li>连通性是二元等价关系（自反性、对称性、传递性）</li><li>有向图中，弱连通：转向无向图后连通；<br>强连通：任意两点间相互可达</li><li>强连通分量（SCC）是等价类，将点集划分成若干个内部强连通的部分</li></ul><h3 id="强连通分量算法">强连通分量算法</h3><hr><h3 id="Kosaraju-算法">Kosaraju 算法</h3><ul><li>从任意结点开始对有向图进行深度优先搜索，得到一个深度优先森林</li><li>将节点遍历：按照生成树的次序 + 对每一棵树上的节点进行后序遍历</li><li>将图 G 逆向得到Gr</li><li>从编号最大的节点开始深度优先搜索，得到的森林就是原图的强联通分量。</li></ul><p>代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;vector&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>struct edge &#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct ver &#123;<br>    edge *head;<br>&#125;;<br>ver G1[<span class="hljs-number">25005</span>];//正向图<br>ver G2[<span class="hljs-number">25005</span>];//反图<br><span class="hljs-type">void</span> add_edge1(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> c) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = c;<br>    <span class="hljs-keyword">current</span>-&gt;next = G1[u].head;<br>    G1[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">void</span> add_edge2(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> c) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = c;<br>    <span class="hljs-keyword">current</span>-&gt;next = G2[u].head;<br>    G2[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">bool</span> visit[<span class="hljs-number">25005</span>];<br><span class="hljs-type">bool</span> colored[<span class="hljs-number">25005</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-type">int</span> SCCcnt;<br><span class="hljs-type">void</span> dfs1(<span class="hljs-type">int</span> u)&#123;<br>    visit[u] = <span class="hljs-keyword">true</span>;<br>    edge *<span class="hljs-keyword">current</span> = G1[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!visit[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            dfs1(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    s.push_back(u);<br>&#125;<br><span class="hljs-type">void</span> dfs2(<span class="hljs-type">int</span> u)&#123;<br>    colored[u] = SCCcnt;<br>    edge *<span class="hljs-keyword">current</span> = G2[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!colored[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            dfs2(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> main()&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++)&#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        add_edge1(u,v,w);<br>        add_edge2(v,u,w);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!visit[i])&#123;<br>            dfs1(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i <span class="hljs-comment">--)&#123;</span><br>        //从栈顶开始向前回溯<br>        <span class="hljs-keyword">if</span>(!colored[s[i]])&#123; //还未被分配到任何SCC中<br>            ++ SCCcnt;<br>            dfs2(s[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Tarjan-算法">Tarjan 算法</h3><p>在DFS过程中，按照生成的顺序会生成一颗结构良好的DFS树。DFS得到的序列（DFS序并不能保证相邻节点一定有边相连），但是DFS树的节点一定都是图中的节点，换句话说，DFS树在本质上就是一个在中序遍历上完全等价的树。<br><img src="/img/DFS%E6%A0%91.png" alt="DFS Tree"></p><p>但是很显然，一颗DFS树上的顶点不代表联通。我们需要考虑不在DFS树上的边，例如这里的：</p><ul><li>反向边</li><li>前向边</li><li>交叉边（横向边）</li></ul><p><strong>Lemma: SCC 中 dfn 最小的结点是该 SCC 中所有节点在 DFS 树上的祖先（也就是所谓最远能到达的祖先）</strong></p><h4 id="Tarjan-算法实现">Tarjan 算法实现</h4><p>用一个栈表示没有全部访问的 SCC<br>记录 DFS 序 dfn[v] 和最远能走到的栈中节点 low[v]<br>要求：从 v 到 low[v] 的路径中最多一条非树边</p><p><img src="/img/Tarjan%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt="Tarjan 实现"></p><p>一个点的所有边访问结束之后，若 dfn[v ] = low[v ] ，则 v 及其子树的一部分构成一个 SCC<br><strong>Lemma: dfn[v] = low[v] 的点是其所在 SCC 中 dfn 最小的点</strong><br>若不是，则 v 到达之要经过非树边，v 必然能通过仅一条非树边到达dfn更小的点</p><p>Tarjan算法的原理是笔者学过所有算法中最恶心最绕的😅，但它的实现还是挺容易的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> dfn[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> low[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> dfnCnt;<br><span class="hljs-type">int</span> Stack[<span class="hljs-number">200005</span>];//一个栈，用于跟踪当前正在进行 DFS 遍历的路径上的节点。节点在被发现时入栈，在找到一个强连通分量时出栈<br><span class="hljs-type">bool</span> inStack[<span class="hljs-number">200005</span>];//是否在栈中<br><span class="hljs-type">int</span> top;//栈顶指针<br><span class="hljs-type">int</span> scc[<span class="hljs-number">200005</span>];//结点i所在强连通分量编号<br><span class="hljs-type">int</span> sccCnt;//强连通分量个数计数器<br><span class="hljs-type">int</span> sz[<span class="hljs-number">200005</span>];//强连通大小<br><br><span class="hljs-type">void</span> Tarjan(<span class="hljs-type">int</span> u)&#123;<br>    low[u] = dfn[u] = ++dfnCnt;<br>    Stack[++ top] = u;<br>    inStack[u] = <span class="hljs-keyword">true</span>;<br>    edge *<span class="hljs-keyword">current</span> = G[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            Tarjan(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>            low[u] = min(low[u],low[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inStack[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>])&#123;<br>            low[u] = min(low[u],dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u] == low[u])&#123;<br>        //找到SCC祖先结点<br>        ++sccCnt;<br>        <span class="hljs-keyword">do</span>&#123;<br>            scc[STACK[top]] = sccCnt;<br>            sz[sccCnt] ++;<br>            inStack[Stack[top]] = <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">while</span>(Stack[top <span class="hljs-comment">--] != u);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!dfn[i])&#123;<br>            Tarjan(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一道很棒的Tarjan例题（算是自己做出来的一道蓝题吧）">一道很棒的Tarjan例题（算是自己做出来的一道蓝题吧）</h4><p>老规矩，贴题，<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1197">ATM</a></p><p>相当综合的一题，把笔者今天学的近乎所有图算法都用了一遍🤣🤣🤣<br>想法是缩点，也就是求所有强连通分量（Tarjan板子），看成一张新的图（此图是DAG），于是使用SPFA求最长路径。特别要注意的是，不可以用Dijkstra，因为贪心的思想放在最长的情况下并不正确！！！（笔者在AC后尝试用Dijkstra WA 了2个点）</p><p>贴个AC代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;queue&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> s,p;<br><span class="hljs-type">int</span> sccCnt;<br><span class="hljs-type">int</span> SCC[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> Stack[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> top;<br><span class="hljs-type">int</span> dfn[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> dfnCnt;<br><span class="hljs-type">int</span> low[<span class="hljs-number">500005</span>];<br><span class="hljs-type">bool</span> inStack[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> <span class="hljs-type">Money</span>[<span class="hljs-number">500005</span>];//每个路口的钱<br><span class="hljs-type">int</span> sccMoney[<span class="hljs-number">500005</span>];//每个强连通分量中抢到钱的总数<br><span class="hljs-type">bool</span> sccPub[<span class="hljs-number">500005</span>];//每个强连通分量中是否有pub<br><span class="hljs-type">bool</span> pub[<span class="hljs-number">500005</span>];//酒吧位置<br>struct edge &#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>&#125;;<br>struct ver &#123;<br>    edge *head;<br>&#125;;<br>ver G[<span class="hljs-number">500005</span>];<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;next = G[u].head;<br>    G[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">void</span> tarjan(<span class="hljs-type">int</span> u) &#123;<br>    low[u] = dfn[u] = ++dfnCnt;<br>    inStack[u] = <span class="hljs-keyword">true</span>;<br>    Stack[++top] = u;<br>    edge *<span class="hljs-keyword">current</span> = G[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>            tarjan(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>            low[u] = min(low[u],low[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inStack[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>            low[u] = min(low[u],dfn[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u] == low[u]) &#123;<br>        ++sccCnt;<br>        <span class="hljs-keyword">do</span> &#123;<br>            inStack[Stack[top]] = <span class="hljs-keyword">false</span>;<br>            SCC[Stack[top]] = sccCnt;<br>            sccMoney[sccCnt] += <span class="hljs-type">Money</span>[Stack[top]];<br>            <span class="hljs-keyword">if</span>(pub[Stack[top]]) &#123;<br>                sccPub[sccCnt] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (Stack[top <span class="hljs-comment">--] != u);</span><br>    &#125;<br>&#125;<br>ver newG[<span class="hljs-number">500005</span>];<br><span class="hljs-type">void</span> add_edgeNEW(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;next = newG[u].head;<br>    newG[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> dis[<span class="hljs-number">500005</span>];<br><span class="hljs-type">bool</span> visit[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        <span class="hljs-type">int</span> u,v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        add_edge(u,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; <span class="hljs-type">Money</span>[i];<br>    &#125;<br>    cin &gt;&gt; s &gt;&gt; p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= p;i ++) &#123;<br>        <span class="hljs-type">int</span> pos;<br>        cin &gt;&gt; pos;<br>        pub[pos] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(!dfn[i]) &#123;<br>            tarjan(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        edge *<span class="hljs-keyword">current</span> = G[i].head;<br>        <span class="hljs-type">int</span> nCurrent = SCC[i];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>) &#123;<br>            <span class="hljs-type">int</span> nEnd = SCC[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>];<br>            <span class="hljs-keyword">if</span>(nEnd != nCurrent)&#123;<br>                add_edgeNEW(nCurrent,nEnd);<br>            &#125;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> start = SCC[s];//起始强连通分量<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.push(<span class="hljs-keyword">start</span>);<br>    dis[<span class="hljs-keyword">start</span>] = sccMoney[<span class="hljs-keyword">start</span>];<br>    <span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>        <span class="hljs-type">int</span> top = q.front();<br>        q.pop();<br>        visit[top] = <span class="hljs-keyword">false</span>;<br>        edge *<span class="hljs-keyword">current</span> = newG[top].head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span>) &#123;<br>            <span class="hljs-keyword">if</span>(dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] &lt; dis[top] + sccMoney[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>                dis[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = dis[top] + sccMoney[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!visit[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>]) &#123;<br>                visit[<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>] = <span class="hljs-keyword">true</span>;<br>                q.push(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>);<br>            &#125;<br>            <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> MaxMoney = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= sccCnt;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(sccPub[i]) &#123;<br>            <span class="hljs-keyword">if</span>(dis[i] &gt; MaxMoney) &#123;<br>                MaxMoney = dis[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; MaxMoney;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><p>Thanks so much:</p><ul><li>Alan Liang &amp; baihua’s slides</li><li><a href="https://xiyuanyang-code.github.io/posts/DataStructure-Graph-SCC/">Xiyuan Yang’s SCC Notes</a></li></ul><h2 id="Final-Words">Final Words</h2><p>做完了最后一次小作业的最后一题，再加上周四已经通过的火车票管理系统，数据结构CS1951 的所有课程内容都基本完成了（还有个机考😭）。感觉一学期下来代码能力得到了不小的提升（虽然这学期好像也没写什么代码🤣）。有一点怅然若失，每天写学算法、写小作业、debug大作业的日子就这样过去了，但想到未来还会学更多有趣的东西，又觉得很兴奋。或许一年前的我，还在为差一点点就能去清北，而质疑自己的选择，但我想我不会后悔我做的每一个决定。也有人问我家那么富为什么要来学cs😅，但我对钱真的不感兴趣呢。一直认为自己物欲很低（室友锐评：清心寡欲），没什么特别想要的，花钱很少，觉得钱没那么重要，也不想靠父母活一辈子（如果我这么选，我甚至不用上大学😅）。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Bellman Ford</tag>
      
      <tag>Floyd</tag>
      
      <tag>SPFA</tag>
      
      <tag>SLF</tag>
      
      <tag>Tarjan</tag>
      
      <tag>Kosaraju</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Theories and Decidability</title>
    <link href="/2025/05/18/Mathematical-Logic12/"/>
    <url>/2025/05/18/Mathematical-Logic12/</url>
    
    <content type="html"><![CDATA[<h1 id="theories-and-decidability"><a class="markdownIt-Anchor" href="#theories-and-decidability"></a> Theories and Decidability</h1><h2 id="recall-the-4-questions-were-gonna-answer"><a class="markdownIt-Anchor" href="#recall-the-4-questions-were-gonna-answer"></a> Recall The 4 Questions we’re gonna answer.</h2><p>Q1: What is a mathematical proof?<br />Q2: What makes a proof correct?<br />Q3: <strong>Is there a boundary of provability?</strong><br />Q4: Can computers find proofs?</p><p>We’ve already answer Q1 Q2 &amp; Q4.</p><p>Now we’re going to answer Q3.</p><h2 id="theories"><a class="markdownIt-Anchor" href="#theories"></a> Theories</h2><p>First, give the definition.</p><p><img src="/img/Theory.png" alt="Theory" /></p><p>我们还可以定义T 的逻辑闭包：<br /><img src="/img/%E9%80%BB%E8%BE%91%E9%97%AD%E5%8C%85.png" alt="逻辑闭包" /></p><p>同样我们还可以知道以下3个命题是等价的<br /><img src="/img/%E7%AD%89%E4%BB%B7%E5%91%BD%E9%A2%98.png" alt="" /></p><p>几个证明的关键点在：</p><ul><li>T <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span>  T⊨ (取任意φ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> T；假设模型M 使得 M ⊨ T，则M ⊨ φ，故T ⊨ φ；所以有φ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> T⊨)</li><li>取模型M，如果M ⊨ T，可以取一个M无法满足的句子ψ，则ψ 不是T 的逻辑推论，则ψ 不属于T⊨</li><li>T⊨是封闭的，因为对所有的ψ，如果(T⊨) ⊨ ψ，则T ⊨ ψ，则 ψ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> T⊨</li><li>空真：如果 T 不可满足，且T ⊨ φ，则φ可取任意L^S中公式</li><li>假设 T⊨ 不可满足，则 (T⊨)⊨ = L^S</li></ul><h2 id="peano-arithmetic"><a class="markdownIt-Anchor" href="#peano-arithmetic"></a> Peano Arithmetic</h2><p><strong>φPA</strong><br /><img src="/img/PA.png" alt="Definition Of PA" /></p><h2 id="elementary-arithmetic"><a class="markdownIt-Anchor" href="#elementary-arithmetic"></a> Elementary arithmetic</h2><p><img src="/img/%E5%88%9D%E7%AD%89%E7%AE%97%E6%9C%AF.png" alt="Definition of EA" /></p><p><strong>RMK:</strong><br />It’s easy to see that φPA <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> Th(N),we will show that φPA ⊊ Th(N)</p><h2 id="r-axiomatizable-可公理化"><a class="markdownIt-Anchor" href="#r-axiomatizable-可公理化"></a> R-axiomatizable 可公理化</h2><p><img src="/img/%E5%85%AC%E7%90%86%E5%8C%96.png" alt="Definition" /></p><h2 id="theorem-5"><a class="markdownIt-Anchor" href="#theorem-5"></a> Theorem 5</h2><p><strong>Every R-axiomatizable theory is R-enumerable.</strong></p><h2 id="complete-theory"><a class="markdownIt-Anchor" href="#complete-theory"></a> Complete Theory</h2><p><img src="/img/CT.png" alt="Complete Theory" /></p><h2 id="theorem-6"><a class="markdownIt-Anchor" href="#theorem-6"></a> Theorem 6</h2><p>(i) Every R-axiomatizable complete theory is R-decidable.<br />(ii) Every R-enumerable complete theory is R-decidable.</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proof of the Undecidabilty of FO</title>
    <link href="/2025/05/17/Mathematical-Logic11/"/>
    <url>/2025/05/17/Mathematical-Logic11/</url>
    
    <content type="html"><![CDATA[<h1>Mathematical Logic 11 Proof of the undecidability of FO</h1><h2 id="Undecidability-of-FO">Undecidability of FO</h2><p><img src="/img/FO.png" alt="Undecidability of FO"></p><h2 id="Basic-Thoughts-of-the-Proof">Basic Thoughts of the Proof</h2><p>We’ve already proved that Π halt is not R-decidable by using Π’halt ⩽m Π halt.</p><p><strong>So we only need to show that Π halt ⩽m FO</strong>.</p><p>i.e <strong>We have to construct a reduction.</strong></p><p>P: □ -&gt; halt  ⇔ |= φP</p><h2 id="Main-Target-Build-φP">Main Target: Build φP</h2><h2 id="Configuration-of-the-Register-Machine">Configuration of the Register Machine</h2><p>引入<strong>Configuration 格局</strong>的概念</p><p>我们定义一个(n + 2) 元组：<br>(L,m0,m1,…,mn)</p><p>L表示当前这一条指令，mi表示第i个寄存器中存储的字符串中 | 的个数（若A = {|}）</p><p>显然这样的(n + 2) 元组可以<strong>刻画程序的行为</strong></p><p>初始状态(0,0,…,0)</p><p>停机时状态(k,m0,m1,…,mn)</p><h2 id="Reduction-Overview-1-S-Structure">Reduction Overview 1 : S-Structure</h2><p>定义一种关系：<br>R^P := {(L,m0,m1,…,mn) | (0,0,…,0) -&gt; (L,m0,m1,…,mn)}</p><p><strong>程序可达格局</strong></p><p>So We need that:<br>1.定义一个公式 ψP decribes R^P<br>2.P: □ -&gt; halt  ⇔  (k,m0,m1,…,mn) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> R^P</p><p>所以可以建立如下的S-strcutre</p><p><img src="/img/BuildSStructure.png" alt="S-Structure"></p><h2 id="Reduction-Overview-2">Reduction Overview 2</h2><p>The desired ψP should satisfy the following two properties:、<br><img src="/img/TwoPro.png" alt="P1 &amp; P2"></p><p>Finally , we set:<br><img src="/img/varphi.png" alt="Construct φP"></p><h2 id="We-can-easily-proved-that-P-□-halt-⇔-φP">We can easily proved that P: □ -&gt; halt  ⇔ |= φP</h2><h2 id="The-Constructuction-of-ψP">The Constructuction of ψP</h2><p><img src="/img/Construct1.png" alt=""></p><p><img src="/img/Construct2.png" alt=""></p><p>是一个对指令类型的分类讨论</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA DS MST</title>
    <link href="/2025/05/11/AlgorithmOfDS4/"/>
    <url>/2025/05/11/AlgorithmOfDS4/</url>
    
    <content type="html"><![CDATA[<h1 id="lca-least-common-ancestors"><a class="markdownIt-Anchor" href="#lca-least-common-ancestors"></a> LCA ———— Least Common Ancestors</h1><hr /><h2 id="如何计算"><a class="markdownIt-Anchor" href="#如何计算"></a> 如何计算？</h2><ul><li>深度相同一起跳</li><li>深度不同，深度大的跳</li></ul><p>显然，一层一层跳复杂度将会来到O(N)</p><h2 id="空间换时间-一次多跨几步"><a class="markdownIt-Anchor" href="#空间换时间-一次多跨几步"></a> 空间换时间 一次多跨几步</h2><p>联系：<a href="https://janezair.site/2025/04/05/AlgorithmOfDS2/#sparse-table-st%E8%A1%A8">ST表</a><br />考虑保存<strong>2 的幂次级 祖先</strong></p><p>于是我们有了一种很棒的<strong>倍增</strong>做法：</p><ol><li>假设 y 比 x 深，则 y 需要向上跳 a = h(y) - h(x)</li><li>对 a 进行二进制拆分</li><li>令 f[x][i]为结点 x 的 2^i级祖先，则状态转移方程为：f[x][i] = f[f[x][i-1]][i-1]</li></ol><p>也就是说，我们可以进行一个ST表的预处理：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(int j <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;j &lt;= 20;j ++)&#123;</span><br>    for(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;i &lt;= n;i ++)&#123;</span><br>        f[i][j] <span class="hljs-operator">=</span> f[f[i][j-<span class="hljs-number">1</span>]][j-<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度是O(NlogN)的</p><h2 id="深度相同一起跳"><a class="markdownIt-Anchor" href="#深度相同一起跳"></a> 深度相同一起跳</h2><p>问题在于：深度差未知<br />不能跳过头，但也不想太保守（一点一点往上挪），争取跳出<strong>能跳的 最大的步子</strong></p><p>So:以 2 的幂次从大往小尝试</p><ul><li>每次跳都确保跳到的点不相同</li><li>步长递减到2^0 为止，返回最后点的父亲节点</li></ul><h2 id="lca-代码实现"><a class="markdownIt-Anchor" href="#lca-代码实现"></a> LCA 代码实现</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int lca(int x,int y)&#123;<br>    if(dp<span class="hljs-comment">[x]</span> &lt; dp<span class="hljs-comment">[y]</span>)&#123;<br>        swap(x,y);<br>    &#125;<br>    for(int j = 19;j &gt;= 0;j --)&#123;<br>        if(dp<span class="hljs-comment">[f<span class="hljs-comment">[x]</span><span class="hljs-comment">[i]</span>]</span> &gt;= dp<span class="hljs-comment">[y]</span>)&#123;<br>            x = f<span class="hljs-comment">[x]</span><span class="hljs-comment">[i]</span>;<br>        &#125;<br>    &#125;<br>    if(x == y)&#123;<br>        return x;<br>    &#125;<br>    for(int j = 19;j &gt;= 0;j --)&#123;<br>        if(dp<span class="hljs-comment">[f<span class="hljs-comment">[x]</span><span class="hljs-comment">[j]</span>]</span> != dp<span class="hljs-comment">[f<span class="hljs-comment">[y]</span><span class="hljs-comment">[j]</span>]</span>)&#123;<br>            x = f<span class="hljs-comment">[x]</span><span class="hljs-comment">[j]</span>;<br>            y = f<span class="hljs-comment">[y]</span><span class="hljs-comment">[j]</span>;<br>        &#125;<br>    &#125;<br>    return f<span class="hljs-comment">[x]</span><span class="hljs-comment">[0]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用树上差分"><a class="markdownIt-Anchor" href="#应用树上差分"></a> 应用：树上差分</h2><p>给定一棵树 n 个节点，有 m 次操作，每次操作给出 u，v 两个节点，将 u-v 路径上的所有点权值 +1。之后查询每个点的点权。</p><p>想法：联系<a href="https://janezair.site/2025/04/05/AlgorithmOfDS2/#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%92%8C%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">树状数组区间修改</a></p><p><strong>差分树上节点加 1 ，代表从根节点到该节点的路径上的节点都加 1</strong></p><h2 id="经典例子清理蜘蛛网"><a class="markdownIt-Anchor" href="#经典例子清理蜘蛛网"></a> 经典例子：清理蜘蛛网</h2><p>放个题：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2193">清理蜘蛛网 ACMOJ</a><br />想法一个是图的存储，我一开始试图用树存储，发现整个存储结构一片混乱。无奈最后投向邻接表（注意必须是邻接表而不是邻接矩阵，不然你将无法过编）<br />还有树上差分（边的差分），更新起点终点（++）和lca点（-= 2）<br />以及前缀和的计算，result[u] = diff[u] + sum(children diff[sn])<br />还有体现附加边的作用，<strong>骨架边断开的机会</strong>分类讨论。<br />总结：一道很难想也不太好写的题，主播写了至少1个多小时（还是在有思路的情况下）</p><p>贴个AC代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;cmath&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br>struct edge &#123;<br>    edge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>&#125;;<br>struct ver &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">value</span>;<br>    edge *head;<br>&#125;;<br>ver g[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> fa[<span class="hljs-number">100005</span>][<span class="hljs-number">21</span>];<br><span class="hljs-type">int</span> diff[<span class="hljs-number">100005</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100005</span>];<br><span class="hljs-type">void</span> addEdge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    edge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> edge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;next = g[u].head;<br>    g[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> f,<span class="hljs-type">int</span> h) &#123;<br>    fa[sn][<span class="hljs-number">0</span>] = f;<br>    dp[sn] = h;<br>    edge *e = g[sn].head;<br>    <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(e-&gt;<span class="hljs-keyword">end</span> != f) &#123;<br>            dfs(e-&gt;<span class="hljs-keyword">end</span>,sn,h + <span class="hljs-number">1</span>);<br>        &#125;<br>        e = e-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> lca(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-keyword">if</span>(dp[x] &lt; dp[y]) &#123;<br>        swap(x,y);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">19</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(dp[fa[x][j]] &gt;= dp[y]) &#123;<br>            x = fa[x][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x == y) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">19</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(fa[x][j] != fa[y][j]) &#123;<br>            x = fa[x][j];<br>            y = fa[y][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-type">void</span> calculate(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> fa) &#123;<br>    edge *e = g[sn].head;<br>    <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(e-&gt;<span class="hljs-keyword">end</span> != fa) &#123;<br>            calculate(e-&gt;<span class="hljs-keyword">end</span>,sn);<br>            diff[sn] += diff[e-&gt;<span class="hljs-keyword">end</span>];<br>        &#125;<br>        e = e-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> u,v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        g[i].head = nullptr;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        addEdge(u,v);<br>        addEdge(v,u);<br>    &#125;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">20</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>            fa[i][j] = fa[fa[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">int</span> LCA = lca(a,b);<br>        diff[a] ++;<br>        diff[b] ++;<br>        diff[LCA] -= <span class="hljs-number">2</span>;<br>    &#125;<br>    calculate(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    long long <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(diff[i] == <span class="hljs-number">0</span>) &#123;<br>            total += m;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff[i] == <span class="hljs-number">1</span>) &#123;<br>            total ++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; total;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        edge *e = g[i].head;<br>        edge *tmp;<br>        <span class="hljs-keyword">while</span>(e != nullptr) &#123;<br>            tmp = e;<br>            e = e-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><hr /><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>并查集是一种用于管理元素所属集合的数据结构。实现为一个<strong>森林</strong>，其中<strong>每棵树表示一个集合</strong>，树中的节点表示对应集合中的元素。</p><h2 id="2种基本操作"><a class="markdownIt-Anchor" href="#2种基本操作"></a> 2种基本操作</h2><h3 id="union-合并"><a class="markdownIt-Anchor" href="#union-合并"></a> Union 合并</h3><p>合并两个元素所属集合（合并对应的树）</p><h3 id="find-查询"><a class="markdownIt-Anchor" href="#find-查询"></a> Find 查询</h3><p>用于判断 2 个元素是否属于一个集合</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p><strong>父亲存储法</strong>：只需要一个数组 f 存储每个节点的父亲即可。</p><p><strong>查询</strong>：只要沿着树找到a, b所在树的根节点fa, fb，若fa, fb相等则两个节点在同一个集合中</p><p><strong>合并</strong>：先沿着树找到a, b所在树的根节点fa, fb，再令f[fa] = fb, 将两树合并</p><h2 id="并查集优化"><a class="markdownIt-Anchor" href="#并查集优化"></a> 并查集优化</h2><h3 id="降低树高"><a class="markdownIt-Anchor" href="#降低树高"></a> 降低树高</h3><h3 id="查询中的路径压缩"><a class="markdownIt-Anchor" href="#查询中的路径压缩"></a> 查询中的路径压缩</h3><p>查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。<br /><strong>在从x到根结点的路径上的每一个结点都将自己的父结点改为根结点。</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gml">int find(<span class="hljs-variable language_">x</span>)&#123;<br>    <span class="hljs-keyword">if</span>(parent[<span class="hljs-variable language_">x</span>] != <span class="hljs-variable language_">x</span>)&#123;<br>        parent[<span class="hljs-variable language_">x</span>] = find(parent[<span class="hljs-variable language_">x</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[<span class="hljs-variable language_">x</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启发式合并"><a class="markdownIt-Anchor" href="#启发式合并"></a> 启发式合并</h3><p>我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> unite(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)&#123;<br>    <span class="hljs-keyword">int</span> rootX = <span class="hljs-keyword">find</span>(x);<br>    <span class="hljs-keyword">int</span> rootY = <span class="hljs-keyword">find</span>(y);<br><br>    <span class="hljs-keyword">if</span>(rootX == rootY)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">size</span>[rootX] &lt; <span class="hljs-keyword">size</span>[rootY])&#123;<br>        parent[rootX] = rootY;<br>        <span class="hljs-keyword">size</span>[rootY] += <span class="hljs-keyword">size</span>[rootX];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        parent[rootY] = rootX;<br>        <span class="hljs-keyword">size</span>[rootX] += <span class="hljs-keyword">size</span>[rootY];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="生成树"><a class="markdownIt-Anchor" href="#生成树"></a> 生成树</h1><p>连通图 G 的生成树（Spanning Tree）是包含G的所有节点的树。</p><p>在有权图中，**最小生成树（MST）**是指总权值最小的一棵生成树。</p><p><strong>切割性质</strong>：假设将图中的顶点划分为两个互不相交的集合，那么连接这两个集合的所有边中，权重最小的边一定属于某棵最小生成树。</p><h2 id="kruskal-算法求解mst-较为常用"><a class="markdownIt-Anchor" href="#kruskal-算法求解mst-较为常用"></a> Kruskal 算法——求解MST  （较为常用）</h2><p>Core:<strong>对边排序，每次取出权值最小的边尝试加入，如果不成环则加入，直到全图连通。</strong></p><h2 id="prim-算法求解mst"><a class="markdownIt-Anchor" href="#prim-算法求解mst"></a> Prim 算法——求解MST</h2><p><strong>从任意一个点开始，选距离集合最近的节点加入集合，直到全图连通</strong></p><h1 id="综合dsmst和lca"><a class="markdownIt-Anchor" href="#综合dsmst和lca"></a> 综合DS,MST和LCA</h1><p>老规矩先贴题：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1898">货车运输</a><br />此题lz开始的想法是Floyd暴力dp，显然会炸。后来打算暴搜，显然也会炸。无奈只得点开luogu题解，发现是蓝题🤡<br />个人觉得最妙的是想到使用最大生成树，把较小的边删掉，在得到的最大生成树上（Kruskal得树，邻接表dfs建树）进行LCA操作，得到LCA后相当于求解出了唯一的一条路径，在遍历这条路径求个最小值就好了<br />另外lz总觉得最后的遍历有点儿暴力，感觉可以多维护一些东西，让查询复杂度来到O(1)？没仔细想，以为会T，结果居然1Y飘过了🤣<br />贴个代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> parent[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> Size[<span class="hljs-number">10005</span>];<br>struct edge &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br><span class="hljs-type">void</span> merge(const edge *aBegin, const edge *aEnd, const edge *bBegin,<br>           const edge *bEnd, edge *c) &#123;<br>    <span class="hljs-keyword">while</span> (aBegin != aEnd &amp;&amp; bBegin != bEnd) &#123;<br>        <span class="hljs-keyword">if</span> (bBegin-&gt;weight &gt; aBegin-&gt;weight) &#123;<br>            *c = *bBegin;<br>            ++bBegin;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            *c = *aBegin;<br>            ++aBegin;<br>        &#125;<br>        ++c;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; aBegin != aEnd; ++aBegin, ++c) *c = *aBegin;<br>    <span class="hljs-keyword">for</span> (; bBegin != bEnd; ++bBegin, ++c) *c = *bBegin;<br>&#125;<br><span class="hljs-type">void</span> merge_sort(edge *a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>    <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>    merge_sort(a, l, mid), merge_sort(a, mid, r);<br>    edge* tmp = <span class="hljs-built_in">new</span> edge[r - l + <span class="hljs-number">1</span>];<br>    merge(a + l, a + mid, a + mid, a + r, tmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; r; ++i) a[i] = tmp[i - l];<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br><span class="hljs-type">int</span> find(<span class="hljs-type">int</span> u) &#123;<br>    <span class="hljs-keyword">if</span>(parent[u] != u) &#123;<br>        parent[u] = find(parent[u]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[u];<br>&#125;<br><span class="hljs-type">void</span> unite(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<br>    <span class="hljs-type">int</span> rootX = find(x);<br>    <span class="hljs-type">int</span> rootY = find(y);<br>    <span class="hljs-keyword">if</span>(rootX != rootY) &#123;<br>        <span class="hljs-keyword">if</span>(Size[rootX] &gt; Size[rootY]) &#123;<br>            parent[rootY] = rootX;<br>            Size[rootX] += Size[rootY];<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            parent[rootX] = rootY;<br>            Size[rootY] += Size[rootX];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> u,v,w;<br>edge Graph[<span class="hljs-number">50005</span>];<br>edge MST[<span class="hljs-number">10005</span>];<br>struct adjEdge &#123;<br>    adjEdge *next;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br>struct adjVer &#123;<br>    adjEdge *head;<br>&#125;;<br>adjVer adjMST[<span class="hljs-number">10005</span>];//最大生成树邻接表<br><span class="hljs-type">void</span> add_edge(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w) &#123;<br>    adjEdge *<span class="hljs-keyword">current</span> = <span class="hljs-built_in">new</span> adjEdge;<br>    <span class="hljs-keyword">current</span>-&gt;end = v;<br>    <span class="hljs-keyword">current</span>-&gt;weight = w;<br>    <span class="hljs-keyword">current</span>-&gt;next = adjMST[u].head;<br>    adjMST[u].head = <span class="hljs-keyword">current</span>;<br>&#125;<br><span class="hljs-type">int</span> fa[<span class="hljs-number">10005</span>][<span class="hljs-number">21</span>];<br><span class="hljs-type">int</span> depth[<span class="hljs-number">10005</span>];<br><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> sn,<span class="hljs-type">int</span> f,<span class="hljs-type">int</span> h) &#123;<br>    fa[sn][<span class="hljs-number">0</span>] = f;<br>    depth[sn] = h;<br>    adjEdge *<span class="hljs-keyword">current</span> = adjMST[sn].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span> != f) &#123;<br>            dfs(<span class="hljs-keyword">current</span>-&gt;<span class="hljs-keyword">end</span>,sn,h + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> lca(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-keyword">if</span>(depth[u] &lt; depth[v]) &#123;<br>        swap(u,v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">20</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(depth[fa[u][j]] &gt;= depth[v]) &#123;<br>            u = fa[u][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(u == v) &#123;<br>        <span class="hljs-keyword">return</span> u;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">20</span>;j &gt;= <span class="hljs-number">0</span>;j <span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">if</span>(fa[u][j] != fa[v][j]) &#123;<br>            u = fa[u][j];<br>            v = fa[v][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-type">int</span> findVal(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v) &#123;<br>    adjEdge *<span class="hljs-keyword">current</span> = adjMST[u].head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">current</span> != nullptr) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;end == v) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span>-&gt;weight;<br>        &#125;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> getMin(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> lca) &#123;<br>    <span class="hljs-type">int</span> Min = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span>(u != lca) &#123;<br>        <span class="hljs-type">int</span> v = findVal(u,fa[u][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span>(v &lt; Min) &#123;<br>            Min = v;<br>        &#125;<br>        u = fa[u][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> Min;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        parent[i] = i;<br>        Size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        Graph[i].start = u;<br>        Graph[i].end = v;<br>        Graph[i].weight = w;<br>    &#125;<br>    merge_sort(Graph,<span class="hljs-number">1</span>,m + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        <span class="hljs-type">int</span> rst = find(Graph[i].<span class="hljs-keyword">start</span>);<br>        <span class="hljs-type">int</span> rnd = find(Graph[i].<span class="hljs-keyword">end</span>);<br>        <span class="hljs-keyword">if</span>(rst != rnd) &#123;<br>            unite(rst,rnd);<br>            MST[++cnt] = Graph[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= cnt;i ++) &#123;<br>        add_edge(MST[i].<span class="hljs-keyword">start</span>,MST[i].<span class="hljs-keyword">end</span>,MST[i].weight);<br>        add_edge(MST[i].<span class="hljs-keyword">end</span>,MST[i].<span class="hljs-keyword">start</span>,MST[i].weight);<br>    &#125;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">20</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>            fa[i][j] = fa[fa[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    cin &gt;&gt; q;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= q;i ++) &#123;<br>        cin &gt;&gt; <span class="hljs-keyword">start</span> &gt;&gt; <span class="hljs-keyword">end</span>;<br>        <span class="hljs-keyword">if</span>(find(<span class="hljs-keyword">start</span>) != find(<span class="hljs-keyword">end</span>)) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> LCA = lca(<span class="hljs-keyword">start</span>,<span class="hljs-keyword">end</span>);<br>            cout &lt;&lt; min(getMin(<span class="hljs-keyword">start</span>,LCA),getMin(<span class="hljs-keyword">end</span>,LCA)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>LCA</tag>
      
      <tag>Disjoint Set</tag>
      
      <tag>MST</tag>
      
      <tag>Kruskal</tag>
      
      <tag>Prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic 10 Halting Problem</title>
    <link href="/2025/05/11/Mathematical-Logic10/"/>
    <url>/2025/05/11/Mathematical-Logic10/</url>
    
    <content type="html"><![CDATA[<h1>Mathematical Logic 10 Halting Problem</h1><hr><h2 id="R-computable">R-computable</h2><p>Let F: A* -&gt; B* (A,B are 2 alphabets)</p><p>(1)A program P computes F if for all w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A*, P: w-&gt;F(w)</p><p>(2)F is R-computable if there is a program which computes F.</p><hr><h2 id="Halting-Problem-for-the-register-machine">Halting Problem for the register machine</h2><hr><h2 id="Godel-numbering">Gödel numbering</h2><p>Def:<br>B:= A U {A,B,…,Z} U {0,1,…,9} U {=,+,-,|}.<br>Words in B* are ordered lexicographically(字典序).</p><p><strong>Encode</strong> each program as a word in B*<br>Example:<br>0LETR1 = R1 - a0|1PRINT|2HALT.</p><p>Assume that this word is the n-th word in the lexicographical ordering of B∗.Then we set:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">w_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">p</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0a_0...a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>(n times)</p><p>Π := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A }.</p><p>The mapping P-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is called <strong>Gödel numbering</strong>.<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is called the <strong>Gödel number</strong> of P.</p><p><strong>Π is R-decidable.</strong></p><h2 id="Π’halt-is-not-R-decidable">Π’halt is not R-decidable.</h2><p>Π’halt := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A and P:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>-&gt;halt}<br>PF:<br>Assume that P0 decides Π’halt<br>0 …<br>1 …<br>…<br>10 PRINT<br>…<br>k HALT</p><p>We can build a P1<br>0 …<br>1 …<br>…<br>10 IF R = □ THEN k ELSE k or k or k… or k<br>…<br>k IF R = □ THEN k ELSE k+1 or k+1 or k+1… or k+1<br>k+1 HALT</p><p>Clearly contradict!</p><h2 id="Πhalt-is-not-R-decidable">Πhalt is not R-decidable.</h2><p>Πhalt := { <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |P a program over A and P: □ -&gt;halt}</p><p>PF:<br>Build P+:<br>P : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> -&gt; halt  -&gt; P+ : □ -&gt; halt</p><p>A further program T:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> -&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>P</mi><mo>+</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{P+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p>With P0 and T we design a program which <strong>decides Π’halt</strong>. On any w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A∗:</p><ul><li>the program first test whether w = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">w_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> for some P.If not, it rejects immediately.</li><li>Otherwise, it uses T to computes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>P</mi><mo>+</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{P+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mbin">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>. Then the program calls P0 on input wP+.</li><li>It correctly decides whether P : wP -&gt; halt.</li></ul><hr><h2 id="The-undecidability-of-first-order-logic-see-u-next-time">The undecidability of first-order logic.(see u next time)</h2>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.006 Shortest Path Algorithm</title>
    <link href="/2025/05/09/Introduction-to-Algorithms4/"/>
    <url>/2025/05/09/Introduction-to-Algorithms4/</url>
    
    <content type="html"><![CDATA[<h1>MIT 6.006 4 Shortest Path Algorithm</h1><h2 id="Overview">Overview</h2><ul><li>Weighted Graph</li><li>General Approaches</li><li>Negative Edges</li><li>Optimal Substructure</li></ul><p>Mainly <strong>2 Algorithms</strong>：<br><strong>Dijkstra</strong> with O(V + E) for <strong>non-negative edge weights</strong><br><strong>Bellman Ford</strong> with O(EV) for <strong>general case</strong></p><h2 id="Weighted-Graph">Weighted Graph</h2><h3 id="Single-Source-Shortest-Paths">Single Source Shortest Paths</h3><p>Data Structure:<br>d[v] = value inside circles<br>= 0 (if v = s) or ∞ (otherwise)<br>= δ(s,v) (at the end)<br>with δ(s,v) &lt;= d[v] (all the times)</p><p>π[v] = predecessor on the best path to v</p><p><img src="/img/WGSP.png" alt="Example"></p><h2 id="Negative-Weight-Edges">Negative-Weight Edges</h2><p>You may get an endless loop like below:<br><img src="/img/NWG.png" alt="Example"></p><p>That’s a bad negative circle.</p><h2 id="General-Structure-Of-SP-Algorithm">General Structure Of SP Algorithm</h2><p><img src="/img/GCSP.png" alt="General Idea"></p><h2 id="Triangle-Inequality">Triangle Inequality</h2><p>Thm:<br>For all u,v,x <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> X, we have</p><p>δ(u,v) &lt;= δ(u,x) + δ(x,v)</p><p>You may use this idea in Floyd Algorithm.</p><h2 id="DAG-（Directed-Acyclic-Graph-有向无环图）">DAG （Directed Acyclic Graph 有向无环图）</h2><p>No cycles！</p><p>1.Topologically sort the DAG.<br>2.One pass over vertices in topologically sorted order relaxing each edge that<br>leaves each vertex.</p><p><img src="/img/DAG.png" alt="DAG Example"></p><p>using <strong>Dynamic Programming</strong> O(V + E)</p><h2 id="Dijkstra-Algorithm">Dijkstra Algorithm</h2><p><img src="/img/Dijkstra.png" alt="Dijkstra"></p><p>Core Idea:<br><strong>For each edge (u, v) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> E, assume w(u, v) ≥ 0, maintain a set S of vertices whose final shortest path weights have been determined. Repeatedly select u <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> V − S with minimum shortest path estimate, add u to S, relax all edges out of u.</strong></p><h3 id="Pseudo-code">Pseudo-code</h3><p><img src="/img/DijkstraCode.png" alt="Dijkstra Code"></p><h2 id="Dijkstra-Complexity-Analysis">Dijkstra Complexity Analysis</h2><p>V times : insert into pq<br>V times : extract min<br>E times : decrease key</p><h3 id="Array">Array</h3><p>V times : extract min<br>1 time  : decrease key</p><p>Total: O(V^2 + E)</p><h3 id="Binary-Min-Heap">Binary Min Heap</h3><p>lgV times: extract min<br>lgV times: decrease key</p><p>Total: O(VlgV + ElgV)</p><h3 id="Fibonacci-heap">Fibonacci heap</h3><p>lgV times: extract min<br>1 time  : decrease key</p><p>Total: O(VlogV + E)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Shortest Path</tag>
      
      <tag>Bellman Ford</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic9</title>
    <link href="/2025/05/06/Mathematical-Logic9/"/>
    <url>/2025/05/06/Mathematical-Logic9/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：终于和计算机相关了😭😭😭😭😭他真的，我哭死。好玩！但怀疑作业依然不会做。。。">Before：终于和计算机相关了😭😭😭😭😭他真的，我哭死。好玩！但怀疑作业依然不会做。。。</h4><h1>Mathematical Logic 9 Decidability and Enumerability</h1><h1>可判定性 和 可枚举性</h1><h2 id="Desicion-problems-判定问题">Desicion problems 判定问题</h2><p>判断给定输入是否满足特定性质</p><p>i.e<br>设 A* 是有限字母表上的字符串集合<br>input : w<br>满足某种性质 : w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*</p><p>判定问题的特征函数定义为：<br>f = 1 （w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W）<br>f = 0 （otherwise）</p><h2 id="Decidability-可判定性">Decidability 可判定性</h2><p>Def:<br>P 是对于性质W的<strong>一个判定程序（decision procedure for W）</strong>，如果：<br>对于每个输入w，P终会停机，且输出一些w’使得：</p><ul><li>如果 w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> W，则w’ 为空串</li><li>否则，w’不为空串</li></ul><p>我们称 W 是可判定的，如果存在这样的一个P</p><h2 id="Enumerability-可枚举性">Enumerability 可枚举性</h2><p>Def:<br>设A 是一个字母表，且 W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*.我们称P 是 W 的一个枚举程序，如果：<br>（在没有任何输入的情况下）P输出了W 中的所有单词（以某种顺序且可能重复）</p><p>我们称 W 是可枚举的，如果存在这样的一个P</p><h2 id="Lemma-about-Enumerability">Lemma about Enumerability</h2><h3 id="Lemma-9">Lemma 9</h3><p>如果W存在这样的一个枚举程序，那么 W 就一定存在一个没有重复的枚举程序</p><h3 id="Lemma-10">Lemma 10</h3><p>如果A 是有限的，那么A* 是可枚举的。</p><h2 id="Decidability-VS-Enumerability">Decidability VS Enumerability</h2><h3 id="Thm-11">Thm 11</h3><p>所有可判定的集合都是可枚举的。</p><h3 id="Thm-12">Thm 12</h3><p>设W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*. W 是可判定的当且仅当 W 和 A*\ W 是可枚举的。</p><h2 id="Q4：Can-computers-find-proofs？">Q4：Can computers find proofs？</h2><p><img src="/img/Turing.png" alt="Alan Turing"></p><p><strong>Undecidability of FO</strong></p><p><strong>any computer program cannot decide whether an arbitrary input mathematical statement has a proof</strong></p><h2 id="Register-Machine">Register Machine</h2><p>基本模型：<br>有限个寄存器R0,…,Rm,每个都可以存储字母表A 上的字符串。</p><p>一个程序由有限条指令组成，每一条都被标记为L <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> N</p><h2 id="Instruction-Type">Instruction Type</h2><ul><li><p>L LET R_i = R_i + a_j<br>It is to add aj at the end of the word in Ri.</p></li><li><p>L LET R_i = R_i - a_j<br>If the word w in Ri ends with aj, then delete this aj; otherwise leave w unchanged.</p></li><li><p>L if Ri = - then L′ else L0 or L1 or · · · or Lr<br>It is to jump to a new location according to the ending letter of the word in Ri.</p></li><li><p>L PRINT<br>It is to output the word in R0.</p></li><li><p>L HALT<br>It is to halt the program.</p></li></ul><h2 id="Register-Program">Register Program</h2><p>A program P starts with w <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> A* if in the beginning of the execution of P we have R0 = w and all other Ri are empty.</p><h2 id="R-Decidability">R-Decidability</h2><p>W is <strong>register-decidable, or R-decidable</strong> for short, if there is a register program which decides W.</p><h2 id="R-Enumerability">R-Enumerability</h2><p>W is <strong>register-enumerable, or R-enumerable</strong> for short, if there is a register program which enumerates W.</p><h2 id="Proposition-15">Proposition 15</h2><p>设W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">⊂</span></span></span></span> A*. W 是R-decidable 当且仅当 W 和 A*\ W 是R-enumerable的。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Segment Tree</title>
    <link href="/2025/04/20/AlgorithmOfDS3/"/>
    <url>/2025/04/20/AlgorithmOfDS3/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：Long-time-no-see！最近强度激增，B-树de了一整天，还有MLE和TLE，感觉是某个地方写爆栈了😢数理逻辑作业还没写完，下周还要复习数分。">Before：Long time no see！最近强度激增，B+树de了一整天，还有MLE和TLE，感觉是某个地方写爆栈了😢数理逻辑作业还没写完，下周还要复习数分。</h4><h4 id="upd：昨天晚上过了，打算51把管理系统速通了，挑点bonus写一下（其实想全写但显然没空），弥补一下bookstore啥bonus都没写的遗憾。希望周五数分顺利！">upd：昨天晚上过了，打算51把管理系统速通了，挑点bonus写一下（其实想全写但显然没空），弥补一下bookstore啥bonus都没写的遗憾。希望周五数分顺利！</h4><h1>Algorithm Of Data Structure —— Segment Tree</h1><h2 id="Definition">Definition</h2><ul><li>二叉树</li><li>每一个叶子节点维护原序列的信息</li><li>每个中间结点维护一段区间信息</li><li>通过子节点的高效信息合并得到中间节点的区间信息</li></ul><p>An example of Segment Tree:<br><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91.png" alt="Simple Segment Tree"></p><h2 id="Basic-Rules">Basic Rules</h2><ul><li>Apparently,线段树是一棵完全二叉树，故树高 h = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span></span></span></span></li><li>结点总数约为 2n，故O(n) = 2n</li><li>每个结点代表一个区间[l,r]，并维护该区间的信息，如区间内的数字和、最大(小)值等。该区间信息由两个分别代表[l, mid],[mid+1, r]的子结点合并而来。</li></ul><h2 id="Storage">Storage</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span></span>&#123;<br>    struct TreeNode&#123;<br>        <span class="hljs-keyword">int</span> l,r; <span class="hljs-regexp">//</span>左右端点<br>        <span class="hljs-keyword">int</span> lson,rson; <span class="hljs-regexp">//</span>左右儿子编号<br>        <span class="hljs-keyword">int</span> data; <span class="hljs-regexp">//</span>关键数据<br>    &#125;nodes[maxN &lt;&lt; <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>问题来了，存树的数组应该开多大？<br>通过一些数学证明，我们可以得到，数组应该开成 <strong>4n</strong>。</p><h2 id="Build-Tree">Build Tree</h2><p><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%98%E5%82%A8.png" alt="Build Segment Tree"></p><p>Example：求区间最大值</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void push_up(int <span class="hljs-keyword">node</span><span class="hljs-title">)&#123;</span><br><span class="hljs-title">    auto</span> &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    cur</span>.data = max(nodes[cur.lson],nodes[cur.rson]);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void build(int <span class="hljs-keyword">node</span><span class="hljs-title">,int</span> l,int r)&#123;<br>    auto &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    cur</span>.l = l;<br>    cur.r = r;<br>    if(l == r)&#123;<br>        cur.data = data[l];<br>        return;<br>    &#125;<br>    auto mid = (l + r) / <span class="hljs-number">2</span>;<br>    cur.lson = <span class="hljs-number">2</span> * <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">    cur</span>.rson = <span class="hljs-number">2</span> * <span class="hljs-keyword">node</span> <span class="hljs-title">+ 1</span>;<br>    build(cur.lson,l,mid);<br>    build(cur.rson,mid + <span class="hljs-number">1</span>,r);<br>    push_up(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Query">Query</h2><p>A Good Picture!<br><img src="/img/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%9F%A5%E8%AF%A2.png" alt="Query"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> node,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123;<br>    auto &amp;cur = nodes[node];<br>    <span class="hljs-built_in">if</span>(l &lt;= cur.l &amp;&amp; cur.r &lt;= r)&#123;<br>        return cur.data;<br>    &#125;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (l + r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">if</span>(l &lt;= <span class="hljs-built_in">mid</span>)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,query(cur.lson,l,r));<br>    &#125;<br>    <span class="hljs-built_in">if</span>(r &gt; <span class="hljs-built_in">mid</span>)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,query(cur.rson,l,r));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Single-Point-Update">Single Point Update</h2><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs hsp">void update(<span class="hljs-keyword">int</span> node,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,<span class="hljs-keyword">int</span> val)&#123;<br>    auto &amp;cur = nodes[node]<span class="hljs-comment">;</span><br>    <span class="hljs-keyword">if</span>(cur.lson == cur.rson)&#123;<br>        cur.data = val<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">return</span><span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = (cur.l + cur.r)/<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span> &lt;= mid)&#123;<br>        update(cur.lson,<span class="hljs-keyword">pos</span>,val)<span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span> &gt; mid)&#123;<br>        update(cur.rson,<span class="hljs-keyword">pos</span>,val)<span class="hljs-comment">;</span><br>    &#125;<br>    push_up(node)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Range-Update">Range Update</h2><p>区间查询的核心思想：区间信息上放<br>复杂度：O(logN)</p><p>区间修改能不能也使用相同的思想？<br>若将区间 [l, r] 内元素都加上某个值:</p><ul><li>若维护最值，直接 cur.data+=val</li><li>若维护区间和，则 cur.data+=(r −l+1)∗ val <br>发现：有时我们会对整棵子树做同样的操作</li></ul><p>Solution: Lazy Tag!</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span></span>&#123;<br>    struct TreeNode&#123;<br>        <span class="hljs-keyword">int</span> l,r; <span class="hljs-regexp">//</span>左右端点<br>        <span class="hljs-keyword">int</span> lson,rson; <span class="hljs-regexp">//</span>左右儿子编号<br>        <span class="hljs-keyword">int</span> lazy_tag;<br>        <span class="hljs-keyword">int</span> data; <span class="hljs-regexp">//</span>关键数据<br>    &#125;nodes[maxN &lt;&lt; <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">void modify(<span class="hljs-built_in">int</span> node,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>    auto &amp;cur = nodes[node];<br>    <span class="hljs-keyword">if</span>(l &lt;= cur.l &amp;&amp; cur.r &lt;= r)&#123;<br>        cur.data += <span class="hljs-keyword">val</span>;<br>        cur.lazytag += <span class="hljs-keyword">val</span>;<br>        return;<br>    &#125;<br>    push_down(node);<br>    <span class="hljs-built_in">int</span> mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid)&#123;<br>        modify(cur.lson,l,r,<span class="hljs-keyword">val</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid)&#123;<br>        modify(cur.rson,l,r,<span class="hljs-keyword">val</span>);<br>    &#125;<br>    push_up(node);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void push_down(int <span class="hljs-keyword">node</span><span class="hljs-title">)&#123;</span><br><span class="hljs-title">    auto</span> &amp;cur = nodes[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">    if</span>(cur.lazytag != <span class="hljs-number">0</span>)&#123;<br>        nodes[cur.lson].data += cur.lazytag;<br>        nodes[cur.rson].data += cur.lazytag;<br>        nodes[cur.lson].lazytag = cur.lazytag;<br>        nodes[cur.rson].lazytag = cur.lazytag;<br>        cur.lazytag = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Template-Problem">Template Problem</h2><p>已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上 x；</li><li>将某区间每一个数加上 x；</li><li>求出某区间每一个数的和。</li></ul><p>(add_tag,mul_tag)------(* k)-----&gt;(add_tag * k,mul_tag * k)<br>(add_tag,mul_tag)------(+ k)-----&gt;(add_tag + k,mul_tag)</p><p>AC代码捏</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;iostream&gt;<br>using namespace std;<br>long long int n,m,mod;<br>long long int num[<span class="hljs-number">100005</span>];<br>struct <span class="hljs-symbol">SegmentTree</span> &#123;<br>    long long int l,r;<br>    long long int lson,rson;<br>    long long int lazytag;<br>    long long int multiTag = <span class="hljs-number">1</span>;<br>    long long int data;<br>&#125;nodes[<span class="hljs-number">400005</span>];<br>void push_up(long long int node) &#123;<br>    auto &amp;cur = nodes[node];<br>    cur.data = nodes[cur.lson].data + nodes[cur.rson].data;<br>    cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>&#125;<br>void push_down(long long int node) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.multiTag != <span class="hljs-number">1</span>) &#123;<br>        nodes[cur.lson].multiTag *= cur.multiTag;<br>        nodes[cur.lson].multiTag = (nodes[cur.lson].multiTag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].multiTag *= cur.multiTag;<br>        nodes[cur.rson].multiTag = (nodes[cur.rson].multiTag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].lazytag *= cur.multiTag;<br>        nodes[cur.lson].lazytag = (nodes[cur.lson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].lazytag *= cur.multiTag;<br>        nodes[cur.rson].lazytag = (nodes[cur.rson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].data *= cur.multiTag;<br>        nodes[cur.lson].data = (nodes[cur.lson].data + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].data *= cur.multiTag;<br>        nodes[cur.rson].data = (nodes[cur.rson].data + mod)<span class="hljs-comment">%mod;</span><br>        cur.multiTag = <span class="hljs-number">1</span>;<br>    &#125;<br>    if(cur.lazytag != <span class="hljs-number">0</span>) &#123;<br>        nodes[cur.lson].lazytag += cur.lazytag;<br>        nodes[cur.lson].lazytag = (nodes[cur.lson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].lazytag += cur.lazytag;<br>        nodes[cur.rson].lazytag = (nodes[cur.rson].lazytag + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.lson].data += (nodes[cur.lson].r - nodes[cur.lson].l + <span class="hljs-number">1</span>)*cur.lazytag;<br>        nodes[cur.lson].data = (nodes[cur.lson].data + mod)<span class="hljs-comment">%mod;</span><br>        nodes[cur.rson].data += (nodes[cur.rson].r - nodes[cur.rson].l + <span class="hljs-number">1</span>)*cur.lazytag;<br>        nodes[cur.rson].data = (nodes[cur.rson].data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>void buildTree(long long int node,long long int l,long long int r) &#123;<br>    auto &amp;cur = nodes[node];<br>    cur.multiTag = <span class="hljs-number">1</span>;<br>    cur.l = l;<br>    cur.r = r;<br>    if(l == r) &#123;<br>        cur.data = num[l];<br>        return;<br>    &#125;<br>    long long int mid = (l + r)/<span class="hljs-number">2</span>;<br>    cur.lson = <span class="hljs-number">2</span> * node;<br>    cur.rson = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>;<br>    buildTree(cur.lson,l,mid);<br>    buildTree(cur.rson,mid + <span class="hljs-number">1</span>,r);<br>    push_up(node);<br>&#125;<br>void update(long long int node,long long int l,long long int r,long long int val) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.l &gt;= l &amp;&amp; cur.r &lt;= r) &#123;<br>        cur.data += (cur.r - cur.l + <span class="hljs-number">1</span>)*val;<br>        cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag += val;<br>        cur.lazytag = (cur.lazytag + mod)<span class="hljs-comment">%mod;</span><br>        return;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    if(l &lt;= mid) &#123;<br>        update(cur.lson,l,r,val);<br>    &#125;<br>    if(r &gt; mid) &#123;<br>        update(cur.rson,l,r,val);<br>    &#125;<br>    push_up(node);<br>&#125;<br>void update2(long long int node,long long int l,long long int r,long long int val) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(cur.l &gt;= l &amp;&amp; cur.r &lt;= r) &#123;<br>        cur.data *= val;<br>        cur.data = (cur.data + mod)<span class="hljs-comment">%mod;</span><br>        cur.lazytag *= val;<br>        cur.lazytag = (cur.lazytag + mod)<span class="hljs-comment">%mod;</span><br>        cur.multiTag *= val;<br>        cur.multiTag = (cur.multiTag + mod)<span class="hljs-comment">%mod;</span><br>        return;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    if(l &lt;= mid) &#123;<br>        update2(cur.lson,l,r,val);<br>    &#125;<br>    if(r &gt; mid) &#123;<br>        update2(cur.rson,l,r,val);<br>    &#125;<br>    push_up(node);<br>&#125;<br>long long int query(long long int node,long long int l,long long int r) &#123;<br>    auto &amp;cur = nodes[node];<br>    if(l &lt;= cur.l &amp;&amp; cur.r &lt;= r) &#123;<br>        return cur.data;<br>    &#125;<br>    push_down(node);<br>    long long int mid = (cur.l + cur.r)/<span class="hljs-number">2</span>;<br>    long long int res = <span class="hljs-number">0</span>;<br>    if(l &lt;= mid) &#123;<br>        res += query(cur.lson,l,r);<br>    &#125;<br>    res = (res + mod)<span class="hljs-comment">%mod;</span><br>    if(r &gt; mid) &#123;<br>        res += query(cur.rson,l,r);<br>    &#125;<br>    res = (res + mod)<span class="hljs-comment">%mod;</span><br>    return res;<br>&#125;<br>int main() &#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; num[i];<br>    &#125;<br>    buildTree(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    long long int x,y,k;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        int op;<br>        cin &gt;&gt; op;<br>        if(op == <span class="hljs-number">2</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>            update(<span class="hljs-number">1</span>,x,y,k);<br>        &#125;else if(op == <span class="hljs-number">3</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            cout &lt;&lt; query(<span class="hljs-number">1</span>,x,y) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;else if(op == <span class="hljs-number">1</span>) &#123;<br>            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>            update2(<span class="hljs-number">1</span>,x,y,k);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特别值得注意的是，push_down时应该先更新multiTag，再更新addTag（先乘后加的原则）</p><h2 id="Classic-Problem">Classic Problem</h2><p><a href="http://poj.org/problem?id=3667">POJ 3667 - Hotel</a></p><p>现有一排房间</p><ul><li>询问：是否有连续x个空房间；如果有，就将最靠前的连续x个房间填满</li><li>修改：将任意一段房间清空(可能本来就是空的)</li></ul><p>每个结点维护子树区间内左端极长、右端极长和最长空房间（l_max,r_max,max）<br>Tag：full/null/empty</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Segment Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic Cheating Paper</title>
    <link href="/2025/04/19/Mathematical-Logic8/"/>
    <url>/2025/04/19/Mathematical-Logic8/</url>
    
    <content type="html"><![CDATA[<h1>ML CT Paper</h1><h2 id="前言">前言</h2><p>这是留给25级往后ACM班学弟学妹的一份遗产了，很详细地总结了CS2950 Mathematical Logic这门课程涉及的主要知识点（有所删减）。特别值得注意的是，我在25.6.5晚在前三位作者整理的基础上，增添了6个example，是拟合了近3年ML Final的结果。今晚考完，更觉得整理地挺到位（精准吧 这是能说的嘛🤣）。分数还没出，也不知道实际到底考的怎样😢 但从这门抽象的课中，我学到了很多。这门课的意义就在于，它真正改变了我们看待数学的观点，让我们去定义我们写了这么多年的证明，用了这么多年的公理。我觉得这是一门很很有意思的课（但这门课的难度还是很大的，做好心理准备吧🤣🤣🤣）</p><h2 id="LaTeX-源码">LaTeX 源码</h2><p><a href="https://latex.sjtu.edu.cn/5789875599fpdzxjcfzrgw#7dce86">https://latex.sjtu.edu.cn/5789875599fpdzxjcfzrgw#7dce86</a></p><p>可以根据个人需要删改</p><h2 id="PDF版本">PDF版本</h2><p><img src="/img/CTP1.png" alt="Page_1"></p><p><img src="/img/CTP2.png" alt="Page_2"></p><h2 id="Acknowledgement-排名不分先后">Acknowledgement (排名不分先后)</h2><ul><li><a href="https://github.com/Ancker-0">Coffish</a></li><li><a href="https://github.com/Monkey-Lee0">Monkey_Lee</a></li><li><a href="https://github.com/Sakura-Dusk">Sakura_Dusk</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modern Cpp</title>
    <link href="/2025/04/14/Modern-Cpp/"/>
    <url>/2025/04/14/Modern-Cpp/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：上机课偶遇modern-cpp，拼劲全力无法战胜">Before：上机课偶遇modern cpp，拼劲全力无法战胜</h4><h1>Modern Cpp</h1><h2 id="Overview！">Overview！</h2><p>关于C++的刻板印象是什么？😋<br>笔者在学习了Java（以及相当烂的py）后，深深地感受到了C++语法规则以及一些奇奇怪怪的规定的复杂😇😇。总结一下C++：</p><ul><li>Old, out-dated, less-frequently used</li><li>Unsafe （特别对，救命啊）</li><li>Hard to use</li><li>Various Complication Issues</li></ul><p>Anyway,we still need to learn <strong>Modern Cpp</strong>.<br>We will cover:</p><ul><li>std::move and value types</li><li>Type inference and std::forward</li><li>auto inference</li><li>Syntax sugar</li><li>Smart pointers</li><li>Safety</li></ul><h2 id="Value-Types">Value Types</h2><h3 id="左值-右值">左值 右值</h3><ul><li>左值表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。可以用&amp;</li><li>右值则相反，是一个临时对象，不可以用&amp;</li></ul><p>我们知道有2种赋值方式：拷贝赋值和移动赋值。对于a = xxx:</p><ul><li>拷贝赋值函数：xxx为左值</li><li>移动赋值函数：xxx为右值</li></ul><h3 id="Move-for-lvalue？std-move">Move for lvalue？std::move!</h3><p>一个Common sense是移动move比拷贝要快，如果我们想<strong>移动一个左值呢</strong>？</p><p><strong>我们可以用std::move</strong> for this.<br>std::move可以让编译器认为某个左值是一个右值，进行了<strong>所有权的转移</strong>，使用了std::move后的对象不可再使用。</p><p><code>const</code>变量不可以使用移动语义。<br><strong>Notice：以下地方不可用std::move</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">void Print(const std::string &amp;s);<br>std::string <span class="hljs-built_in">Concat</span>(const std::string &amp;p, std::string q) &#123;<br>    ∕∕ Move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> const <span class="hljs-selector-tag">var</span><br>    std::string tmp = std::<span class="hljs-built_in">move</span>(p);<br><br>    ∕∕ Move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> rvalue<br>    std::string tmp2 = std::<span class="hljs-built_in">move</span>(p + q);<br>    std::string ret = p + q;<br><br>    ∕∕ Move <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span> const value reference<br>    Print(std::<span class="hljs-built_in">move</span>(p + q));<br><br>    ∕∕ Move the return value or <span class="hljs-selector-tag">use</span> after move<br>    return std::<span class="hljs-built_in">move</span>(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>std::move的实现并不同于想象中的复杂类型转换，实际上它只用了<code>static_cast</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">∕∕ A sample implementation of std::move<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="hljs-function">type&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">move</span><span class="hljs-params">(_Tp&amp;&amp; <span class="hljs-type">__t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="hljs-type">__t</span>); &#125;<br></code></pre></td></tr></table></figure><h2 id="Universal-Reference-通用引用">Universal Reference 通用引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;param)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>如果传递的参数是左值（lvalue），则 T 会被推断为该类型的引用。如果传递的参数是右值（rvalue），则 T 会被推断为该类型的值类型。</strong><br>所以如果param是左值，T的类型会是int &amp;，那么param的类型会是int&amp; &amp;&amp;，C++会将其折叠为int&amp;。（<strong>引用折叠</strong>）</p><p>如果param是右值，T的类型会是int。那么param的类型会是int&amp;&amp;。<br>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;param)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_lvalue_reference_v&lt;T&gt;)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Left value passed. Type of param is &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Right value passed. Type of param is &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">func</span>(a);  <span class="hljs-comment">// 左值传递</span><br><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(b));  <span class="hljs-comment">// 右值传递</span><br><br>    <span class="hljs-type">int</span> &amp;c = a;<br>    <span class="hljs-built_in">func</span>(c);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-forward-完美转发">std::forward 完美转发</h2><p>笔者在<a href="https://stackoverflow.com/questions/8526598/how-does-stdforward-work-especially-when-passing-lvalue-rvalue-references">stackoverflow</a>上找了一些观点<br><strong>std::forward is really just syntactic sugar over static_cast&lt;T&amp;&amp;&gt;</strong>.Nicol Bolas CommentedDec 15, 2011 at 21:19</p><p><strong>The concepts that seems to be lacking is that type (for instance int) is not the same thing as “value category” (an int can be sometimes a lvalue if you use a variable int a, sometimes rvalue if you return it from a function int fun()). When you look at a parameter thing&amp;&amp; x its type is an rvalue reference, however, the variable named x also has a value category: it’s an lvalue. std::forward&lt;&gt; will make sure to convert the “value category” x to match its type. It makes sure a thing&amp; x is passed as a value category lvalue, and thing&amp;&amp; x passed as an rvalue.</strong> arkan CommentedOct 1, 2022 at 14:19</p><p>std::forward 的作用是根据模板参数的类型，将参数转发为左值或右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp; t)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-comment">//移除T的引用类型</span><br></code></pre></td></tr></table></figure><p>Attach a test:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-type">void</span> process(<span class="hljs-type">int</span>&amp; x) &#123;<br>    std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-type">void</span> process(<span class="hljs-type">int</span>&amp;&amp; x) &#123;<br>    std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;typename T&gt;<br><span class="hljs-type">void</span> <span class="hljs-keyword">wrapper</span>(T&amp;&amp; arg) &#123;<br>    process(std::forward&lt;T&gt;(arg));<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">wrapper</span>(a); // 输出 &quot;lvalue&quot;<br>    <span class="hljs-keyword">wrapper</span>(<span class="hljs-number">20</span>); // 输出 &quot;rvalue&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Auto-Reference-自动类型推断">Auto Reference 自动类型推断</h2><ul><li>auto可推断变量类型</li><li>auto&amp; 可推断引用类型</li><li>const auto&amp; 可推断常量引用</li></ul><p>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个包含整数的向量</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 auto&amp; 遍历向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : vec) &#123;<br>        <span class="hljs-comment">// 直接修改容器中的元素</span><br>        elem *= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出修改后的向量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : vec) &#123;<br>        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="Important-Part-Smart-Pointers-智能指针">Important Part: Smart Pointers!智能指针</h2><h3 id="unique-ptr">unique_ptr</h3><p>一个Move Only的智能指针，只可以拥有一个拥有者。<br>Attach an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name_</span>(name) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass created with name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destroyed with name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>&#125;;<br><br><span class="hljs-comment">// 函数接受一个 unique_ptr 并打印内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintUniquePtr</span><span class="hljs-params">(std::unique_ptr&lt;MyClass&gt; ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>        ptr-&gt;<span class="hljs-built_in">Print</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;unique_ptr is null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数返回一个 unique_ptr</span><br><span class="hljs-function">std::unique_ptr&lt;MyClass&gt; <span class="hljs-title">CreateUniquePtr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 unique_ptr</span><br>    std::unique_ptr&lt;MyClass&gt; myPtr = <span class="hljs-built_in">CreateUniquePtr</span>(<span class="hljs-string">&quot;Kimi&quot;</span>);<br><br>    <span class="hljs-comment">// 使用 unique_ptr</span><br>    myPtr-&gt;<span class="hljs-built_in">Print</span>();<br><br>    <span class="hljs-comment">// 将 unique_ptr 传递给另一个函数</span><br>    <span class="hljs-built_in">PrintUniquePtr</span>(std::<span class="hljs-built_in">move</span>(myPtr));<br><br>    <span class="hljs-comment">// myPtr 已经被移动，现在是空的</span><br>    <span class="hljs-keyword">if</span> (!myPtr) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;myPtr is now null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建另一个 unique_ptr</span><br>    std::unique_ptr&lt;MyClass&gt; anotherPtr = <span class="hljs-built_in">CreateUniquePtr</span>(<span class="hljs-string">&quot;Moonshot AI&quot;</span>);<br><br>    <span class="hljs-comment">// 使用 unique_ptr 的 reset 方法</span><br>    anotherPtr-&gt;<span class="hljs-built_in">Print</span>();<br>    anotherPtr.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 手动释放资源</span><br>    <span class="hljs-keyword">if</span> (!anotherPtr) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;anotherPtr is now null&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MyClass created <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Kimi<br><span class="hljs-type">Name</span>: Kimi<br><span class="hljs-type">Name</span>: Kimi<br>MyClass destroyed <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Kimi<br>myPtr <span class="hljs-keyword">is</span> now <span class="hljs-keyword">null</span><br>MyClass created <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Moonshot AI<br><span class="hljs-type">Name</span>: Moonshot AI<br>MyClass destroyed <span class="hljs-keyword">with</span> <span class="hljs-type">name</span>: Moonshot AI<br>anotherPtr <span class="hljs-keyword">is</span> now <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr">shared_ptr</h3><p>基本特性：</p><ul><li>可以有多个所有者，是可拷贝的，但需要注意循环引用问题。</li><li>只有当所有拥有者都释放它时才会销毁（通过引用计数实现）。</li></ul><p><code>shared_ptr</code>的特殊用途<br>解决类之间的循环引用：<br>如果两个类相互包含对方的对象，会导致编译错误，因为C++需要在编译时知道类的大小。<br>使用shared_ptr可以解决这个问题，因为shared_ptr<T>只需要类的声明而不需要定义就可以使用。</p><p>Attach an example:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    // 其他方法和成员<br>private:<br>    std::shared_ptr&lt;B&gt; b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    // 其他方法和成员<br>private:<br>    std::shared_ptr&lt;A&gt; a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="weak-ptr">weak_ptr</h3><p>在使用智能指针shared_ptr的时候，可能会存在循环引用的问题，例如智能指针a指向智能指针b，智能指针b指向智能指针a。此时两个智能指针的引用计数都不为1，此时存在内存泄露，两个指针指向的内存不会被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;Node&gt; next;<br><br>    <span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node created\n&quot;</span>; &#125;<br><br>    ~<span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_bug_for_shared_ptr</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Node&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>    std::shared_ptr&lt;Node&gt; ptr2 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>    ptr1-&gt;next = ptr2;<br>    ptr2-&gt;next = ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_bug_for_shared_ptr</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br></code></pre></td></tr></table></figure><p><code>weak_ptr</code> 是 C++11 引入的一种智能指针，用于解决 <code>shared_ptr</code> 的循环引用问题。它允许一个对象安全地引用另一个对象，但不会增加引用计数。<br>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;B&gt; b_ptr;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::weak_ptr&lt;A&gt; a_ptr; <span class="hljs-comment">// 使用 weak_ptr 避免循环引用</span><br>    ~<span class="hljs-built_in">B</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建两个对象，避免循环引用</span><br>    &#123;<br>        std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>        std::shared_ptr&lt;B&gt; b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br><br>        <span class="hljs-comment">// A 持有 B 的 shared_ptr</span><br>        a-&gt;b_ptr = b;<br><br>        <span class="hljs-comment">// B 持有 A 的 weak_ptr</span><br>        b-&gt;a_ptr = a;<br><br>        <span class="hljs-comment">// 当作用域结束时，a 和 b 会被正确销毁</span><br>    &#125; <span class="hljs-comment">// 这里不会导致内存泄漏</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> destroyed<br><span class="hljs-selector-tag">B</span> destroyed<br></code></pre></td></tr></table></figure><h2 id="std-any">std::any</h2><p>功能：<br>允许在C++中以类似弱类型语言的方式使用变量。<br>可以存储任何类型的数据，并在需要时进行类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::any x = <span class="hljs-number">114514</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 2</span><br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br>    &#125;<br>    x = <span class="hljs-string">&quot;qwerty&quot;</span>; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 5</span><br>        std::cout &lt;&lt; (*ptr) + <span class="hljs-number">114514</span> &lt;&lt; std::endl; <span class="hljs-comment">// 6</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">114514<br><br></code></pre></td></tr></table></figure><p><code>auto ptr = std::any_cast&lt;int&gt;(&amp;x)</code>会判断ptr是否可以转化为一个int*类型的指针，如果可以就做取地址，如果不可以就变成<code>nullptr</code></p><h2 id="std-optional-and-std-variant">std::optional and std::variant</h2><h3 id="std-optional">std::optional</h3><ul><li>可以存储类型T的值或者什么也不存储（类似于指针，但更安全）。</li><li>用于表示可选值，避免使用裸指针带来的空指针问题。</li></ul><p>Attach a test:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-type">bool</span> returnValue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (returnValue) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 返回空</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 42</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No value&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 42</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No value&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Value:</span> <span class="hljs-number">42</span><br><span class="hljs-literal">No</span> <span class="hljs-string">value</span><br></code></pre></td></tr></table></figure><h3 id="std-variant">std::variant</h3><ul><li>可以存储多种类型的数据（类似于union，但使用起来更方便）。</li><li>用于存储不同类型的数据，并且可以在运行时安全地访问和转换。</li></ul><p>Attach an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 定义一个 std::variant，可以存储 int 或 std::string</span><br><span class="hljs-keyword">using</span> MyVariant = std::variant&lt;<span class="hljs-type">int</span>, std::string&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVariant</span><span class="hljs-params">(<span class="hljs-type">const</span> MyVariant&amp; v)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::visit 访问 std::variant</span><br>    std::<span class="hljs-built_in">visit</span>([](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;, v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 std::variant，初始值为 int</span><br>    MyVariant v1 = <span class="hljs-number">42</span>;<br>    <span class="hljs-built_in">printVariant</span>(v1); <span class="hljs-comment">// 输出: Value: 42</span><br><br>    <span class="hljs-comment">// 修改 std::variant 的值为 std::string</span><br>    v1 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    <span class="hljs-built_in">printVariant</span>(v1); <span class="hljs-comment">// 输出: Value: Hello, World!</span><br><br>    <span class="hljs-comment">// 创建一个 std::variant，初始值为 std::string</span><br>    MyVariant v2 = <span class="hljs-string">&quot;Another string&quot;</span>;<br>    <span class="hljs-built_in">printVariant</span>(v2); <span class="hljs-comment">// 输出: Value: Another string</span><br><br>    <span class="hljs-comment">// 修改 std::variant 的值为 int</span><br>    v2 = <span class="hljs-number">123</span>;<br>    <span class="hljs-built_in">printVariant</span>(v2); <span class="hljs-comment">// 输出: Value: 123</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><ul><li><a href="https://xiyuanyang-code.github.io/posts/Modern-C/">YXY 的Modern Cpp 学习笔记</a></li><li>Kimi AI（发现了kimi的好）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Modern Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical Logic 7 Completeness 1</title>
    <link href="/2025/04/12/Mathematical-Logic7/"/>
    <url>/2025/04/12/Mathematical-Logic7/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：久违的数理逻辑课！上了7节课终于觉得有点入门了，还是挺有意思的。周四下午闪击南京，周五下午又闪击回来。虽然只有1天，但很开心在这短短的20个小时内帮助了不少人（都是无意间）。我要永远做个善良的人！">Before：久违的数理逻辑课！上了7节课终于觉得有点入门了，还是挺有意思的。周四下午闪击南京，周五下午又闪击回来。虽然只有1天，但很开心在这短短的20个小时内帮助了不少人（都是无意间）。我要永远做个善良的人！</h4><h1>Mathematical Logic 7 Completeness 1</h1><p>我们继续完备性的证明！<br>我们知道，要证明一阶逻辑的完备性，我们只需要证明：</p><p>Given a consisitent <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span>,it suffices to construct a term model <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{I}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> = (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">T</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup><mo separator="true">,</mo><msup><mrow><mi>β</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{T}^{\Phi},\mathfrak{\beta}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">T</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class=""><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>) such that:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathfrak{I}^{\Phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> \iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⊢</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>.</p><p>昨晚室友问我为了体现完备性，就是要证明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊨</mo></mrow><annotation encoding="application/x-tex">\models</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.999em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class="mrel">⊨</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> 难道不是在说对于任何一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> 上的模型，都能使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>为真吗？但是这里不是只找了一个模型吗？我想这应该是由于<strong>Henkin’s Term Model</strong>的特殊性，但这个留到后几节课再讨论了。</p><h2 id="Henkin’s-Term-Model-Recall-模型回顾">Henkin’s Term Model Recall 模型回顾</h2><p>首先引入等价类的概念：<br>Let $ t_1,t_2 $ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>.Then $ t_1 $ ~ $ t_2 $ if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">⊢</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1\equiv t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≡</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>.</p><p>For every t <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> we define:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>t</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.81508em;"></span><span class="strut bottom" style="height:0.81508em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> := {t’ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> |t’ ~ t}</p><p><strong>Definition</strong><br>The term structure for (\Phi), denoted by (\mathfrak{I}^{\Phi}), is defined as follows.</p><ol><li><p><strong>Universe</strong>:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mrow><mi mathvariant="normal">Φ</mi></mrow></msup><mo>:</mo><mo>=</mo><mo>{</mo><mover accent="true"><mrow><mi>t</mi></mrow><mo stretchy="true">‾</mo></mover><mo>∣</mo><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup><mo>}</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">T^{\Phi} := \{\overline{t} \mid t \in T^S\}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">:</span><span class="mrel">=</span><span class="mopen">{</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mrel">∣</span><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Relation symbols</strong>:<br>For every \(n\)-ary relation symbol \(R \in S\), and \(\overline{t_1}, \ldots, \overline{t_n} \in T^{\Phi}\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mover accent="true"><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo><mo>∈</mo><msup><mi>R</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mspace width="1em"></mspace><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi></mtext><mspace width="1em"></mspace><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>R</mi><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(\overline{t_1}, \ldots, \overline{t_n}) \in R^{\mathfrak{I}^{\Phi}} \quad \text{if} \quad \Phi \vdash R t_1 \ldots t_n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:1.2087649999999999em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mspace quad"></span><span class="text mord textstyle uncramped"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span></span><span class="mord mspace quad"></span><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Function symbols</strong>:<br>For every \(n\)-ary function symbol \(f \in S\), and \(\overline{t_1}, \ldots, \overline{t_n} \in T^{\Phi}\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mo>(</mo><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mover accent="true"><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mo>)</mo><mo>:</mo><mo>=</mo><mi>f</mi><mover accent="true"><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><mo stretchy="true">‾</mo></mover><mo>⋯</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f^{\mathfrak{I}^{\Phi}} (\overline{t_1}, \ldots, \overline{t_n}) := f \overline{t_1} \cdots t_n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:1.2087649999999999em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="minner">…</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">:</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.73508em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="minner">⋯</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li><li><p><strong>Constants</strong>:<br>For every constant \(c \in S\),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mrow><mi mathvariant="normal">Φ</mi></mrow></msup></mrow></msup><mo>:</mo><mo>=</mo><mover accent="true"><mrow><mi>c</mi></mrow><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">c^{\mathfrak{I}^{\Phi}} := \overline{c}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9587649999999999em;"></span><span class="strut bottom" style="height:0.9587649999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class=""><span class="mord scriptstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped"><span class="mord scriptscriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">:</span><span class="mrel">=</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">c</span></span></span><span style="top:-0.5505599999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p></li></ol><p>For every variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,we let:<br>\mathfrak{\beta}^{\Phi}\(v_i\) := <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{v_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.63056em;"></span><span class="strut bottom" style="height:0.78056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.5505599999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span></p><h2 id="对于原子公式成立-atomic-varphi">对于原子公式成立 atomic <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span></h2><p><strong>Lemma 5</strong></p><p>(i) For any \( t \in T^S \),<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>(</mo><mi>t</mi><mo>)</mo><mo>=</mo><mover accent="true"><mrow><mi>t</mi></mrow><mo>¯</mo></mover><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi(t) = \bar{t}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">t</span></span></span><span style="top:-0.18407999999999997em;margin-left:0.16668em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span></span></span></span></p><p>(ii) For every atomic \(\varphi\),<br>\mathfrak{I}^\Phi \models \varphi \iff \Phi \vdash \varphi.</p><p>(i)的证明，我们<strong>对项t进行归纳</strong>：</p><ul><li>t = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> is a variable</li><li>t = c is a constant</li><li>t = f<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_1...t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li></ul><p>根据定义可证</p><p>(ii)的证明，对2个原子公式进行分类讨论：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><msub><mi>t</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models t_1 \equiv t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≡</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>R</mi><msub><mi>t</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models Rt_1...t_n    </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br>利用(i)中所证，可证</p><h2 id="Consistent-Negation-Complete-Contains-Witness">Consistent,Negation Complete,Contains Witness</h2><h3 id="Lemma-8">Lemma 8</h3><p>先看一个引理：</p><h1>Lemma 8</h1><p>Let (\varphi) be an (S)-formula and (x_1, \ldots, x_n) pairwise distinct variables. Then</p><h3 id="i">(i)</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi mathvariant="normal">∃</mi><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><mi mathvariant="normal">∃</mi><msub><mi>x</mi><mi>n</mi></msub><mi>φ</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \exists x_1 \ldots \exists x_n \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathrm">∃</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord mathrm">∃</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">φ</span></span></span></span><br><strong>if and only if</strong> there are (S)-terms (t_1, \ldots, t_n) such that<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>φ</mi><mfrac><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \varphi \frac{t_1 \ldots t_n}{x_1 \ldots x_n}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8455559999999999em;"></span><span class="strut bottom" style="height:1.295556em;vertical-align:-0.44999999999999996em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.4149999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mathrm">.</span></span></span></span></p><h3 id="ii">(ii)</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi mathvariant="normal">∀</mi><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><mi mathvariant="normal">∀</mi><msub><mi>x</mi><mi>n</mi></msub><mi>φ</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \forall x_1 \ldots \forall x_n \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.090331em;vertical-align:-0.249em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathrm">∀</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord mathrm">∀</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">φ</span></span></span></span><br><strong>if and only if</strong> for all (S)-terms (t_1, \ldots, t_n) we have<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="fraktur">I</mi></mrow><mi mathvariant="normal">Φ</mi></msup><mo>⊨</mo><mi>φ</mi><mfrac><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>…</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathfrak{I}^\Phi \models \varphi \frac{t_1 \ldots t_n}{x_1 \ldots x_n}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8455559999999999em;"></span><span class="strut bottom" style="height:1.295556em;vertical-align:-0.44999999999999996em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathfrak">I</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">Φ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊨</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.4149999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="minner">…</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mathrm">.</span></span></span></span></p><p>由替换引理等可证</p><h3 id="Consistent">Consistent</h3><p><strong>Definition</strong><br><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is consistent if there is no <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> such that both <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> ⊢ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> ⊢ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>. Otherwise,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is inconsistent.</strong></p><h3 id="Negation-Complete">Negation Complete</h3><p><strong>Definition</strong><br>A set (\Phi) is <em>negation complete</em> if for every (S)-formula (\varphi):<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi><mtext><mtext> </mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mtext> </mtext></mtext><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">¬</mi><mi>φ</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi \text{ or } \Phi \vdash \neg \varphi.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mspace"> </span></span><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">¬</span><span class="mord mathit">φ</span><span class="mord mathrm">.</span></span></span></span></p><p>通俗的说，就是如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> 证不出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span>，那就一定能证出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span>；证不出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span>，那就一定能证出来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span></p><h3 id="Contains-Witness">Contains Witness</h3><h1>Definition</h1><p>🔍 A set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> <strong>contains witnesses</strong> if for every <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo>∈</mo><msup><mi>L</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">\varphi \in L^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> and every variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>, there exists a term <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">t \in T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> such that:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mrow><mo fence="true">(</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mi>φ</mi><mo>→</mo><mi>φ</mi><mfrac><mrow><mi>t</mi></mrow><mrow><mi>x</mi></mrow></mfrac><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \left( \exists x \varphi \to \varphi \frac{t}{x} \right).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathrm">∃</span><span class="mord mathit">x</span><span class="mord mathit">φ</span><span class="mrel">→</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord mathrm">.</span></span></span></span></p><h2 id="Henkin’s-Theorem-Proof">Henkin’s Theorem Proof</h2><p>First,还是先来证明一个引理：</p><h3 id="Lemma-9">Lemma 9</h3><p>Assume that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span></span></span></span> is <strong>consistent</strong>, <strong>negation complete</strong>, and <strong>contains witnesses</strong>. Then for all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>-formulas <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">ψ</span></span></span></span>:</p><p>(i)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span></span></span></span> if and only if \Phi \not\vdash \neg \varphi.</p><p>(ii)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mo>(</mo><mi>φ</mi><mo>∨</mo><mi>ψ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Phi \vdash (\varphi \vee \psi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mopen">(</span><span class="mord mathit">φ</span><span class="mbin">∨</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span><span class="mclose">)</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit" style="margin-right:0.03588em;">ψ</span></span></span></span>.</p><p>(iii)<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \exists x \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">∃</span><span class="mord mathit">x</span><span class="mord mathit">φ</span></span></span></span> if and only if there is a term <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><msup><mi>T</mi><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">t \in T^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi>φ</mi><mfrac><mrow><mi>t</mi></mrow><mrow><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\Phi \vdash \varphi \frac{t}{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824556em;"></span><span class="strut bottom" style="height:1.169556em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathit">φ</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>.</p><p>(i)向右通过consistent定义说明，向左通过negation complete定义说明<br>(ii)向左利用V-intro by succedent证明，向右证明如下：<br>Assume that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>⊢</mo><mi mathvariant="normal">¬</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">\Phi \vdash \neg \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Φ</span><span class="mrel">⊢</span><span class="mord mathrm">¬</span><span class="mord mathit">φ</span></span></span></span><br><strong>Proof Steps:</strong><br><img src="/img/Lemma9.png" alt="Lemma 9(ii)Proof"></p><p>(iii)向右可通过Modus ponens证明，向左可通过\exist-intro in succedent证明</p><h3 id="Henkin’s-Theorem">Henkin’s Theorem</h3><p>由引理证明起来还是比较显然的：<br><img src="/img/Henkin.png" alt="Henkin's Theorem Proof"></p><p>注意，这里对公式的归纳是对公式的<strong>connective rank</strong>归纳，保证要证的公式都更长：<br><strong>Rank Definition:</strong><br>rk(\varphi) := \begin{cases} 0 & \text{if } \varphi \text{ is atomic,} \1 + rk(\psi) & \text{if } \varphi = \neg\psi, \1 + rk(\psi_1) + rk(\psi_2) & \text{if } \varphi = (\psi_1 \lor \psi_2), \1 + rk(\psi) & \text{if } \varphi = \exists x \psi. \end{cases}</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust RefCell机制</title>
    <link href="/2025/04/07/Rust-RefCell%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/07/Rust-RefCell%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：为什么要出一期挺莫名其妙的东西？起因还是机考，连续2次机考工程题一分没拿了（太菜了bushi），感觉对C-的各种机制很不熟悉，而Rust又是重要的一门现代编程语言。援引StanfordCS110L前言的一段话：">Before：为什么要出一期挺莫名其妙的东西？起因还是机考，连续2次机考工程题一分没拿了（太菜了bushi），感觉对C++的各种机制很不熟悉，而Rust又是重要的一门现代编程语言。援引<a href="https://reberhardt.com/cs110l/spring-2020/">StanfordCS110L</a>前言的一段话：</h4><h5 id="如果你学过-C-并接触过一些系统编程的话，应该对-C-的内存泄漏以及指针的危险有所耳闻，但-C-的底层特性以及高效仍然让它在系统级编程中无法被例如-Java-等自带垃圾收集机制的高级语言所替代。而-Rust-的目标则是希望在-C-的高效基础上，弥补其安全不足的缺点。因此-Rust-在设计之初，就有带有很多系统编程的观点。学习-Rust，也能让你之后能用-C-语言编写出更安全更优雅的系统级代码（例如操作系统等）。"><em>如果你学过 C 并接触过一些系统编程的话，应该对 C 的内存泄漏以及指针的危险有所耳闻，但 C 的底层特性以及高效仍然让它在系统级编程中无法被例如 Java 等自带垃圾收集机制的高级语言所替代。而 Rust 的目标则是希望在 C 的高效基础上，弥补其安全不足的缺点。因此 Rust 在设计之初，就有带有很多系统编程的观点。学习 Rust，也能让你之后能用 C 语言编写出更安全更优雅的系统级代码（例如操作系统等）。</em></h5><h1>Rust Learning _RefCell机制</h1><h2 id="Rust的所有权机制">Rust的所有权机制</h2><p>Rust的所有权机制要求每个值都有<strong>唯一的所有者</strong>（通常是变量），并且在同一时间内只能有一个所有者。所有权的转移可以通过赋值、函数参数传递或返回值来实现。相当于 C++ 中的移动语义（std::move()）</p><p>在一个值的所有者变量的作用域之外（例如在另外一个函数中）对该值的访问必须通过借用（相当于 C++ 中指向变量的指针）来实现。Rust 中的借用分为两种：</p><ul class="lvl-0"><li class="lvl-2"><p>不可变借用（Immutable Borrow）：相当于 C++ 中的 const T*，允许读取但不允许修改</p></li><li class="lvl-2"><p>可变借用（Mutable Borrow）：相当于 C++ 中的 T*，允许读取和修改</p></li></ul><p>Rust 对变量的借用有着严格的限制：</p><ul class="lvl-0"><li class="lvl-2"><p>在同一时间内，只能有<strong>一个可变借用，或者多个不可变借用</strong></p></li><li class="lvl-2"><p><strong>不能同时存在可变借用和不可变借用</strong></p></li><li class="lvl-2"><p>所有借用都必须在拥有变量的生命周期内有效，对以上规则的违反会导致编译错误。</p></li></ul><p>Rust 的借用机制对编译器优化非常有帮助。由于不可变借用不能与可变借用共存，**被不可变借用指向的值只需要从堆内存中获取一次，之后可以安全地存储在寄存器或栈上缓存中。*<em>相比之下，C++ 中也进行类似的优化，但其他函数修改 const</em> 指针指向的值是未定义行为，可能导致不安全的代码。</p><p>Rust 的编译器可以在编译时就能“静态”地检查所有权和借用关系，在运行时无需额外检查。然而，<strong>对于堆上对象，在编译期检查所有权和借用关系是非常困难的</strong>。因此，Rust 提供了 RefCell<T> 类型来在运行时检查所有权和借用关系。它有如下方法：</p><ul class="lvl-0"><li class="lvl-2"><p>borrow() 与 try_borrow()：获取一个不可变借用，返回 Ref<T> 类型。如果当前存在可变借用则失败。borrow() 会 panic，相当于 C++ 中的 abort，而 try_borrow() 返回一个 Result&lt;Ref<T>, BorrowError&gt;，相当于 C++ 中的 std::optional&lt;Ref<T>&gt;</p></li><li class="lvl-2"><p>borrow_mut() 与 try_borrow_mut()：获取一个可变借用，返回 RefMut<T> 类型。如果当前存在任何借用则会失败</p></li><li class="lvl-2"><p>返回的 Ref<T> 和 RefMut<T> 包装器实现了解引用操作符，可以像使用普通引用一样使用</p></li><li class="lvl-2"><p>当 Ref<T> 和 RefMut<T> 的生命周期结束时，会自动减少或重置借用计数</p></li><li class="lvl-2"><p>当 RefCell<T> 的生命周期结束时，若仍有借用存在，则会 panic</p></li></ul><h2 id="C-中的std-optional">C++中的std::optional</h2><p>编程中，我们经常会需要表示或处理一个“可能为空”的变量，可能是一个为包含任何元素的容器，可能是一个类型的指针没有指向任何有效的对象实例，再或者是一个对象没有被赋予有效的值。</p><p>C++17中的std::optional<T>为解决这类问题提供了简单的解决方案。optional<T>可以看作是T类型变脸与一个布尔值的打包。其中的布尔值用来表示T是否为“空”。<br>std::optional<T>可以：<strong>包含一个类型为T的值或者不包含任何值(处于&quot;空&quot;状态)</strong><br>不包含任何值显示表示为：std::nullopt</p><p>Advantage: 明确表示值可能存在或不存在；强制使用者考虑值缺失的情况；通常比使用指针或额外标志更高效</p><h2 id="C-中的const-成员函数">C++中的const 成员函数</h2><p><strong>在C++中，只有被声明为const的成员函数才能被一个const类对象调用。</strong><br>const 成员函数<strong>不能修改类的普通成员变量</strong><br>如果想修改，需加上mutable关键字，允许 const 成员函数修改内部计数器（确实这个关键字常见于计数器）</p><h2 id="剩余代码的实现">剩余代码的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCellError</span> : <span class="hljs-keyword">public</span> std::runtime_error &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCellError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : std::runtime_error(message) &#123;</span>&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RefCellError</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<span class="hljs-comment">// Abstract class as base class</span><br><br><span class="hljs-comment">//invalidly call an immutable borrow</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><span class="hljs-comment">//invalidly call a mutable borrow</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowMutError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowMutError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><span class="hljs-comment">//still has refs when destructed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructionError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DestructionError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCell</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>    <span class="hljs-comment">// TODO(student)</span><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_num;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_mut_num;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Forward declarations</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span>;<br><br>    <span class="hljs-comment">// Constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; initial_value)</span>:value(initial_value),borrow_mut_num(<span class="hljs-number">0</span>),borrow_num(<span class="hljs-number">0</span>) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(T &amp;&amp; initial_value)</span>:value(std::move(initial_value)),borrow_mut_num(<span class="hljs-number">0</span>),borrow_num(<span class="hljs-number">0</span>) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// Disable copying and moving for simplicity</span><br>    <span class="hljs-built_in">RefCell</span>(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">RefCell</span>(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// Borrow methods</span><br>    <span class="hljs-function">Ref <span class="hljs-title">borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        ++ borrow_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;Ref&gt; <span class="hljs-title">try_borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        ++ borrow_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">RefMut <span class="hljs-title">borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        ++ borrow_mut_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;RefMut&gt; <span class="hljs-title">try_borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(borrow_mut_num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        ++ borrow_mut_num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Inner classes for borrows</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-type">const</span> RefCell* refcell;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Ref</span>(<span class="hljs-type">const</span> RefCell &amp;c):<span class="hljs-built_in">refcell</span>(&amp;c),<span class="hljs-built_in">valid</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br><br>        ~<span class="hljs-built_in">Ref</span>() &#123;<br>            <span class="hljs-keyword">if</span>(valid ) &#123;<br>                -- refcell-&gt;borrow_num;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-comment">// Allow copying</span><br>        <span class="hljs-built_in">Ref</span>(<span class="hljs-type">const</span> Ref&amp; other):<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            <span class="hljs-keyword">if</span>(valid)&#123;<br>                ++ refcell-&gt;borrow_num;<br>            &#125;<br>        &#125;<br>        Ref&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Ref&amp; other) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span>(valid) &#123;<br>                    -- refcell-&gt;borrow_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = other.valid;<br>                <span class="hljs-keyword">if</span>(valid)&#123;<br>                    ++ refcell-&gt;borrow_num;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Allow moving</span><br>        <span class="hljs-built_in">Ref</span>(Ref&amp;&amp; other) <span class="hljs-keyword">noexcept</span>:<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            <span class="hljs-comment">//TODO</span><br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Ref&amp; <span class="hljs-keyword">operator</span>=(Ref&amp;&amp; other) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    --refcell-&gt;borrow_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = <span class="hljs-literal">true</span>;<br>                other.valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//other = nullptr;</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// TODO(student)</span><br>        RefCell* refcell;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">RefMut</span>(RefCell &amp;c):<span class="hljs-built_in">refcell</span>(&amp;c),<span class="hljs-built_in">valid</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br><br>        ~<span class="hljs-built_in">RefMut</span>() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(valid ) &#123;<br>                -- refcell-&gt;borrow_mut_num;<br>            &#125;<br>        &#125;<br><br>        T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_mut_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> refcell-&gt;value;<br>        &#125;<br><br>        T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            <span class="hljs-keyword">if</span>(!valid || refcell-&gt;borrow_mut_num == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;refcell-&gt;value;<br>        &#125;<br><br>        <span class="hljs-comment">// Disable copying to ensure correct borrow rules</span><br>        <span class="hljs-built_in">RefMut</span>(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br><br>        <span class="hljs-comment">// Allow moving</span><br>        <span class="hljs-built_in">RefMut</span>(RefMut&amp;&amp; other) <span class="hljs-keyword">noexcept</span>:<span class="hljs-built_in">refcell</span>(other.refcell),<span class="hljs-built_in">valid</span>(other.valid)  &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(RefMut&amp;&amp; other) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    --refcell-&gt;borrow_mut_num;<br>                &#125;<br>                refcell = other.refcell;<br>                valid = other.valid;<br>                other.valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//other = nullptr;</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor</span><br>    ~<span class="hljs-built_in">RefCell</span>() &#123;<br>        <span class="hljs-comment">// TODO(student)</span><br>        <span class="hljs-keyword">if</span>(borrow_mut_num &gt; <span class="hljs-number">0</span> || borrow_num &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DestructionError</span>(<span class="hljs-string">&quot;RuntimeError&quot;</span>);<br>        &#125;<br>        borrow_mut_num = <span class="hljs-number">0</span>;<br>        borrow_num = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Reference">Reference</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2641">stargazer 的 RefCell</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/hhdshg/article/details/103433781">C++17之std::optional全方位详解</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Language Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Rust</tag>
      
      <tag>Const</tag>
      
      <tag>Memory Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Of DS——Fenwick Tree &amp; Sparse Table</title>
    <link href="/2025/04/05/AlgorithmOfDS2/"/>
    <url>/2025/04/05/AlgorithmOfDS2/</url>
    
    <content type="html"><![CDATA[<h4 id="before20250329must-be-one-of-the-best-days-in-2025i-cant-tell-you-why-and-i-beg-you-dont-ask-me-whyi-just-hope-to-be-like-her-and-continue-chasing-after-my-dreamjust-like-her-and-themwhatever-it-takesi-just-cant-help-being-excited-about-this-wonderful-meeting-in-xuhuishanghai-hope-everything-will-be-alright"><a class="markdownIt-Anchor" href="#before20250329must-be-one-of-the-best-days-in-2025i-cant-tell-you-why-and-i-beg-you-dont-ask-me-whyi-just-hope-to-be-like-her-and-continue-chasing-after-my-dreamjust-like-her-and-themwhatever-it-takesi-just-cant-help-being-excited-about-this-wonderful-meeting-in-xuhuishanghai-hope-everything-will-be-alright"></a> Before：2025.03.29，must be one of the best days in 2025.I can’t tell you why and I beg you don’t ask me why.I just hope to be like her and continue chasing after my dream,just like her and them.Whatever it takes.I just can’t help being excited about this wonderful meeting in Xuhui,Shanghai. Hope everything will be alright.</h4><p><img src="/img/xuhui.jpg" alt="2025.03.29晚-徐家汇-上海" /></p><h1 id="algorithm-of-ds-2-fenwick-tree-and-sparse-table"><a class="markdownIt-Anchor" href="#algorithm-of-ds-2-fenwick-tree-and-sparse-table"></a> Algorithm of DS 2 Fenwick Tree and Sparse Table</h1><h1 id="fenwick-tree-树状数组"><a class="markdownIt-Anchor" href="#fenwick-tree-树状数组"></a> Fenwick Tree 树状数组</h1><p>一点点feeling：1~base在算法题里还是很香的😢</p><h2 id="单点修改与区间查询"><a class="markdownIt-Anchor" href="#单点修改与区间查询"></a> 单点修改与区间查询</h2><p>对于序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,...,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>我们要支持一下操作：<br />（1）单点修改其中某个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />（2）查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>A problem we first met in the <strong>Chunking</strong> with a time complexity of O(n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>).（上机课上助教反复说过，可以用《线段树和树状数组解决》）所以要介绍的就是《<strong>树状数组</strong>》来解决这个经典问题。</p><p>如下图所示，就展示了一个树状数组求解前缀和的很好的例子：<br /><img src="/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" alt="树状数组" /></p><p>首先我们介绍树状数组中的<strong>预处理函数</strong>——lowbit函数！</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<span class="hljs-comment">//有时可能需要开成long long int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不难知道，这其实是x二进制表示下从右往左第一个出现1的位置。<br />每一个树状数组c[x]管辖的范围其实是：[x - lowbit(x) + 1,x]<br />为求得前缀和，每次回退lowbit(x)，得到新的x（新的起点）。如此往复，直到x = 0，代码实现如下：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml">int query(int <span class="hljs-variable language_">x</span>)&#123;<br>    int ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">x</span> &gt; <span class="hljs-number">0</span>)&#123;<br>        ans += c[<span class="hljs-variable language_">x</span>];<br>        <span class="hljs-variable language_">x</span> -= lowbit(<span class="hljs-variable language_">x</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我需要得到区间[x,y]之间的和，则：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">return <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>而对于更新操作，我们需要对第x位后包括x的所有树状数组的和进行加w的操作，相当于是一个逆过程：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-type">void</span> update(int <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span>int w)&#123;<br>    while(<span class="hljs-keyword">x</span> &lt;<span class="hljs-operator">=</span> n)&#123;<br>        <span class="hljs-keyword">c</span>[<span class="hljs-keyword">x</span>] +<span class="hljs-operator">=</span> w<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">x</span> +<span class="hljs-operator">=</span> lowbit(<span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间修改和单点查询"><a class="markdownIt-Anchor" href="#区间修改和单点查询"></a> 区间修改和单点查询</h2><p>似乎略有变化，实则并无变化，只是我们维护的树状数组c[x]是对于差分数组的。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">d<span class="hljs-comment">[i]</span> = a<span class="hljs-comment">[i]</span> - a<span class="hljs-comment">[i-1]</span>;<br></code></pre></td></tr></table></figure><p>查询操作很简单，就是对差分数组求一个前缀和，函数实现一模一样。<br />如果要对某一区间[x,y]内的所有数进行一个 + w的操作，观察到，当i <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> [x + 1,y]时，d[i]不会发生变化，我们只需要修改首尾两处的d[i]即可，进行操作:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">update</span>(x,w);<br><span class="hljs-built_in">update</span>(y + <span class="hljs-number">1</span>,-w);<br></code></pre></td></tr></table></figure><h2 id="区间修改与区间查询"><a class="markdownIt-Anchor" href="#区间修改与区间查询"></a> 区间修改与区间查询</h2><p>又有了一些小变化，不妨列出来看一看：<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} \Sigma_{j = 1}^{i} d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span><br />= k * d[1] + (k - 1) * d[2] + … + 1 * d[k]<br />= (k + 1) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>i</mi><mo>∗</mo><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma_{i = 1}^{k} i * d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></p><p>可见事实上我们只需要再多维护一个id[i]的树状数组就可以了(in fact 是这次小作业的某一题)，召唤术：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2665">区间修改与查找</a><br />hint：校外用户对不住了，ACMOJ只对sjtu内部开放😢😢</p><h2 id="二维树状数组"><a class="markdownIt-Anchor" href="#二维树状数组"></a> 二维树状数组</h2><p>Show me the Problem!<br />给定一个二维数组A，要求实现以下操作：<br />（1）单点修改A[x][y]<br />（2）单点查询A[x][y]<br />（3）子矩阵和查询：(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为左上角，(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为右下角<br />（4）子矩阵修改：(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为左上角，(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)为右下角，所有元素加w</p><p>类似地建立树状数组c[x][y]表示以(x - lowbit(x) + 1,y - lowbit(y) + 1)为左上角，(x,y)为右下角的子矩阵的信息。<br />对于单点修改，思路大致不变，核心在于先固定一个然后修改另一个，使用循环嵌套：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x;i &lt;= n;i += <span class="hljs-built_in">lowbit</span>(i))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &lt;= m;j += <span class="hljs-built_in">lowbit</span>(j))&#123;<br>            c[i][j] += w;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于子矩阵的查询，想法和一维也是一致的（若左上角为(1,1)）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x;i &gt; <span class="hljs-number">0</span>;i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &gt; <span class="hljs-number">0</span>;j -= <span class="hljs-built_in">lowbit</span>(j))&#123;<br>            ans += c[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>而如果是任意的子矩阵，可以通过容斥原理来解决：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">return <span class="hljs-built_in">query</span>(x2,y2) - <span class="hljs-built_in">query</span>(x1,y2) - <span class="hljs-built_in">query</span>(x2,y1) + <span class="hljs-built_in">query</span>(x1,y1);<br></code></pre></td></tr></table></figure><p>What about <strong>区间修改和单点查询</strong>?<br />Redefine 差分数组：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">d[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span>] = a[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span>] - a[<span class="hljs-variable language_">x</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">y</span>] - a[<span class="hljs-variable language_">x</span>][<span class="hljs-variable language_">y</span> - <span class="hljs-number">1</span>] + a[<span class="hljs-variable language_">x</span> - <span class="hljs-number">1</span>][<span class="hljs-variable language_">y</span> - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>对差分数组构建一个树状数组，单点查询就被转变为了区间前缀和。</p><p>而对于区间修改，通过观察+想象（或者逻辑推演）可知：只需要对4个角进行修改，具体表现为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">update</span>(x1,y1,w);<br><span class="hljs-built_in">update</span>(x1,y2 + <span class="hljs-number">1</span>,-w);<br><span class="hljs-built_in">update</span>(x2,y1 + <span class="hljs-number">1</span>,-w);<br><span class="hljs-built_in">update</span>(x2 + <span class="hljs-number">1</span>,y2 + <span class="hljs-number">1</span>,w);<br></code></pre></td></tr></table></figure><h2 id="another-经典应用树状数组求解逆序对数"><a class="markdownIt-Anchor" href="#another-经典应用树状数组求解逆序对数"></a> Another 经典应用——树状数组求解逆序对数</h2><p>核心在于:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> ans =  <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>    ans += query(maxN) - query(<span class="hljs-built_in">num</span>[i]);<br>    update(<span class="hljs-built_in">num</span>[i],<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果num[i]范围过大，可以采用离散化的方式防止RE😢😰<br />下面附上离散化的代码（de死我了，遇到了各种离谱的bug）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span> &#123;<br>    <span class="hljs-type">int</span> Data;<br>    <span class="hljs-type">int</span> pos;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">const</span> number*abegin,<span class="hljs-type">const</span> number*aend,<span class="hljs-type">const</span> number*bbegin,<span class="hljs-type">const</span> number*bend,number*c)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (abegin != aend &amp;&amp; bbegin != bend) &#123;<br>        <span class="hljs-keyword">if</span>(abegin-&gt;Data &lt; bbegin-&gt;Data) &#123;<br>            *c = *abegin;<br>            abegin ++;<br>            c ++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            *c = *bbegin;<br>            bbegin ++;<br>            c ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(abegin != aend) &#123;<br>        *c = *abegin;<br>        abegin ++;<br>        c ++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(bbegin != bend) &#123;<br>        *c = *bbegin;<br>        bbegin ++;<br>        c ++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(number *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(r - l &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(a,mid,r);<br>    <span class="hljs-keyword">auto</span> *tmp = <span class="hljs-keyword">new</span> number[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">merge</span>(a + l,a + mid,a + mid,a + r,tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; r;i ++) &#123;<br>        a[i] = tmp[i - l];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>&#125;<br><span class="hljs-type">int</span> c[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> tem[<span class="hljs-number">500005</span>];<br>number a[<span class="hljs-number">500005</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> w)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(x &lt;= n) &#123;<br>        c[x] += w;<br>        x += <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) &#123;<br>        ans += c[x];<br>        x -= <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> pairNum = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        cin &gt;&gt; a[i].Data;<br>        a[i].pos = i;<br>    &#125;<br>    <span class="hljs-built_in">merge_sort</span>(a,<span class="hljs-number">1</span>,n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> id = <span class="hljs-number">1</span>;<br>    tem[a[<span class="hljs-number">1</span>].pos] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span>(a[i].Data == a[i - <span class="hljs-number">1</span>].Data) &#123;<br>            tem[a[i].pos] = id;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            tem[a[i].pos] = ++ id;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        pairNum += <span class="hljs-built_in">query</span>(id) - <span class="hljs-built_in">query</span>(tem[i]);<br>        <span class="hljs-built_in">update</span>(tem[i],<span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; pairNum;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sparse-table-st表"><a class="markdownIt-Anchor" href="#sparse-table-st表"></a> Sparse Table ST表</h1><p>ST 表（Sparse Table，稀疏表）是用于解决<strong>可重复贡献问题</strong>的数据结构。</p><h2 id="rmq问题"><a class="markdownIt-Anchor" href="#rmq问题"></a> RMQ问题</h2><p>Problem First😢😢😢：<br />给定n个数，m次询问，对于每个询问，回答区间[l,r]中的最大值。</p><p>我们发现区间最大值是一个具有「可重复贡献」性质的问题。即使用来求解的预处理区间有重叠部分，只要这些区间的并是所求的区间，最终计算出的答案就是正确的。我们能使用至多两个预处理过的区间来覆盖询问区间，也就是说询问时的时间复杂度可以被降至O(1)，在处理有大量询问的题目时十分有效。</p><p>令f(i,j)表示区间[i,i + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span> - 1]区间上的最大值。对于每个询问，我们把它分为[l,l + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span> - 1]和[r - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span> + 1,r]，其中s = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">log_2{r - l + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span>。</p><p>鉴于log操作计算量较大（double），我们考虑用一个函数手写一下：（和OiWiki上的想法不太一样，但感觉能用）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        x /= <span class="hljs-number">2</span>;<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是预处理：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>    cin &gt;&gt; f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是倍增处理了：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">for(int i = <span class="hljs-number">1</span><span class="hljs-comment">;i &lt;= 21;i ++)&#123; //如果数据是1e6级的，那么21就查不多了，甚至不用调用函数再算一下</span><br>    for(int <span class="hljs-keyword">j </span>= <span class="hljs-number">1</span><span class="hljs-comment">;i + (1 &lt;&lt; j) - 1 &lt;= n;j ++)&#123;</span><br>        f[i][<span class="hljs-keyword">j] </span>= std::max(f[i][<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>],f[i + (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>))][<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当查询时，就更简单了：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int s = log(r - l + 1);<br>cout &lt;&lt; std::max(f<span class="hljs-comment">[i]</span><span class="hljs-comment">[s]</span>,f<span class="hljs-comment">[r - (1 &lt;&lt; s) + 1]</span><span class="hljs-comment">[s]</span>);<br></code></pre></td></tr></table></figure><h2 id="超级经典问题与众不同"><a class="markdownIt-Anchor" href="#超级经典问题与众不同"></a> 超级经典问题——与众不同！</h2><p>指路：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2183">与众不同</a><br />思路：记f(i)表示以第i个位置为结尾的最长完美序列的左端点位置，容易发现f(i)是不降的对于一个[l,r]的询问，我们将区间中的点分成左右两部分，左边的点满足f(i)&lt;L,右边的点满足f(i)≥L, 对于左边的点我们可以直接算出答案，对于右边的点我们可以用st表区间询问求得答案。</p><p>上代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> LastExist[<span class="hljs-number">2000005</span>];<br><span class="hljs-type">int</span> position[<span class="hljs-number">200005</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">200005</span>][<span class="hljs-number">20</span>];//ST表<br><span class="hljs-type">int</span> LOG(<span class="hljs-type">int</span> x) &#123;<br>    <span class="hljs-type">int</span> i = - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(x) &#123;<br>        x /= <span class="hljs-number">2</span>;<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    std::ios::sync_with_stdio(<span class="hljs-keyword">false</span>);<br>    cin.tie(<span class="hljs-number">0</span>); <br>    cout.tie(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        x += <span class="hljs-number">1000001</span>;<br>        position[i] = max(position[i - <span class="hljs-number">1</span>],LastExist[x] + <span class="hljs-number">1</span>);<br>        LastExist[x] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> l,r;<br>    //ST表初始化<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = i - position[i] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">21</span>;j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k + (<span class="hljs-number">1</span> &lt;&lt;j) - <span class="hljs-number">1</span> &lt;= n ;k ++) &#123;<br>            f[k][j] = max(f[k][j - <span class="hljs-number">1</span>],f[k + (<span class="hljs-number">1</span>&lt;&lt;(j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i ++) &#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l ++;<br>        r ++;<br>        <span class="hljs-type">int</span> maxLength = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> newstart = - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = l;j &lt;= r;j ++) &#123;<br>            <span class="hljs-keyword">if</span>(position[j] &lt; l) &#123;<br>                maxLength = j - l + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                newstart = j;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(newstart ==  - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; maxLength &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> s = LOG(r - newstart + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> another = max(f[newstart][s],f[r - (<span class="hljs-number">1</span> &lt;&lt; s) + <span class="hljs-number">1</span>][s]);<br>        <span class="hljs-keyword">if</span>(another &gt; maxLength) &#123;<br>            maxLength = another;<br>        &#125;<br>        cout &lt;&lt; maxLength &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://oi-wiki.org/ds/fenwick/">树状数组</a></li><li><a href="https://oi-wiki.org/ds/sparse-table/">ST表</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Fenwick Tree</tag>
      
      <tag>Sparse Table</tag>
      
      <tag>RMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic6</title>
    <link href="/2025/03/28/Mathematical-Logic6/"/>
    <url>/2025/03/28/Mathematical-Logic6/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：稍有强度的一周，主要表现在…超级大的数学物理数理逻辑强度，但感觉经过3、4天的摸爬滚打，基本上还是搞明白了😇还有平安度过的XZJT（感觉还是挺成功的？maybe）继续加油！">Before：稍有强度的一周，主要表现在…超级大的数学物理数理逻辑强度，但感觉经过3、4天的摸爬滚打，基本上还是搞明白了😇还有平安度过的XZJT（感觉还是挺成功的？maybe）继续加油！</h5><h5 id="ps：昨天小姐姐double-happy了🥰🥰">ps：昨天小姐姐double happy了🥰🥰</h5><h1>Mathematical Logic 6</h1><h2 id="Call-back-Introduction-to-Sequent-Calculus">Call back: Introduction to Sequent Calculus</h2><p><strong>10 Basic Rules</strong></p><ol><li class="lvl-3"><p>Antecedent</p></li><li class="lvl-3"><p>Assumption</p></li><li class="lvl-3"><p>Case Analysis</p></li><li class="lvl-3"><p>Contradiction</p></li><li class="lvl-3"><p>V-introduction in antecedent</p></li><li class="lvl-3"><p>V-introduction in succedent</p></li><li class="lvl-3"><p>∃ -introduction in succedent</p></li><li class="lvl-3"><p>∃ -introduction in antecedent</p></li><li class="lvl-3"><p>Equality</p></li><li class="lvl-4"><p>Substitution</p></li></ol><p>Every Basic Rules is correct.(can be proved)</p><p><strong>Derived Rules 1</strong></p><ol><li class="lvl-3"><p>Excluded middle</p></li><li class="lvl-3"><p>Modified Contradiction</p></li><li class="lvl-3"><p>Chain Deduction</p></li></ol><p><strong>Derived Rules 2</strong><br>Modus Ponens<br>$\Gamma \vdash \varphi \rightarrow \psi $<br>$\Gamma \vdash \varphi$<br>—————————<br>$\Gamma \vdash \psi$<br><strong>Derived Rules 3</strong><br>1.Symmetry of $\equiv$<br>$\Gamma \vdash t_1 \equiv t_2$<br>—————————<br>$\Gamma \vdash t_2 \equiv t_1$</p><p>2.Transitivity of $\equiv$<br>$\Gamma \vdash t_1 \equiv t_2$<br>$\Gamma \vdash t_2 \equiv t_3$<br>—————————<br>$\Gamma \vdash t_1 \equiv t_3$</p><p>3.For n-ary relation symbol R $\in$ S<br>can be proved by using Substitution Lemma<br>$\Gamma \vdash R t_1 \ldots t_n  $<br>$\Gamma \vdash t_1 \equiv t’_1 $<br>$\Gamma \vdash t_2 \equiv t’_2 $<br>$\cdots \cdots$<br>$\Gamma \vdash t_n \equiv t’_n $<br>—————————<br>$\Gamma \vdash R t’_1 \ldots t’_n$</p><p>4.For n-ary function symbol R $\in$ S<br>can also be proved by using Substitution Lemma<br>$\Gamma \vdash t_1 \equiv t’_1 $<br>$\Gamma \vdash t_2 \equiv t’_2 $<br>$\cdots \cdots$<br>$\Gamma \vdash t_n \equiv t’_n $<br>—————————<br>$\Gamma \vdash f t_1 \ldots t_n \equiv f t’_1 \ldots t’_n$</p><p><strong>Soundness</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Defintion</p></li><li class="lvl-2"><p>Lemma 1</p></li><li class="lvl-2"><p>Theorem 2(<strong>Soundness</strong>)<br>If $\Phi \vdash \varphi$,then $\Phi \vDash \varphi$</p></li></ul><p>Opposite is <strong>Completeness</strong> and we will prove it in later lessons.</p><h2 id="Consistency">Consistency</h2><p><strong>Defintion</strong><br><strong>$\Phi$ is consistent if there is no $\varphi$ such that both $\Phi$ ⊢ $\varphi$ and $\Phi$ ⊢ $\neg$$\varphi$. Otherwise,$\Phi$ is inconsistent.</strong></p><p><strong>Lemma3</strong>: $\Phi$ is inconsistent if and only if $\Phi \vdash \varphi$ for any formulas $\varphi$.<br>This can be proved by using <strong>Modified Contradiction</strong>.</p><p><strong>Lemma 4</strong>: $\Phi$ is consistent if and only if there is a $\varphi$ such that $\Phi \not\models \varphi$.<br>This can be proved by using <strong>Modified Contradiction</strong>.</p><p><strong>Lemma 5</strong>: $\Phi$ is consistent if and only if every finite $\Phi_0 \subset \Phi$</p><p><strong>Lemma 6</strong>: Every satisfiable $\Phi$ is consistent.<br>(Prove from the negative perspective using soundness and build a model)</p><p><strong>Lemma 7</strong>:<br>(1) $\Phi \vdash \varphi$ if and only if $\Phi \cup \neg\varphi$ is inconsistent.</p><p>Easy to prove.</p><p>(2) $\Phi \vdash \neg\varphi$ if and only if $\Phi \cup \varphi$ is inconsistent.</p><p>(3)If cons($\Phi$),then either cons($\Phi \cup \varphi$) or cons($\Phi \cup \neg\varphi$).</p><h2 id="So-the-end-of-Sequent-Calculus">So the end of Sequent Calculus.</h2><h2 id="Start-of-Question-2-What-makes-a-proof-correct">Start of Question 2: What makes a proof correct?</h2><p>能证的都是对的（soundness），对的都是能证的（Completeness完备性）。</p><p><strong>Theorem 8</strong><br>If $\Phi \models \varphi$,$\Phi \vdash \varphi$</p><p><strong>Theorem 9</strong><br>cons($\Phi$) implies that $\Phi$ is satisfiable.</p><h2 id="Term-Model（version-1）">Term Model（version 1）</h2><p>Define the term model $\mathcal{I}^\Phi(t)$ so that for every t $\in T^S$.<br>$\mathcal{I}^\Phi(t) = t$<br>把语法对象作为语义的universe<br>That is, the interpretation of an S-term $t$ is the syntax object $t \in T^S$ itself.</p><p><strong>Universe</strong>：A = $T^S$<br><strong>n-ary function symbol</strong>：<br>$f^A(t_1, \ldots, t_n) := f t_1 \ldots t_n.$</p><p><strong>n-ary relation symbol</strong>：<br>$R^A = {(t_1, \ldots, t_n) | \Phi \vdash R t_1 \ldots t_n}.$</p><p>$c^A := c$ and $\beta(v_i) := v_i$ for every variable $v_i$</p><p>But：we will meet a problem.<br>Let S = {f} where f is a function symbol and $\Phi:={fv_0 \equiv fv_1}$</p><ul class="lvl-0"><li class="lvl-2"><p>$\mathcal{I}^\Phi(fv_0) = fv_0 \neq fv_1 = \mathcal{I}^\Phi(fv_1)$(2 strings are not the same)</p></li><li class="lvl-2"><p>$\mathcal{I}^\Phi \models \Phi$ implies that $\mathcal{I}^\Phi(fv_0) = \mathcal{I}^\Phi(fv_1)$</p></li></ul><p><strong>Contradict!<strong>😢😰😢😰<br>To Overcome The Issue!<br>在项的集合上定义一个</strong>等价关系</strong>，define an equivalence relation ~ on $T^S$</p><p><strong>Let $t_1$, $t_2$ $\in T^S$.Then $t_1$ ~ $t_2$ if $\Phi \vdash t_1 \equiv t_2$.</strong><br>(Easy to prove equivalence relation)</p><p>Introduce the <strong>Equivalence Class of t</strong>.<br>For every $t \in T^S$ we define:<br>$\overline{t} := {t’ \in T^S \mid t’ \sim t}$</p><p>Through <strong>Derived Rules 3</strong>,we can prove that:</p><ul class="lvl-0"><li class="lvl-2"><p>For every $n$-ary function symbol $f \in S$ and terms $t_1 \sim t_1’, \ldots, t_n \sim t_n’$, we have<br>$f t_1 \cdots t_n \sim f t_1’ \cdots t_n’.$</p></li><li class="lvl-2"><p>For every $n$-ary relation symbol $R \in S$ and terms $t_1 \sim t_1’, \ldots, t_n \sim t_n’$, we have<br>$\Phi \vdash R t_1 \cdots t_n \iff \Phi \vdash R t_1’ \cdots t_n’.$</p></li></ul><p>So we will introduce…</p><h2 id="Term-Model（version-2）">Term Model（version 2）!!!</h2><p>The term structure for $\Phi$, denoted by $\mathfrak{T}^{\Phi}$, is defined as follows.</p><p>(i) The universe is ${T}^{\Phi} := {\overline{t} \mid t \in T^S}$.</p><p>(ii) For every $n$-ary relation symbol $R \in S$, and $\overline{t}_1, \ldots, \overline{t}_n \in T^{\Phi}$</p><p>$(\overline{t}_1, \ldots, \overline{t}_n)$ $\in {R}<sup>\mathfrak{T}</sup>{\Phi}  \text{if}  \Phi \vdash R t_1 \ldots t_n.$</p><p>(iii) For every $n$-ary function symbol $f \in S$, and $\overline{t}_1, \ldots, \overline{t}_n \in T^{\Phi}$</p><p>${f}<sup>\mathfrak{T}</sup>{\Phi}$ $(\overline{t}_1, \ldots, \overline{t}_n)$ := $\overline{f t_1 \ldots t_n}.$</p><p>(iv) For every constant $c \in S$<br>${c}<sup>\mathfrak{T}</sup>{\Phi}$ := $\overline{c}.$</p><p>And we still need an assignment:<br>$\mathfrak{\beta}^{\Phi}(v_i):= \overline{v_i}$</p><p>So we have the <strong>Heenkin’s term model</strong>:<br>$\mathfrak{I}<sup>{\Phi}$:=($\mathfrak{T}</sup>{\Phi},\mathfrak{\beta}^{\Phi}$)</p><p><strong>Lemma 11</strong>:<br>(1)For any $t$ $\in T^S$:<br>$\mathfrak{I}^{\Phi}(t) = \overline{t}$</p><p>(2)For every atomic $\varphi$<br>$\mathfrak{I}^{\Phi} \models \varphi \iff \Phi \vdash \varphi$</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic5</title>
    <link href="/2025/03/22/Mathematical-Logic5/"/>
    <url>/2025/03/22/Mathematical-Logic5/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：Raytracing-ing-Build-my-first-ppm-file-I-❤️-Computer-Graphics">Before：Raytracing ing!Build my first ppm file!I ❤️ Computer Graphics!</h5><p><img src="/img/First.png" alt="PPM Hello World!"></p><h1>Mathematical Logic 5 Left Proof of Substitution Lemma 替换引理 &amp; Sequent Calculus (I)  序列演算</h1><h2 id="Left-Proof-of-Substitution-Lemma-替换引理">Left Proof of Substitution Lemma 替换引理</h2><p>对于项的替换引理证明还是比较直观容易的：<br><img src="/img/Sub%E8%AF%81%E6%98%8E1.png" alt="项替换Proof"></p><p>但对于公式来说，需要对公式进行归纳，这就有一定的难度了（特别是对∃的证明），外加由于此博客的Markdown渲染器并未配好(upd:配好了，也是终于能用Tex了)，就偷个懒直接了lecture-notes的图了🤡<br><img src="/img/Sub%E8%AF%81%E6%98%8E2.png" alt="公式替换Proof"></p><h2 id="Sequent-Calculus-Basic-Defintion">Sequent Calculus  Basic Defintion</h2><p>把证明当作数学对象来研究，这里的<strong>Sequent Calculus</strong>就是一种我们建立起来的证明系统。从已有的antecedent得到新的succedent。<br>$<br>Γ ⊢ Δ<br>$ <br>Γ 是前提集合，Δ是结论集合而Sequent Calculus要做的就是，设计一个演算系统，通过一系列规则从已知的序列推导出新的序列。</p><h3 id="Sequent-Rule-序列规则的形式">Sequent Rule 序列规则的形式</h3><p>$<br>\frac{Γ_1  φ_1…Γ_n  φ_n}{Γ’  φ}<br>$</p><h3 id="Derivability-可推导性">Derivability 可推导性</h3><p>如果可以从 Γ 推出 $\phi$ ，则记作<br>$<br>⊢ \Gamma \phi<br>$<br>这称为可推导</p><p>如果存在<strong>有限</strong>个公式<br>$<br>\phi_1 \phi_2 … \phi_n \in \Phi<br>$<br>使得<br>$<br>⊢ \phi_1 \phi_2 … \phi_n \phi<br>$<br>则称作公式$\phi$可从公式集$\Phi$中形式化证明或推导，记作<br>$<br>\Phi ⊢ \phi<br>$</p><h3 id="Correctness-正确性">Correctness 正确性</h3><p>A sequent $\Gamma$ $\phi$ is correct if<br>$<br>{\psi | \psi \in \Gamma} ⊢ \phi<br>$<br>即我们需要序列$\Gamma$中的所有公式都满足$\phi$，才能得到$\Gamma$ ⊢ $\phi$<br>引入的规则必须保证只产生正确的序列</p><h2 id="Structure-Rules-结构规则">Structure Rules 结构规则</h2><h3 id="Antecedent-前提规则">Antecedent 前提规则</h3><p>$<br>\frac{Γ ⊢ φ}{Γ’ ⊢ φ} \quad Γ ⊆ Γ’<br>$<br>如果某个结论可以从一组前提中推导出来，那么它也可以从更大的前提集合中推导出来。我们可以在推导过程中增加前提</p><h3 id="Assumption">Assumption</h3><p>$<br>\frac{}{\Gamma \vdash \varphi} \quad \text{如果 } \varphi \in \Gamma<br>$<br>如果某个公式已经是前提集合的一部分，那么它可以直接作为结论。换句话说，假设规则允许我们直接从前提集合中&quot;提取&quot;已知的公式作为结论，而无需进一步的推导。</p><h2 id="Connective-Rules-连接词规则">Connective Rules 连接词规则</h2><h3 id="Case-Analysis-案例分析规则">Case Analysis 案例分析规则</h3><p>我觉得就是<strong>分类讨论</strong>（遍历所有情况）<br>$<br>\frac{\Gamma, \psi \vdash \varphi \quad \Gamma, \neg \psi \vdash \varphi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合和某个假设 𝜓可以推导出结论 𝜑，并且从前提集合和 ¬𝜓也可以推导出𝜑，那么可以直接从前提集合推导出𝜑</p><h3 id="Contradiction-矛盾规则">Contradiction 矛盾规则</h3><p>我觉得就是<strong>反证的思想推出矛盾</strong><br>$<br>\frac{\Gamma, \neg \varphi \vdash \psi \quad \Gamma, \neg \varphi \vdash \neg \psi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合和 ¬𝜑可以推导出 𝜓和 ¬𝜓，那么可以直接从前提集合推导出 𝜑。</p><h3 id="v-introduction-in-antecedent-析取引入规则-前提版">v-introduction in antecedent 析取引入规则(前提版)</h3><p>$<br>\frac{\Gamma, \varphi \vdash \chi \quad \Gamma, \psi \vdash \chi}{\Gamma, \varphi \vee \psi \vdash \chi}<br>$<br>如果无论 𝜑为真还是 𝜓为真，𝜒都成立，那么从 𝜑∨𝜓（即 𝜑或𝜓中至少有一个为真）也可以推导出 𝜒。</p><h3 id="v-introduction-in-succedent-析取引入规则-结论版">v-introduction in succedent 析取引入规则(结论版)</h3><p>$<br>\frac{\Gamma \vdash \varphi}{\Gamma \vdash \varphi \vee \psi} \quad \text{or} \quad \frac{\Gamma \vdash \psi}{\Gamma \vdash \varphi \vee \psi}<br>$<br>如果𝜑为真，则𝜑∨𝜓也为真；如果𝜓为真，则𝜑∨𝜓也为真；因此只要𝜑和𝜓中的一个为真，𝜑∨𝜓就为真</p><h2 id="Derived-Rules-派生规则（可通过结构规则、连接词规则证明）">Derived Rules 派生规则（可通过结构规则、连接词规则证明）</h2><h3 id="排中律-Law-of-Excluded-Middle">排中律 Law of Excluded Middle</h3><p>$<br>\vdash \varphi \vee \neg \varphi<br>$<br>对于任何命题 𝜑，$ \varphi \vee \neg \varphi$  总是为真。也就是说，任何命题要么为真，要么为假，不存在中间状态</p><h3 id="修改的矛盾规则-Modified-Contradiction">修改的矛盾规则 Modified Contradiction</h3><p>$<br>\frac{\Gamma \vdash \psi \quad \Gamma \vdash \neg \psi}{\Gamma \vdash \varphi}<br>$<br>如果从前提集合 $\Gamma $ 可以推导出 $ \psi $，并且从前提集合 $ \Gamma $ 也可以推导出 $ \neg \psi $，那么可以直接从 $ \Gamma $ 推导出 $ \varphi $。</p><h3 id="链式推理-Chain-Deduction">链式推理 Chain Deduction</h3><p>$<br>\frac{\Gamma \vdash \varphi \quad \Gamma, \varphi \vdash \psi}{\Gamma \vdash \psi}<br>$<br>通过中间步骤 $ \varphi $，可以将前提集合 $ \Gamma $ 与结论 $ \psi $ 连接起来，形成一个推理链。</p><h2 id="Quantifier-Rules-量词规则">Quantifier Rules 量词规则</h2><h3 id="∃-introduction-in-succedent-结论版">∃-introduction in succedent(结论版)</h3><p>$<br>\frac{\Gamma \vdash \varphi(t/x)}{\Gamma \vdash \exists x \varphi}<br>$<br>如果存在一个具体的项  t ，使得 $ \varphi(t/x) $ 成立，那么可以推导出存在量词 $ \exists x \varphi $。</p><h3 id="∃-introduction-in-antecedent-前提版">∃-introduction in antecedent(前提版)</h3><p>$<br>\frac{\Gamma, \varphi(y/x) \vdash \psi}{\Gamma, \exists x \varphi \vdash \psi} \quad \text{如果 } y \notin \text{free}(\Gamma \cup {\exists x \varphi, \psi})<br>$<br>通过引入一个新的变量  y ，可以将存在量词 $ \exists x \varphi $ 引入前提中，从而推导出 $ \psi $。<br><strong>变量y选取的重要性</strong>（如果变量选取不当，可能会导致逻辑错误）<br>y 必须是一个新变量，不能在其他地方自由出现</p><h2 id="Equality-Rules-等式规则">Equality Rules 等式规则</h2><h3 id="Equality-等式的基本规则">Equality 等式的基本规则</h3><p>$<br>t \equiv t<br>$<br>等式的基本规则表明任何项 𝑡 都等于它自身。</p><h3 id="Substitution-替换规则">Substitution 替换规则</h3><p>$<br>\frac{\Gamma \vdash t \equiv t’ \quad \Gamma \vdash \varphi(t/x)}{\Gamma \vdash \varphi(t’/x)}<br>$<br>如果两个项  t  和  t’  相等，那么在任何公式中，可以用  t’  替换  t ，而不改变公式的真值。</p><h2 id="Soundness-可靠性定理">Soundness 可靠性定理</h2><p>$<br>\text{如果 } \Phi \vdash \varphi, \text{ 则 } \Phi \models \varphi.<br>$<br>如果从前提集合 $ \Phi $ 可以形式化推导出 $ \varphi $，那么 $ \varphi $ 在语义上也成立。也就是说，形式化推导的结果在语义上是正确的。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic4</title>
    <link href="/2025/03/14/Mathematical-Logic4/"/>
    <url>/2025/03/14/Mathematical-Logic4/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"><a href="#Before：昨天立的flag要在这周结束前finish-map，经过昨天一下午-一晚上和今天一上午-一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket-System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜" class="headerlink" title="Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜"></a>Before：昨天立的flag要在这周结束前finish map，经过昨天一下午+一晚上和今天一上午+一下午艰难地debug（快被leak卡死了呜呜呜），终于过啦！至此，STLite-2025这个轻量级STL库的大作业全部完成🥳🥳🥳比ddl提前了一整个月，本学期只剩下最后一个大作业——Ticket System了，所以：现在可以美美开始BPT啦（bushi）but，数理逻辑还是好抽象啊😣😣😣鼠鼠菜菜</h5><h5 id="今天是3月14日，𝜋节。2022-03-14-2025-03-14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。"><a href="#今天是3月14日，𝜋节。2022-03-14-2025-03-14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。" class="headerlink" title="今天是3月14日，𝜋节。2022.03.14 - 2025.03.14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。"></a>今天是3月14日，𝜋节。2022.03.14 - 2025.03.14，整整三年了，还是没放下，要带着遗憾一直到老了…忽远忽近，忽明忽暗。过去那么久了，还是忘不了。永远是我的青春，祝你一路顺风。</h5><h1 id="Mathematical-Logic-4-同构引理的证明-替换"><a href="#Mathematical-Logic-4-同构引理的证明-替换" class="headerlink" title="Mathematical Logic 4 同构引理的证明 &amp; 替换"></a>Mathematical Logic 4 同构引理的证明 &amp; 替换</h1><h2 id="Call-back-previous-一阶逻辑语义"><a href="#Call-back-previous-一阶逻辑语义" class="headerlink" title="Call back previous 一阶逻辑语义"></a>Call back previous 一阶逻辑语义</h2><p><strong>同构</strong><br>存在一个A -&gt; B 的映射满足：</p><ol><li>是双摄</li><li>保持关系（n元关系运算符）</li><li>保持运算（n元函数运算符）</li><li>保持常量（常数c）</li></ol><p>则结构A、结构B同构</p><p>在上周的作业中，我们证明了同构是一种等价关系。回忆，等价关系需要满足三个条件：</p><ol><li>自反性</li><li>对称性</li><li>传递性</li></ol><h2 id="同构引理的证明"><a href="#同构引理的证明" class="headerlink" title="同构引理的证明"></a>同构引理的证明</h2><p>Recall:<br>A、B是2个同构的S-结构，那么对于所有S-sentence 𝜑，有：</p><p>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑 </p><p>Prof:<br>由重合引理可知：<br>A |&#x3D; 𝜑 ⟺ (A,β) |&#x3D; 𝜑<br>B |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>so A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑  ⟺  (A,β) |&#x3D; 𝜑 ⟺ (B,β’) |&#x3D; 𝜑</p><p>定义β^𝜋(x) :&#x3D; 𝜋(β(x))<br>那么我们要证：<br>(A,β) |&#x3D; 𝜑 ⟺ (B,β^𝜋) |&#x3D; 𝜑 (𝜑 是任意S-公式)<br>&#x2F;&#x2F; 这不就从句子推广到公式上了嘛 </p><p>也就是要证明：<br>I:&#x3D; (A,β) I^𝜋:&#x3D; (B,β^𝜋)<br>𝜋(I(t)) &#x3D; I^𝜋(t)</p><p>这里改写成解释，也就可以进行结构归纳法（对公式的归纳了）<br>略</p><h2 id="项的替换-Substitution"><a href="#项的替换-Substitution" class="headerlink" title="项的替换 Substitution"></a>项的替换 Substitution</h2><p>设t 是一个S-term，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义项的替换：<br><img src="/img/%E6%9B%BF%E6%8D%A2.png" alt="替换"></p><p>(a)如果t &#x3D; x是一个变量，那么：<br><img src="/img/%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="变量替换"></p><p>(b)如果t &#x3D; c是一个常数，那么：<br><img src="/img/%E5%B8%B8%E9%87%8F%E6%9B%BF%E6%8D%A2.png" alt="常量替换"></p><p>(c)对于一个函数项<br><img src="/img/%E5%87%BD%E6%95%B0%E9%A1%B9%E6%9B%BF%E6%8D%A2.png" alt="函数项替换"></p><h2 id="公式上的替换"><a href="#公式上的替换" class="headerlink" title="公式上的替换"></a>公式上的替换</h2><p>设𝜑 是一个S-formula，x0,…,xr是变量，且t0,…,tr是S-terms。那么我们可以这样定义：<br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A21.png" alt="公式替换"><br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A22.png" alt="公式替换"></p><h2 id="赋值上的替换（对于自由变量）"><a href="#赋值上的替换（对于自由变量）" class="headerlink" title="赋值上的替换（对于自由变量）"></a>赋值上的替换（对于自由变量）</h2><p><img src="/img/%E8%B5%8B%E5%80%BC%E6%9B%BF%E6%8D%A2.png" alt="赋值替换"></p><h2 id="替换引理"><a href="#替换引理" class="headerlink" title="替换引理"></a>替换引理</h2><p>替换引理分为2个部分：</p><h3 id="项的替换引理"><a href="#项的替换引理" class="headerlink" title="项的替换引理"></a>项的替换引理</h3><p>对一个项 𝑡 进行替换后，其解释等于在原解释 𝐼 的基础上，将变量x0,…,xr替换为项t0,…,tr的解释<br><img src="/img/%E9%A1%B9%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%90%86.png" alt="项的替换引理"></p><h3 id="公式的替换引理"><a href="#公式的替换引理" class="headerlink" title="公式的替换引理"></a>公式的替换引理</h3><p>对一个公式 𝜑 进行替换后，其真值等于在原解释 𝐼 的基础上，将变量x0,…,xr替换为项t0,…,tr的解释后的真值<br><img src="/img/%E5%85%AC%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%BC%95%E7%90%86.png" alt="公式的替换引理"></p><h3 id="二者均为语法替换-⟺-语义更新"><a href="#二者均为语法替换-⟺-语义更新" class="headerlink" title="二者均为语法替换 ⟺  语义更新"></a>二者均为语法替换 ⟺  语义更新</h3>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Of DS——Monotonic Stack &amp; Queue</title>
    <link href="/2025/03/13/AlgorithmOfDS1/"/>
    <url>/2025/03/13/AlgorithmOfDS1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：最近在de-STLite的最后一个数据结构map。周二用一个下午-一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️">Before：最近在de STLite的最后一个数据结构map。周二用一个下午+一个晚上搓完后，开始了《漫长》的debug环节，目前来看问题出在erase上（AVL倒也合理），RE麻了…😰😰😰遂开始了算法学习呜呜呜。立个小目标，这周结束前把map过了吧求求了😢😢😢最近还是很开心的，也很轻松，希望能轻松一学期（bushi🤣🤣🤣）今天知道了一件事，让我觉得人间值得😣😉☺️</h5><h1>Algorithm of Data Structure 1 单调栈&amp;单调队列&amp;栈模拟递归</h1><h2 id="单调栈">单调栈</h2><p>定义：栈内元素满足某种单调性质，可以单增也可以单减</p><p>在处理每个元素时，将其与栈顶元素进行比较，如果当前元素大于（或小于）栈顶元素，则将栈顶元素出栈，直到满足单调性质为止。然后，将当前元素入栈，继续处理下一个元素（<strong>当前元素必须入栈</strong>）</p><p>单调栈可以快速找到每个元素的下一个更大（或更小）元素，时间复杂度为O(n)（n为序列的长度）</p><p>具体来说，<strong>单调递增栈可用于寻找下一个更小元素，而单调递减栈可用于寻找下一个更大元素</strong>，并且只需要遍历整个序列一次</p><p>Example：找到数列中每个元素下一个比它大的元素下标（1 — base）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈顶位置</span><br>stack[top] = <span class="hljs-number">0</span>; <span class="hljs-comment">//a[0]入栈  stack数组记录栈内元素下标</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span> &amp;&amp; a[stack[top]] &lt; a[i])&#123;<br>        ans[stack[top]] = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//记录答案</span><br>        top --; <span class="hljs-comment">//当前栈顶元素出栈</span><br>    &#125;<br>    stack[++ top] = i;<br>&#125;<br><span class="hljs-keyword">while</span>(top &gt;=<span class="hljs-number">0</span>)&#123;<br>    ans[stack[top --]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//栈内剩余元素不存在下一个比它大的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：需要一个stack数组记录栈内情况，一个top记录栈顶位置，一个a存储原本序列数据，和一个ans存储答案</p><h2 id="单调栈例题">单调栈例题</h2><p><a href="https://www.luogu.com.cn/problem/P1901">luogu P1901</a></p><ul class="lvl-0"><li class="lvl-2"><p>某地有N个能量发射站排成一行，每个发射站i都有不相同的高度Hi，并能向两边（两端的发射站只能向一边）同时发射能量值为Vi的能量，发出的能量只被两边最近的且比它高的发射站接收。</p></li><li class="lvl-2"><p>显然，每个发射站发出的能量有可能被0~2个其他发射站所接受。</p></li><li class="lvl-2"><p>请计算出接收最多能量的发射站接收的能量是多少。</p></li></ul><p>小黄题，15分钟速通😋 Strong女也只能切黄题了呜呜呜</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>h2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>stack2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>v2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>ans2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total1[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>total2[1000005];<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>main() &#123;<br>   <span class="hljs-built_in"> int </span>n;<br>    cin &gt;&gt; n;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        cin &gt;&gt; h1[i];<br>        cin &gt;&gt; v1[i];<br>    &#125;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>        h2[i] = h1[n - 1 -i];<br>        v2[i] = v1[n - 1- i];<br>    &#125;<br>   <span class="hljs-built_in"> int </span>top1 = 0;<br>   <span class="hljs-built_in"> int </span>top2 = 0;<br>    stack1[top1] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top1 &gt;= 0 &amp;&amp; h1[stack1[top1]] &lt; h1[i]) &#123;<br>            ans1[stack1[top1]] = i;<br>            total1[i] += v1[stack1[top1]];<br>            top1 --;<br>        &#125;<br>        stack1[++ top1] = i;<br>    &#125;<br>    while(top1 &gt;= 0) &#123;<br>        ans1[stack1[top1 --]] = -1;<br>    &#125;<br><br>    stack2[top2] = 0;<br>    for(int i = 1;i &lt; n;i ++) &#123;<br>        while(top2 &gt;= 0 &amp;&amp; h2[stack2[top2]] &lt; h2[i]) &#123;<br>            ans2[stack2[top2]] = i;<br>            total2[i] += v2[stack2[top2]];<br>            top2 --;<br>        &#125;<br>        stack2[++ top2] = i;<br>    &#125;<br>    while(top2 &gt;= 0) &#123;<br>        ans2[stack2[top2 --]] = -1;<br>    &#125;<br><br>   <span class="hljs-built_in"> int </span>maxE = 0;<br>    for(int i = 0;i &lt; n;i ++) &#123;<br>       <span class="hljs-built_in"> int </span>current = total1[i] + total2[n - 1 - i];<br>        if(current &gt; maxE) &#123;<br>            maxE = current;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; maxE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><p>高效地维护队列中元素的单调性（递增或递减），同时支持在队列两端的插入和删除操作</p><ul class="lvl-0"><li class="lvl-2"><p>可在队首出队</p></li><li class="lvl-2"><p>仅在队尾入队</p></li><li class="lvl-2"><p>如果影响单调性，可能从队尾出队</p></li></ul><p>省流：其实是一个双端队列（deque）（这不是隔壁这次大作业嘛🤣有福了）</p><p><strong>它通常用于解决需要在一个滑动窗口（或固定长度的子数组）内找到最大值或最小值的问题</strong></p><ul class="lvl-0"><li class="lvl-2"><p>插入元素：当新元素进入窗口时，从队列尾部移除所有小于新元素的元素，然后将新元素插入队列尾部。</p></li><li class="lvl-2"><p>移除元素：当元素离开窗口时，如果它是队列头部的元素，则从队列头部移除。</p></li><li class="lvl-2"><p>获取最值：队列头部的元素始终是当前窗口的最大值（或最小值，取决于单调性）</p></li></ul><p>可实现在O(1)的时间复杂度下获得最值比如我们现在要一个递增的单调队列</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> minFront = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> minBack = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++)&#123;<br>    <span class="hljs-built_in">num</span>[i] = read();<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; minWin[minFront] &lt;= i - k)&#123; <span class="hljs-comment">//队头指针小于等于队尾指针 &amp;&amp; 队头元素索引已经不在窗口范围内</span><br>        ++ minFront;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(minBack &gt;= minFront &amp;&amp; <span class="hljs-built_in">num</span>[i] &lt; minWin[minBack])&#123;<br>        -- minBack; <span class="hljs-comment">// 将破坏单调性的元素出列</span><br>    &#125;<br>    <span class="hljs-comment">//加入队列</span><br>    minWin[++ minBack] = <span class="hljs-built_in">num</span>[i];<br>    <span class="hljs-keyword">if</span>(i &gt;= k)&#123;<br>        cout &lt;&lt; minWin[minFront];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列例子">单调队列例子</h2><p>小Z的家门口种了N棵树，第i棵树在目标点xi，高度hi。如果一棵树左边D距离内和右边D距离内有高度至少是它的两倍的树，那么小Z认为这棵树不够茁壮。春天到了，他想给不够茁壮的树多施点肥，请你帮忙数数有几棵不够茁壮的树。</p><p>思路：长度为D（若不足D 也可）的数组（窗口），移动即可。两个方向都扫一遍</p><h2 id="栈模拟递归">栈模拟递归</h2><p>递归过程：</p><ol><li class="lvl-3"><p>执行代码块0</p></li><li class="lvl-3"><p><strong>保存现场准备进入下一层</strong></p></li><li class="lvl-3"><p>接受下层返回的数据</p></li><li class="lvl-3"><p><strong>恢复现场</strong></p></li><li class="lvl-3"><p>继续执行代码块1</p></li></ol><p>直接用递归程序实现递归时，第二步和第四步都是编译器在帮助你完成而非递归实现，我们期望：自己用实现保存现场和恢复现场</p><p>用栈模拟递归的优势在于：</p><ol><li class="lvl-3"><p>避免递归深度限制</p></li><li class="lvl-3"><p>更直观的控制流程</p></li><li class="lvl-3"><p>避免递归调用的开销</p></li></ol><h2 id="END">END</h2><p>你可以当我哑巴一样你不会看见我的抵抗请别怕我受伤 我自己会圆场</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Monotonic Stack</tag>
      
      <tag>Monotonic Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic3</title>
    <link href="/2025/03/08/Mathematical-Logic3/"/>
    <url>/2025/03/08/Mathematical-Logic3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"><a href="#Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣" class="headerlink" title="Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣"></a>Before：下课就去捞！3周没捞了😋😋😋上大学后捞的频率大幅增长🤣🤣🤣</h5><p>🐖🐖🐖</p><h1 id="Mathematical-Logic-3-重合引理-同构引理"><a href="#Mathematical-Logic-3-重合引理-同构引理" class="headerlink" title="Mathematical Logic 3 重合引理 同构引理"></a>Mathematical Logic 3 重合引理 同构引理</h1><h2 id="概念回顾"><a href="#概念回顾" class="headerlink" title="概念回顾"></a>概念回顾</h2><p><strong>项</strong>是由<strong>变量、常量符号和函数符号</strong>通过递归方式构造的表达式。<br><strong>公式</strong>（formula）是由<strong>项</strong>通过<strong>谓词符号、逻辑连接词和量词构造</strong>的表达式。<br><strong>结构</strong>由<strong>域</strong>和<strong>解释函数</strong>组成。<br><strong>解释</strong>由<strong>结构</strong>和<strong>赋值函数</strong>（将自由变量映射到域中的元素）组成。</p><ul><li>原子公式：包括等式公式、谓词公式R</li><li>逻辑连接词：¬、∧、∨、→、↔</li><li>量词：∀xφ (x是变量，φ 是公式)、∃xφ (x是变量，φ 是公式)</li></ul><p>我们可以解释term、解释formula、解释sentence</p><h2 id="结构归纳法（对公式进行归纳）"><a href="#结构归纳法（对公式进行归纳）" class="headerlink" title="结构归纳法（对公式进行归纳）"></a>结构归纳法（对公式进行归纳）</h2><p>公式的归纳基于公式的结构，即公式的构造方式。由于公式是通过递归方式定义的（<strong>从原子公式逐步构造出复杂公式</strong>），因此我们可以使用结构归纳法来证明公式的性质。<br>公式的归纳证明通常分为以下几个步骤：</p><ul><li>证明性质𝑃对所有原子公式成立</li><li>归纳步骤：假设性质𝑃对某些公式𝜑和𝜓成立（归纳假设），然后证明𝑃对通过这些公式构造的复杂公式也成立。</li></ul><h2 id="重合引理（The-Coincidence-Lemma）"><a href="#重合引理（The-Coincidence-Lemma）" class="headerlink" title="重合引理（The Coincidence Lemma）"></a>重合引理（The Coincidence Lemma）</h2><p>设I1(A1,β1),I2(A2,β2)是2个S-解释，且满足以下条件：</p><ul><li>A1 &#x3D; A2（解释的域相同）</li><li>对于S：&#x3D; S1 ∩ S2中的每个符号，它们在A1、A2中的解释相同</li></ul><p>那么：</p><ul><li>对于任何S项t，如果β1(x) &#x3D; β2(x)对于t中的所有变量x成立，则I1(x) &#x3D; I2(x)<br>即需要满足<strong>结构的解释相同</strong>和<strong>变量的赋值相同</strong></li><li>对于任何S公式𝜑，如果β1(x) &#x3D; β2(x)对于𝜑中的所有自由变量x成立，则I1 |&#x3D; 𝜑 当且仅当 I2 |&#x3D; 𝜑<br>即需要满足<strong>结构的解释相同</strong>和<strong>自由变量的赋值相同</strong></li></ul><p>证明依赖于<strong>结构归纳法</strong></p><h2 id="同构引理（The-Isomorphism-Lemma）"><a href="#同构引理（The-Isomorphism-Lemma）" class="headerlink" title="同构引理（The Isomorphism Lemma）"></a>同构引理（The Isomorphism Lemma）</h2><p>首先给出<strong>同构</strong>的定义：<br>在模型论中，同构是指两个结构之间存在一个<strong>双射</strong>（bijection），这个双射<strong>保持了结构中的所有关系、函数和常量</strong>。<br>具体来说：<br>设A(A,I)和B(B,J)是2个S—结构，其中A和B是它们的域，I和J是解释函数。<br>一个同构𝜋：A → B是一个双射，满足以下条件：</p><ul><li>保持关系<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%85%B3%E7%B3%BB.png" alt="保持关系"></li><li>保持运算<br><img src="/img/%E4%BF%9D%E6%8C%81%E8%BF%90%E7%AE%97.png" alt="保持运算"></li><li>保持常量<br><img src="/img/%E4%BF%9D%E6%8C%81%E5%B8%B8%E9%87%8F.png" alt="保持常量"></li></ul><p>如果存在这样的双射𝜋，则称结构A和B是同构的，记作A≅B<br>例子：群论 &amp; 图论中的同构</p><p>同构的性质：</p><ul><li>自反性（Reflexivity）：A ≅ A</li><li>对称性（Symmetry）：若A ≅ B，则B ≅ A</li><li>传递性（Transitivity）：若A ≅ B 且 B ≅ C ，则A ≅ C</li></ul><p>因此，同构是一个<strong>等价关系</strong></p><p>那么同构引理可以表示为：<br>如果A、B是两个同构的S-结构，则对于任何<strong>S-句子</strong>𝜑，有<br>A |&#x3D; 𝜑  ⟺  B |&#x3D; 𝜑<br>这意味着，同构的结构在一阶逻辑中无法被区分，它们满足相同的句子。</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms3</title>
    <link href="/2025/03/06/Introduction-to-Algorithms3/"/>
    <url>/2025/03/06/Introduction-to-Algorithms3/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"><a href="#Before-哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢" class="headerlink" title="Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢"></a>Before: 哎帮人debug好累啊，边改别人的代码边学AVL，也是无敌了。我到底要不要见她一面呢？感觉错过了就是一辈子😢😢😢</h5><h1 id="Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL"><a href="#Introduction-to-Algorithms-3-Balanced-Binary-Search-Tree——AVL" class="headerlink" title="Introduction to Algorithms 3 Balanced Binary Search Tree——AVL"></a>Introduction to Algorithms 3 Balanced Binary Search Tree——AVL</h1><p>First, recall an important definition of <strong>Height of a Node</strong>: <strong>length of the longest downward path to a leaf</strong></p><h2 id="The-Importance-of-Being-Balanced"><a href="#The-Importance-of-Being-Balanced" class="headerlink" title="The Importance of Being Balanced"></a>The Importance of Being Balanced</h2><p>As we talk about last time,BST suppports insert&#x2F;delete&#x2F;min&#x2F;max&#x2F;next_larger&#x2F;next_smaller or in a time complexity of <strong>O(h)</strong>.But that’s not what we want.Somehow if h equals to n,it’s gonna be really bad.</p><p>We love this tree😋😋😋：<br><img src="/img/PerfectTree.png" alt="Perfectly Balanced Binary Tree"></p><p>We hope to do some adjustments to the tree so that h can equal to <strong>logN</strong>.</p><h2 id="AVL-Trees——Adel’son-Vel’skii-Landis-1962"><a href="#AVL-Trees——Adel’son-Vel’skii-Landis-1962" class="headerlink" title="AVL Trees——Adel’son-Vel’skii &amp; Landis 1962"></a>AVL Trees——Adel’son-Vel’skii &amp; Landis 1962</h2><h3 id="Main-Defintion"><a href="#Main-Defintion" class="headerlink" title="Main Defintion:"></a>Main Defintion:</h3><p>For every node,require <strong>heights</strong> of left &amp; right children to differ by at most <strong>± 1</strong>.</p><ul><li>We mark nil trees as height <strong>-1</strong>（quite smart cuz -1 + 1 &#x3D; 0）</li><li>Each nodes stores its height</li></ul><p><img src="/img/AVL%E4%BE%8B%E5%AD%90.png" alt="An example of an AVL tree"></p><h3 id="Balance"><a href="#Balance" class="headerlink" title="Balance"></a>Balance</h3><p>Consider the largest height of an AVL tree with N nodes.(worst time complexity)<br>Equalently,we can consider <strong>the minimun node numbers of an AVL tree with height h</strong>!<br>Great thoughts!</p><p>We can do a rough Maths proof:<br>N_h &#x3D; N_(h - 1) + N_(h - 2) &gt; 2N_(h - 2)<br>&#x3D;&gt; N_h &gt; 2^(h&#x2F;2)<br>&#x3D;&gt; h &lt; 2 log(N_h)<br>So proved that h is alogN(a is a parameter)</p><p>Theoretical computer scientists can do this more accurately,like what the picture below shows using Fibonacci:<br><img src="/img/AVLproof.png" alt="The secret behind the logN height of the AVL tree"></p><h3 id="AVL-insert"><a href="#AVL-insert" class="headerlink" title="AVL insert"></a>AVL insert</h3><p>1.insert as in simple BST(just the normal one)<br>2.<strong>work your way up tree, restoring AVL property</strong>(the most important step of building the AVL tree)</p><p>Each Step of the famous <strong>AVL Rotation</strong>:</p><ul><li><p>suppose x is lowest node violating(违背) AVL</p></li><li><p>assume x is right-heavy (left case symmetric)</p></li><li><p>if x’s right child is right-heavy or balanced:<br><img src="/img/AVL%E6%97%8B%E8%BD%AC1.png" alt="AVL Inserting Balance"></p></li><li><p>else: follow steps<br><img src="/img/AVL%E6%97%8B%E8%BD%AC2.png" alt="AVL Inserting Balance"></p></li><li><p>then continue up to x’s grandparent, greatgrandparent</p></li></ul><h2 id="Other-Balanced-Trees"><a href="#Other-Balanced-Trees" class="headerlink" title="Other Balanced Trees"></a>Other Balanced Trees</h2><ul><li>B-Trees&#x2F;2-3-4 Trees Bayer and McCreight 1972 (see CLRS 18)</li><li>BB[α] Trees Nievergelt and Reingold 1973</li><li>Red-black Trees CLRS Chapter 13</li><li>Splay-Trees Sleator and Tarjan 1985</li><li>Skip Lists Pugh 1989</li><li>Scapegoat Trees Galperin and Rivest 1993</li><li>Treaps Seidel and Aragon 1996</li></ul><h2 id="Comparison-with-Heap"><a href="#Comparison-with-Heap" class="headerlink" title="Comparison with Heap"></a>Comparison with Heap</h2><p><img src="/img/HeapAVL1.png"><br><img src="/img/HeapAVL2.png"></p><h2 id="End-Start-BHW-3-Map"><a href="#End-Start-BHW-3-Map" class="headerlink" title="End(Start BHW 3 Map~~~)"></a>End(Start BHW 3 Map~~~)</h2>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Tree</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>AVL</tag>
      
      <tag>Balanced Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-Algorithms2</title>
    <link href="/2025/03/01/Introduction-to-Algorithms2/"/>
    <url>/2025/03/01/Introduction-to-Algorithms2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：风止于秋水，我止于你"><a href="#Before：风止于秋水，我止于你" class="headerlink" title="Before：风止于秋水，我止于你"></a>Before：风止于秋水，我止于你</h5><h1 id="Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort"><a href="#Introduction-to-Algorithms-2-Binary-Search-Tree-Binary-Search-Sort" class="headerlink" title="Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort"></a>Introduction to Algorithms 2 Binary Search Tree &amp; Binary Search Sort</h1><h2 id="Base-on"><a href="#Base-on" class="headerlink" title="Base on ?"></a>Base on ?</h2><p><strong>Runway Reservation System</strong>!!!(My favourite plane! We’re saved!)</p><p><img src="/img/Runway.png" alt="Runway Reservation System"></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Each node x in the binary tree has a key <strong>key(x)</strong>.Nodes other than the root have a <strong>parent p(x)</strong>.Nodes may have a left child <strong>left(x)</strong> and&#x2F;or a right child <strong>right(x)</strong>.<br>ps：ALL POINTERS!Unlike in the Heap.</p><p><strong>Characteristics</strong>：for any node x, for all nodes y in the left subtree of x, key(y) ≤ key(x). For all nodes y in the right subtree of x key(y) ≥ key(x).</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>As the picture shows below🤓<br><img src="/img/BST%E6%8F%92%E5%85%A5.png" alt="BST insert operation"></p><p>Under the problem,we need to do the “Within K minutes Check” before inserting.If doesn’t follow,then stop the insertion.</p><h2 id="Find-Exists-find-val"><a href="#Find-Exists-find-val" class="headerlink" title="Find Exists : find(val)"></a>Find Exists : find(val)</h2><p>Follow left and right pointers until you find it or hit NIL.</p><h2 id="Find-the-minimum-element-in-a-BST-findmin"><a href="#Find-the-minimum-element-in-a-BST-findmin" class="headerlink" title="Find the minimum element in a BST : findmin()"></a>Find the minimum element in a BST : findmin()</h2><p>Just go left until you can’t.</p><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><p>All the operations above have an O(h) time complexity.<br>ps: <strong>h is the height of BST</strong></p><p>We may find a problem: somehow in a tricky (or abstract) way of insertion, the BST may turn to a <strong>List</strong>.So the complexity will be O(n),but we hope O(logn).😣😣😣</p><p>We’re gonna talk about it next time in the <strong>AVL Chapter</strong>😋😋😋<br>Balanced BSTs to the rescue in the next lecture!</p><h2 id="Find-the-next-larger-element-next-larger-x"><a href="#Find-the-next-larger-element-next-larger-x" class="headerlink" title="Find the next larger element: next_larger(x)"></a>Find the next larger element: next_larger(x)</h2><p>IF right child is not NIL,return minimun(x -&gt; right)<br>    else y &#x3D; parent(x)</p><pre><code class="hljs">while y not NIL and x = right(y)    x =  y    y = parent(y)return y;</code></pre><h2 id="How-many-planes-are-scheduled-to-land-at-times-≤-t"><a href="#How-many-planes-are-scheduled-to-land-at-times-≤-t" class="headerlink" title="How many planes are scheduled to land at times ≤ t?"></a>How many planes are scheduled to land at times ≤ t?</h2><p>Algorithm:<br>1.Walk down tree to find desired time( find t pos )<br>2.Add in nodes that are smaller<br>3.Add in subtree sizes to the left( record the size of the subtrees)</p><h2 id="附上早上手写的BST"><a href="#附上早上手写的BST" class="headerlink" title="附上早上手写的BST"></a>附上早上手写的BST</h2><p>（由于赶时间就没写类模板了，int型BST凑合看看吧😢）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by JaneZ on 2025/3/2.</span><br><span class="hljs-comment">//</span><br>#ifndef BST_H<br>#define BST_H<br>#include &lt;cstdio&gt;<br><br>class BinarySearchTree &#123;<br>private:<br>    struct treeNode &#123;<br>        treeNode *parent;<br>        treeNode *left;<br>        treeNode *right;<br>        int count; <span class="hljs-comment">//单个结点出现次数</span><br>        int size; <span class="hljs-comment">//以该结点为根 的子树大小</span><br>        int value; <span class="hljs-comment">//存储的值，这里以整数为例</span><br><br>        treeNode(treeNode *p = nullptr,treeNode *l = nullptr,treeNode *r = nullptr,int c = <span class="hljs-number">1</span>,int s = <span class="hljs-number">1</span>,int v = <span class="hljs-number">0</span>):<br>        parent(p),left(l),right(r),count(c),size(s),value(v)&#123;&#125;<br>    &#125;;<br><br>    treeNode *root;<br><br>    treeNode *buildTree(treeNode *other) &#123;<br>        <span class="hljs-keyword">if</span>(other != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">treeNode</span> *r = new treeNode(nullptr,nullptr,nullptr,other-&gt;</span><span class="hljs-function"><span class="hljs-title">count</span>,other-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>,other-&gt;</span>value);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = buildTree(other -&gt;</span> left);<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = buildTree(other -&gt;</span> right);<br>            return r;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            return nullptr;<br>        &#125;<br>    &#125;<br><br>    void clear(treeNode *r) &#123;<br>        <span class="hljs-keyword">if</span>(r != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> left);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> right != nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">clear</span>(r -&gt;</span> right);<br>            &#125;<br>            delete r;<br>        &#125;<br>    &#125;<br>public:<br>    BinarySearchTree():root(nullptr)&#123;&#125;<br><br>    BinarySearchTree(const BinarySearchTree &amp;other) &#123;<br>        root = buildTree(other.root);<br>    &#125;<br><br>    ~BinarySearchTree() &#123;<br>        clear(root);<br>    &#125;<br><br>    treeNode *search(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == val) &#123;<br>            return r;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &lt; r -&gt;</span> value)&#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">search</span>(r -&gt;</span> right,val);<br>        &#125;<br>    &#125;<br><br>    treeNode *insert(treeNode *r,int key) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            r = new treeNode(nullptr,nullptr,nullptr,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,key);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> value == key) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span>count ++;<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &lt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> left,key);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(key &gt; r -&gt;</span> value) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> = insert(r -&gt;</span> right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//返回新的根结点</span><br>    treeNode *remove(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(val &lt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = remove(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(val &gt; r -&gt;</span> value) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> right,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> count &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> count --;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr ) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> right;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> right == nullptr) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *tmp = r -&gt;</span> left;<br>                    delete r;<br>                    return tmp;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//用右子树的最小值作为新的根结点</span><br>                    <span class="hljs-function"><span class="hljs-title">treeNode</span> *pos = findMin(r -&gt;</span> right);<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> = pos -&gt;</span> count;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">value</span> = pos -&gt;</span> value;<br>                    <span class="hljs-function"><span class="hljs-title">pos</span> -&gt;</span> count = <span class="hljs-number">1</span>;<br>                    <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> = remove(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,pos -&gt;</span> value);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> count;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">r</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> += r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> ?root -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> size:<span class="hljs-number">0</span>;<br><br>        return r;<br>    &#125;<br><br>    treeNode *findMin(treeNode *r) &#123;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">r</span> = r -&gt;</span> left;<br>        &#125;<br>        return r;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名</span><br>    int queryRank(treeNode *r,int val) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value == val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                return <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> value &gt; val) &#123;<br>            <span class="hljs-function"><span class="hljs-title">return</span> queryRank(r -&gt;</span> left,val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left == nullptr) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> 1 + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> <span class="hljs-function"><span class="hljs-title">count</span> + queryRank(r -&gt;</span> right,val);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找排名为第k名的树</span><br>    int queryKth(treeNode *r,int k) &#123;<br>        <span class="hljs-keyword">if</span>(r == nullptr) &#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> left != nullptr) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> size &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> left ,k);<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> + r -&gt;</span> count &gt;= k) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-title">return</span> r -&gt;</span> value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">return</span> queryKth(r -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span>,k - (r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> ?r -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">size</span> : 0) - r -&gt;</span> count);<br>    &#125;<br>&#125;;<br><br>#endif <span class="hljs-comment">//BST_H</span><br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Still an easy one.Can’t wait to see AVL!<br>立下flag，争取这周搞定用AVL实现的map!😋</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Algorithms1</title>
    <link href="/2025/03/01/Introduction-to-Algorithms1/"/>
    <url>/2025/03/01/Introduction-to-Algorithms1/</url>
    
    <content type="html"><![CDATA[<h4 id="Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"><a href="#Before：去年12月从班主任口中得知了我们的主角——MIT-6-006-Introduction-to-Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友-three-hats-user-同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT-EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭" class="headerlink" title="Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 @three-hats-user 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭"></a>Before：去年12月从班主任口中得知了我们的主角——MIT 6.006 Introduction to Algorithms这门非常经典的课（被誉为“MIT-EECS系的瑰宝”）。室友 <a href="https://github.com/Jxint001">@three-hats-user</a> 同学在我的推荐下（自己没学别人学了🤡）在寒假卷了这门课（虽然还没学完），对它评价也很高。于是今天入手了这门课，一句话：不愧是MIT EECS🧎‍♀️🧎‍♀️🧎‍♀️另外，鉴于这门课程全部学完需要100hr，且有些算法在上学期的上机课中已经有所接触，故JaneZ并不会更新全部（有空一定会学完的呜呜呜），而是挑选一些结合这学期所学的数据结构的课程，提升辣鸡的算法能力😭😭😭</h4><h1 id="Introduction-to-Algorithms-1-Heaps-and-heap-sort"><a href="#Introduction-to-Algorithms-1-Heaps-and-heap-sort" class="headerlink" title="Introduction to Algorithms 1  Heaps and heap sort"></a>Introduction to Algorithms 1  Heaps and heap sort</h1><h2 id="Priority-Queues-Definition"><a href="#Priority-Queues-Definition" class="headerlink" title="Priority Queues Definition"></a>Priority Queues Definition</h2><p>A data structure implementing a set S of elements,each associated with a key,supporting the following operations: </p><ul><li>insert(S,x)</li><li>max(S)</li><li>extract_max(S):return element of S with largest key and remove it from S</li><li>increase_key(S,x,k):increase the value of element x’ s key to new value k</li></ul><p>Priority Queues can be built by using Heap or AVL.</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>As I said seconds before,<strong>Heap</strong> is one of the Implementations of a priority queue.</p><p>First,we are going to visualize an <strong>Array</strong> as a <strong>nearly complete binary tree</strong>（完全二叉树）</p><p>Let’s just talk about <strong>Max Heap</strong> here（Min Heap is exactly the same）</p><p><strong>Max Heap Property</strong>:The key of a node is $\geq$ than the key children.<br>For example:</p><p><img src="/img/%E5%A4%A7%E6%A0%B9%E5%A0%86%E4%BE%8B%E5%AD%90.png" alt="Max Heap Example"></p><p>Almost the same basic characteristics as Binary Tree</p><p>Here’re some simple Heap Operations:</p><ul><li>build max heap: produce a max-heap from an unordered array</li><li><strong>max_heapify</strong>: correct a single violation(违反) of the heap property in a subtree at its root</li><li>insert,extract_max,heapsort</li></ul><h3 id="The-most-important-procedure-Max-heapify"><a href="#The-most-important-procedure-Max-heapify" class="headerlink" title="The most important procedure: Max_heapify"></a>The most important procedure: Max_heapify</h3><p>• Assume that the trees rooted at left(i) and right(i) are max-heaps.</p><p>• If element A[i] violates the max-heap property, correct violation by “trickling” element A[i] down the tree, making the subtree rooted at index i a max-heap.</p><p>Here is an example of Max_heapify:<br><img src="/img/Heapify1.png" alt="Max_heapify1"><br><img src="/img/Heapify2.png" alt="Max_heapify2"><br><img src="/img/Heapify3.png" alt="Max_heapify3"></p><p>Time Complexity: O(logN)</p><h3 id="Build-Max-Heap"><a href="#Build-Max-Heap" class="headerlink" title="Build Max Heap"></a>Build Max Heap</h3><p>For n&#x2F;2 to 1  &#x2F;&#x2F;从后往前第一个非叶节点开始<br>    do Max_heapify(A,i)</p><p>这里我们很容易“看出”时间复杂度是O(NlogN)，然而真的如此嘛？<br>可以想一下，最底一层的非叶结点进行的操作次数至多只有1次，而并非logN次，只有根结点才会进行logN次操作，所以经过数学推导，我们可以验证，建堆操作的时间复杂度是O(N)</p><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p>I think it’s just a simple use of Max_Heap.Easy to understand and I will just show the thoughts.<br>(1)Build Max_Heap from an unordered array.<br>(2)Find A[1] (the biggest element)<br>(3)Swap elements A[1] and A[n]<br>(4)Discard(移除) n from the heap<br>(5)Run MaxHeapify to fix the missing 1 place<br>(6)Go to Step 2 until empty</p><p>The time complexity of Heap Sort is O(NlogN)</p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>这节的内容整体还是挺容易的，特别是在写完priority_queue之后😋<br>Keep Going!</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic2</title>
    <link href="/2025/02/28/Mathematical-Logic2/"/>
    <url>/2025/02/28/Mathematical-Logic2/</url>
    
    <content type="html"><![CDATA[<h5 id="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"><a href="#Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅" class="headerlink" title="Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅"></a>Before：哎呀数理逻辑真的好抽象😭本来英语就烂，还有一大堆新定义的符号，绕在一起，感觉更像是在学语言而不是数学😥再加上周五晚上连上3节😅</h5><h5 id="Result：果断重开了"><a href="#Result：果断重开了" class="headerlink" title="Result：果断重开了"></a>Result：果断重开了</h5><h5 id="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"><a href="#Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！" class="headerlink" title="Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！"></a>Decision：我一定要用中文把这门课搞清楚，抵制洋文！！！</h5><h1 id="Mathematical-Logic-2-一阶逻辑的语义"><a href="#Mathematical-Logic-2-一阶逻辑的语义" class="headerlink" title="Mathematical Logic 2 一阶逻辑的语义"></a>Mathematical Logic 2 一阶逻辑的语义</h1><h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><p>在不同的场合下，同一个一阶逻辑命题可能有不同的含义。如对∀v0Rv0v0，既可以解读成“任意自然数都整除自己”（真），也可以解读成“任何实数都小于自己”（假）<br>So：讨论语义时首先需要确定讨论的数学对象</p><p>刚刚的例子中，自然数和实数明确了讨论对象取自怎样的集合，这个集合称作<strong>域</strong>（universe），记为A</p><p>确定符号集中每个符号的含义，就是确定每个符号对应的元素、集合或映射具体是什么：</p><ul><li>一个n元关系就是某个A^n的子集 a(R)</li><li>一个n元函数就是某个A^n到A的映射 a(f)</li><li>每个常数符号对应A中某个特定元素 a(c)</li></ul><p>我们把这个从符号到其具体含义的映射记为a。<br>A 和 a 确定了一阶逻辑中变量的“定义域”和符号集中每个符号的含义。我们把二元组(A,a)记为 𝔄，称作<strong>S-结构</strong>。</p><p>对于符号集S &#x3D; {R,f,c}，我们通常将a(R)写作$R^𝔄$或$R^A$，a(f)写作$f^𝔄$或$f^A$，a(c)写作$c^𝔄$或$c^A$。</p><h2 id="Interpretation-解释"><a href="#Interpretation-解释" class="headerlink" title="Interpretation 解释"></a>Interpretation 解释</h2><p>Structure给出了变量的定义域和符号集的语义，但我们接下来还有<strong>terms</strong>和<strong>formulas</strong></p><p><strong>一个term的语义是从一个term到universe中一个元素的映射</strong>——$\beta$<br>为了确定这个映射，我们首先需要知道term中的每个变量代表universe当中的哪个元素，这就是要我们给出一个$v_i$ -&gt; A 的映射$\beta$</p><p>所以我们把一个S-structure和一个S-assignment的二元组称作I &#x3D; (𝔄,$\beta$)<br>定义<strong>解释</strong>的语义</p><ul><li>对于变量x，I(x) &#x3D; $\beta$(x)</li><li>对于常量c，I(c) &#x3D; $c^𝔄$</li><li>对于n元函数关系f $\in$ S，$t_1,t_2,…,t_n$均为S-terms。那么有I(ft_1 … t_n) &#x3D; $f^𝔄$(I(t_1),I(t_2),…,I(t_n))</li></ul><p><strong>formula的语义是从一个term到“真或假”的映射(类似于bool?)</strong><br>对于一个formula 𝜑  ，我们用记号 I |&#x3D; 𝜑  来表示 公式 𝜑 的语义为真，读作I 满足𝜑 ，|&#x3D; 即称为<strong>满足关系</strong>。（ 解释 I 满足公式 𝜑  ）</p><p>下面是一些原子性&#x2F;关于逻辑连词&#x2F;量词的情况<br><img src="/img/%E8%A7%A3%E9%87%8A%E6%BB%A1%E8%B6%B3%E5%85%AC%E5%BC%8F.png" alt="解释满足formulas"></p><p>(a) 当且仅当I(t_1)，I(t_2)是universe下的同一个元素<br>(b) 当且仅当 (I(t_1),…,I(t_n)) 属于$R^𝔄$<br>(c) 当且仅当 解释I 不满足公式 𝜑<br>(d) 当且仅当 解释I 满足公式 𝜑 且 解释I 满足公式Ψ<br>(e) 当且仅当 解释I 满足公式 𝜑  或 解释I 满足公式Ψ<br>(f) （一个有点神奇的解释）当且仅当 I |&#x3D; φ（语法上）表明解释I 满足公式 𝜑 （语义上）<br>(g) 当且仅当（还有一个当且仅当，亿点点绕）（解释I 满足 公式 𝜑 当且仅当解释I 满足公式Ψ）</p><p>比较复杂的就是 ∀ 和 ∃<br>(h) 想说的意思是：当且仅当universe中每个元素为公式 𝜑 中出现的x赋值并保持其他变量赋值不变，公式 𝜑 始终不变</p><p>为此我们定义一个描述为formula中的某个特定变量赋特殊的值的方便的符号：<br><img src="/img/Assignment.png" alt="修改赋值函数"></p><p>于是新的解释I 变为了：<br><img src="/img/%E6%96%B0%E8%A7%A3%E9%87%8A.png" alt="新的解释"><br>这表示在解释I 中，将变量 𝑥 的赋值修改为 𝑎，其他部分保持不变。</p><p>于是(h)表示的即为：对于域 𝐴中的每一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 都为真。</p><p>(i) （也是同理）存在域 𝐴中的一个元素 𝑎，如果将 𝑥 赋值为 𝑎，公式 𝜑 为真。</p><p>如果一个公式 𝜑 是valid(恒真)，那么所有的解释都能满足公式 𝜑</p><p>逻辑推论的定义：<br>Φ 是一个S-公式的集合；<br>公式 𝜑 是一个单独的S-公式<br>如果 Φ |&#x3D; 𝜑，表示 𝜑 是 Φ 的逻辑推论，即公式 𝜑 可以从 Φ 中逻辑推导出来</p><p>我们称公式 𝜑 是可满足的，如果存在一个S-解释I，使得公式 𝜑 在解释I下为真</p><p>公式 𝜑 和公式 Ψ 是逻辑等价的，如果 𝜑 |&#x3D; Ψ 且 Ψ |&#x3D; 𝜑</p><p><img src="/img/%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7.png" alt="逻辑等价例子"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/">https://xingershang.github.io/2024/08/30/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%AF%AD%E4%B9%89/</a></p><p>这位博主真的救命，讲的太清楚了</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematical-Logic1</title>
    <link href="/2025/02/21/Mathematical-Logic1/"/>
    <url>/2025/02/21/Mathematical-Logic1/</url>
    
    <content type="html"><![CDATA[<h5 id="Before-数理逻辑CS2950是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是Yin-Qiang，Yijia-Chen的学生。后续会更新这门“抽象”的课的Lecture-Notes❤️">Before: 数理逻辑<a href="https://wiki.pdy.app:8443/s/96e05898-1739-424b-8a49-85de7c83ebec">CS2950</a>是ACM班大一下要求修的一门课，这门课本质上还是一门数学课，一般也是数学系的同学可能会上的（而不是计算机系🤣）。Prof是<a href="https://cs.sjtu.edu.cn/~qyin/">Yin Qiang</a>，<a href="https://basics.sjtu.edu.cn/~chen/">Yijia Chen</a>的学生。后续会更新这门“抽象”的课的Lecture Notes❤️</h5><h1>Methematical Logic 1 Introduction &amp; The Syntax of First-order Logic</h1><h2 id="Course-Introduction">Course Introduction</h2><p>Four Problems mainly</p><ul class="lvl-0"><li class="lvl-2">What is a mathematical proof</li><li class="lvl-2">What makes a proof correct</li><li class="lvl-2">Is there a boundary of provability</li><li class="lvl-2">Can computers find proofs</li></ul><h3 id="Q1-What-is-a-mathematical-proof">Q1.What is a mathematical proof</h3><p>Based on first-order logic</p><h3 id="Q2-What-makes-a-proof-correct">Q2.What makes a proof correct</h3><p>Gödel Completeness Theorem</p><h3 id="Q3-Is-there-a-boundary-of-provability"><a href="http://Q3.Is">Q3.Is</a> there a boundary of provability</h3><p>Gödel’s First Incompleteness Theorem</p><h3 id="Q4-Can-computers-find-proofs">Q4.Can computers find proofs</h3><p>Any computer program cannot decide whether an arbitrary input mathematical statement has a proof.<br>Turing’s undecidability of the halting problem.(图灵停机问题不可判定)</p><p>Below is A Proof of Q4:<br>φP,x has a proof | P will eventually halt on input x<br>1.construct the mathematical statement φx,x<br>2.call the program T on input φx,x<br>3.if T(φx,x) = yes then run forever else halt</p><p>Then we can get that H(H) haltss iff H(H) does not halt.(Using what we know up)</p><h2 id="The-Syntax-of-First-order-Logic-一阶逻辑语法">The Syntax of First-order Logic 一阶逻辑语法</h2><h3 id="Alphabets-字母表">Alphabets 字母表</h3><p>an nonempty set of symbols 非空符号的集合</p><h3 id="Word-词">Word 词</h3><p>A word w over A(an Alphabet) is a finite sequence of symbols in A,i.e,<br>$$<br>w = w_1w_2…w_n<br>$$<br>$<br>w_i \in A<br>$<br>$A^*$ denotes the set of all words over A</p><h3 id="Countable-Set">Countable Set</h3><p>There exists an injective function(单射) α from N onto M<br>At most countable: if M is either finite or countable</p><p>Two lemmas<br>1.These three equivalent:<br>(1)M is at most countable<br>(2)an surjective function f:N -&gt; M<br>(3)an injective function f:M -&gt; N<br>2.A is most countable,then $A^*$ is countable.</p><h3 id="Terms-项">Terms 项</h3><p>Variable Constant are both S-terms.<br>And if f is a n-ary function symbol in S,then f(S-terms) is also a S-term.</p><h3 id="Formula-公式">Formula 公式</h3><p>The set $L^S$ of S-formulas contains precisely those words in $A^∗_S$ which can be obtained by applying the following rules finitely many times.<br><img src="/img/Formula.png" alt="Formula Rules"></p><h3 id="Variables-变量">Variables 变量</h3><p>Let t be a S-term, then var(t) is the set of variables in t.</p><h3 id="Free-Variables-自由变元">Free Variables 自由变元</h3><p>We say that an occurrence of x in φ is free if it is not in the scope of any ∀x or ∃x.<br>只有出现在约束范围内的变量才算是约束出现的</p><h3 id="Sentence-句子">Sentence 句子</h3><p>If free(φ) is ∅,then it’s a sentence. 没有自由变元<br>Reflect Mathematical characteristics.<br>$L_N^S$:= {φ | φ an S-formula with free(φ) ⊆ {v0, . . . , vn−1}}.</p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Logic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematical Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
